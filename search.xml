<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web开发</title>
      <link href="/2024/11/04/web%E5%BC%80%E5%8F%91/"/>
      <url>/2024/11/04/web%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h1><h2 id="前端的代码如何转换成网页"><a href="#前端的代码如何转换成网页" class="headerlink" title="前端的代码如何转换成网页"></a>前端的代码如何转换成网页</h2><p>通过浏览器的<strong>内核</strong>转化（解析和渲染）成用户看到的网页</p><h2 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h2><ul><li>也叫网页标准，又一系列标准组成，大部分由W3C（World Wide Web Consortium，万维网联盟）负责制定。</li><li>三个组成部分：<ul><li>HTML：负责网页的<strong>结构</strong>（页面元素和内容）</li><li>CSS：负责网页的<strong>表现</strong>（页面元素的外观、位置等页面样式，如：颜色、大小等）</li><li>JavaScript：负责网页的<strong>行为</strong>（交互效果，如：轮播图）</li></ul></li></ul><h2 id="HTML、CSS"><a href="#HTML、CSS" class="headerlink" title="HTML、CSS"></a>HTML、CSS</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>HTML（HyperText Markup Language）：超文本标记语言</p><ul><li>超文本：超越了文本的限制，处理文字信息，还可以定义图片、音频、视频等内容</li><li>标记语言：由标签构成的语言<ul><li>HTML语言都是<strong>预定义</strong>好的，如：使用&lt;a&gt;展示超链接，&lt;img&gt;展示图片，&lt;video&gt;展示视频</li><li>HTML代码直接在浏览器中运行，HTML标签由浏览器解析</li></ul></li></ul></li><li><p>CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式（表现）。</p></li></ul><h3 id="HTML的结构标签示例"><a href="#HTML的结构标签示例" class="headerlink" title="HTML的结构标签示例"></a>HTML的结构标签示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML的一些语法特点"><a href="#HTML的一些语法特点" class="headerlink" title="HTML的一些语法特点"></a>HTML的一些语法特点</h3><ul><li>标签不区分大小写</li><li>标签的属性既可以使用双引号，也可以使用单引号</li><li>语法结构松散（语法不严格）</li></ul><h3 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h3><ul><li><p>行内样式（不推荐）：写在标签的style属性中</p><ul><li><p>只针对当前一个标签</p></li><li><p>格式：属性名：属性值；</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> style=&quot;xxx: xxx; xxx: xxx;&quot;&gt;标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定在head标签中）</p><ul><li>对于当前HTML文件的所有该标签都生效</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        xxx: xxx;</span></span><br><span class="line"><span class="language-css">        xxx :xxx;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外联样式：写在一个单独的.css文件中（通过link标签从网页中引入）(link写在&lt;head&gt;中)</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    xxx: xxx;</span><br><span class="line">    xxx: xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/news.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>用来选取需要设置样式的元素（标签）</p><ul><li>元素选择器：如上</li><li>id选择器：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#hid</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;hid&quot;</span>&gt;</span>CSS id Selector<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>类选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cls</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>CSS class Selector<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优先级：id选择器 &gt; 类选择器 &gt; 元素选择器</strong></p><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p><strong>盒子</strong>：页面中所有的元素（标签），都可以看成一个盒子，由盒子将页面的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局。</p><p><strong>组成</strong>：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）</p><p>与&lt;div&gt;和&lt;span&gt;一起使用</p><h3 id="HTML实现"><a href="#HTML实现" class="headerlink" title="HTML实现"></a>HTML实现</h3><h4 id="图片标签："><a href="#图片标签：" class="headerlink" title="图片标签：&lt;img&gt;"></a>图片标签：&lt;img&gt;</h4><p>格式：&lt;img src&#x3D;”…” width&#x3D;”…” height&#x3D;”…”&gt;</p><ul><li><p>src：图片资源路径</p><ul><li>绝对路径<ul><li>绝对磁盘路径</li><li>绝对网络路径</li></ul></li><li>相对路径（推荐）：.&#x2F; ：当前目录（即HTML文件所在目录）（可省略）；..&#x2F; ：上一级目录</li></ul></li><li><p>width：宽度（px，像素；%，相对于父元素的百分比）</p></li><li><p>height：高度（一般高度和宽度只写一个，就可以等比例缩放）</p></li></ul><h4 id="标题标签："><a href="#标题标签：" class="headerlink" title="标题标签：&lt;h1&gt;"></a>标题标签：&lt;h1&gt;</h4><p><em>只有&lt;h1&gt; 到 &lt;h6&gt;</em></p><p>格式：&lt;h1&gt;……&lt;&#x2F;h1&gt;</p><h4 id="水平线标签："><a href="#水平线标签：" class="headerlink" title="水平线标签：&lt;hr&gt;"></a>水平线标签：&lt;hr&gt;</h4><p>格式：&lt;hr&gt;</p><p><em>只需写一个&lt;hr&gt;就可以</em></p><h4 id="无意义标签："><a href="#无意义标签：" class="headerlink" title="无意义标签：&lt;div&gt; &#x2F; &lt;span&gt;"></a>无意义标签：&lt;div&gt; &#x2F; &lt;span&gt;</h4><p>没有语义的布局标签，用于将不是任何标签的文字进行格式的修改</p><p>特点：</p><ul><li>&lt;div&gt;：一行只显示一个（独占一行）；宽度默认时父元素的宽度，高度默认由内容撑开；可以设置宽高</li><li>&lt;span&gt;：一行可以显示多个（组合行内元素）；宽度和高度默认由内容撑开；不可以设置宽高</li></ul><h4 id="超链接："><a href="#超链接：" class="headerlink" title="超链接：&lt;a&gt;"></a>超链接：&lt;a&gt;</h4><p>格式：&lt;a href&#x3D;”…” target&#x3D;”…”&gt;央视网&lt;&#x2F;a&gt;</p><p>属性：href：资源访问的url；target：在何处打开（_self：默认值，在当前页面；_blank：在空白页面打开）</p><p><em>超链接默认蓝色加下划线，如果想修改需要用text-decoration来修改</em></p><h4 id="视频标签："><a href="#视频标签：" class="headerlink" title="视频标签：&lt;video&gt;"></a>视频标签：&lt;video&gt;</h4><p>src：视频的url</p><p>controls：显示播放控件</p><p>width：宽度</p><p>height：高度</p><h4 id="音频标签："><a href="#音频标签：" class="headerlink" title="音频标签：&lt;audio&gt;"></a>音频标签：&lt;audio&gt;</h4><p>src：音频的url</p><p>controls：显示播放控件</p><h4 id="段落标签："><a href="#段落标签：" class="headerlink" title="段落标签：&lt;p&gt;"></a>段落标签：&lt;p&gt;</h4><h4 id="文本加粗标签："><a href="#文本加粗标签：" class="headerlink" title="文本加粗标签：&lt;b&gt; &#x2F; &lt;strong&gt;"></a>文本加粗标签：&lt;b&gt; &#x2F; &lt;strong&gt;</h4><h4 id="换行标签："><a href="#换行标签：" class="headerlink" title="换行标签：&lt;br&gt;"></a>换行标签：&lt;br&gt;</h4><h4 id="表格标签："><a href="#表格标签：" class="headerlink" title="表格标签：&lt;table&gt; &#x2F; &lt;tr&gt; &#x2F; &lt;td&gt;"></a>表格标签：&lt;table&gt; &#x2F; &lt;tr&gt; &#x2F; &lt;td&gt;</h4><ul><li>&lt;table&gt;：定义表格整体，包含多个&lt;tr&gt;。border：表格边框宽度；width：表格宽度；cellspacing：单元之间的空间</li><li>&lt;tr&gt;：表格的行，包含多个&lt;td&gt;</li><li>&lt;td&gt;：表格单元格（普通），如果是表头单元格，可以替换为&lt;th&gt;（自带居中和加粗）</li></ul><h4 id="表单标签："><a href="#表单标签：" class="headerlink" title="表单标签：&lt;form&gt;"></a>表单标签：&lt;form&gt;</h4><p>负责数据的采集，如：注册、登陆等数据的采集</p><p><strong>表单项</strong>：不同类型的input元素、下拉列表、文本域等</p><ul><li><p>&lt;input&gt;：定义表单项，通过type属性控制输入形式（text（默认）、password（密码字段）、radio（单选按钮）、checkbox（复选框）、file（文件上传）、date&#x2F;time&#x2F;datetime-local（日期&#x2F;时间&#x2F;日期时间）、number（数字输入框）、email（邮箱输入框）、hidden（隐藏框）、submit&#x2F;reset&#x2F;button（提交。重置&#x2F;可点击按钮））（单选框和复选框中每个input均需要用&lt;label&gt;&lt;&#x2F;label&gt;包含，尤其是单选框，表示不可多选）</p></li><li><p>&lt;select&gt;：定义下拉列表，&lt;option&gt;定义列表项</p></li><li><p>&lt;textarea&gt;：定义文本域</p></li></ul><p><strong>注意：表单项必须有name属性才可以提交</strong></p><p>表单项中<strong>value</strong>属性可以控制传入的值</p><p><strong>属性</strong>：</p><ul><li>action：规定当提交表单时向何处发送表单数据—URL（不指定就默认提交到当前页面）</li><li>method：规定用于发送表单数据的方式—POST&#x2F;GET（默认为GET）<ul><li>GET：表单数据拼接在url后面（？username&#x3D;java），大小有限制</li><li>POST：表单数据在请求体中携带，大小没有限制</li></ul></li></ul><h3 id="CSS实现"><a href="#CSS实现" class="headerlink" title="CSS实现"></a>CSS实现</h3><h4 id="颜色：color"><a href="#颜色：color" class="headerlink" title="颜色：color"></a>颜色：color</h4><p>格式：color: red;</p><p><strong>颜色表示形式</strong></p><ul><li>关键字：red、blue</li><li>rgb表示法：rgb(0,0,255)  <em>（红绿蓝三原色）</em></li><li>十六进制表示法：#ff0000   <em>（每两位代表rgb的一位）（可以简写成#f00，即在每个rgb的两位相同时写一个即可）</em></li></ul><h4 id="字体：font-size"><a href="#字体：font-size" class="headerlink" title="字体：font-size"></a>字体：font-size</h4><p><em>记得后面加上px</em></p><h4 id="文本装饰：text-decoration"><a href="#文本装饰：text-decoration" class="headerlink" title="文本装饰：text-decoration"></a>文本装饰：text-decoration</h4><p>none：默认，标准文本</p><p>underline：下划线</p><p>overline：上划线</p><p>line-through：穿过文本的一条线</p><h4 id="首行缩进：text-indent"><a href="#首行缩进：text-indent" class="headerlink" title="首行缩进：text-indent"></a>首行缩进：text-indent</h4><p>常与&lt;p&gt;一起使用</p><h4 id="设置行高：line-height"><a href="#设置行高：line-height" class="headerlink" title="设置行高：line-height"></a>设置行高：line-height</h4><p>常与&lt;p&gt;一起使用</p><h4 id="对齐方式：text-align"><a href="#对齐方式：text-align" class="headerlink" title="对齐方式：text-align"></a>对齐方式：text-align</h4><p>包括center、left、right</p><h4 id="盒子模型相关："><a href="#盒子模型相关：" class="headerlink" title="盒子模型相关："></a>盒子模型相关：</h4><p>width</p><p>height</p><p>box-sizing：指定宽高指的是哪个部分的（eg. border-box）</p><p>background-color</p><p>padding：内边距（上 右 下 左）（一致时可以只写一个）（写三个时分别为上 左右 下；两个时分别为上下 左右）（可以写auto，代表浏览器自动计算）</p><p>border：边框（宽度 线条类型 颜色）</p><p>margin：外边框（上 右 下 左）</p><p>（如果只设置某一个方位的边框、内边距、外边距，可以在属性名后加上-位置，如：padding-top\padding-left…）</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>跨平台、面向对象的脚本语言（不需要编译）。用来控制网页行为，能使网页可交互</li><li>JS与Java是完全不同的语言，无论是概念还是设计，但是基础语法类似</li></ul><h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><ul><li><strong>内部脚本</strong>：将JS代码定义在HTML页面中<ul><li>JS代码必须位于&lt;script&gt;&lt;&#x2F;script&gt;标签之间</li><li>在HTML文档中，可以在任意地方放置任意数量的&lt;script&gt;</li><li>一般会把脚本置于&lt;body&gt;元素的底部，可以改善显示速度</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;Hello JS&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>外部脚本</strong>：将JS代码定义在外部JS文件中，然后引入到HTML页面中<ul><li>外部JS文件中，只包含JS代码，不包含&lt;script&gt;标签</li><li>&lt;script&gt;标签不能自闭合<em>（自闭合：本来要用一个配对的结束符号来关闭，然而它却自己关闭了，如：&lt;script src&#x3D;”js&#x2F;demo.js”&gt;）</em></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>demo.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello JS&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li>区分大小写</li><li>每行结尾分号可写可不写</li></ul><h4 id="输出语句："><a href="#输出语句：" class="headerlink" title="输出语句："></a>输出语句：</h4><ul><li>弹出警告框：window.alert()</li><li>在浏览器中展示：document.write()</li><li>写入浏览器控制台：console.log()</li></ul><h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><ul><li>用var关键字（variable）来声明变量</li><li>JS是一门弱类型语言，变量可以存放不同类型的值</li><li>变量名需要遵循以下规则：<ul><li>组成字符可以是任何字母、数字、下划线或美元符号$</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li></ul><p><strong>特点</strong>：</p><ul><li>作用域大，全局变量</li><li>可以重复定义</li></ul><p><strong>新增</strong>：</p><ul><li><strong>let关键字</strong>：与var类似，但是是局部变量，而且不能重复定义</li><li><strong>const关键字</strong>：声明只读的常量</li></ul><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><ul><li>原始类型：number、string、boolean、null、undefined</li><li>引用类型—object</li></ul><p>（使用typeof运算符可以获取数据类型）</p><h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><ul><li>算术运算符</li><li>赋值运算符</li><li>比较运算符：（多一个&#x3D;&#x3D;&#x3D;）</li><li>逻辑运算符</li><li>三元运算符</li></ul><p><em>=&#x3D;与=&#x3D;&#x3D;的区别：=&#x3D;会进行类型转换，===不会进行类型转换，=&#x3D;=会同时比较数据类型和数据</em></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义：用function关键字</p><p>方式：</p><ul><li><p>方式一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>形参不需要指明类型</li><li>返回值不需要指明类型</li><li>函数调用可以传递任意多个的参数，函数只会取前几个作为参数</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><strong>定义</strong>：</p><ul><li><p>var 变量名 &#x3D; new Array(元素列表);</p></li><li><p>var 变量名 &#x3D; [元素列表];</p></li></ul><p><strong>访问</strong>：</p><p>arr[索引] &#x3D; 值;</p><p>特点：长度可变，类型可变（可以存储任意类型的数据）</p><p><strong>属性</strong>：</p><ul><li>length：返回数组元素数量</li></ul><p><strong>方法</strong>：</p><ul><li>forEach ()：遍历数组中<strong>有值</strong>的元素，并调用一次传入的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="params"><span class="keyword">function</span>(e)</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用function，并将获得的值存入e</p><p>可简写为<strong>箭头函数</strong>：(…) &#x3D;&gt; {…} （小括号中放形参列表）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>push()：在末尾添加新元素，并返回新长度</li><li>splice()：删除元素（传两个参：从哪个索引开始，删几个）</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>创建方式</strong>：</p><ul><li>var 变量名 &#x3D; new String(“…”)；</li><li>var 变量名 &#x3D; “…”；</li></ul><p><strong>属性</strong>：</p><ul><li>length</li></ul><p><strong>方法</strong>：</p><ul><li>charAt()</li><li>indexOf()：检索字符串位置</li><li>trim()：去除字符串两边的空格</li><li>substring()</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p><strong>JS自定义对象</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">属性名<span class="number">1</span>: 属性值<span class="number">1</span>,</span><br><span class="line">属性名<span class="number">2</span>: 属性值<span class="number">2</span>,</span><br><span class="line">    函数名称: <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>函数可省略为: 函数名称 () {}</em></p><p><strong>概念</strong>：JavaScript Object Notation，JS对象标记法</p><ul><li>JSON是通过JS对象标记法书写的文本、</li><li>由于语法简单，层次结构鲜明，现多用于<strong>作为数据载体</strong>，在网络中进行数据传输</li></ul><p><strong>定义</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&#x27;&#123;&quot;key1&quot;: value1, &quot;key2&quot;: value2&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>value的数据类型：</p><ul><li>数字：直接写整数或浮点数</li><li>字符串：放在双引号中</li><li>逻辑值：直接写</li><li>数组：放在方括号中</li><li>对象：放在花括号中</li><li>null</li></ul><p><strong>JSON字符串转换为JS对象</strong>：</p><p>var jsObject &#x3D; JSON.parse(jsonStr);</p><p><em>（转换为对象后就可以通过.属性拿到内部某个属性值）</em></p><p><strong>JS对象转换为JSON字符串</strong></p><p>var jsonStr &#x3D; JSON.stringify(jsObject);</p><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p><strong>概念</strong>：Browser Object Model，浏览器对象模型，允许JS与浏览器对话，JS将浏览器的各个组成部分封装为对象</p><p><strong>组成</strong>：</p><ul><li>Window：浏览器窗口对象<ul><li>获取：<ul><li>直接使用window，其中window.可以省略。（比如window.alert(“Hello”)等价于alert(“Hello”)）</li></ul></li><li>属性<ul><li>history</li><li>location</li><li>navigation</li></ul></li><li>方法<ul><li>alert()：显示带有一段消息和一个确认按钮的警告框</li><li>confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框（返回布尔值）</li><li>setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式（执行多次）</li><li>setTimeout()：在指定的毫秒数后调用函数或计算表达式（执行一次）</li></ul></li></ul></li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象<ul><li>介绍：地址栏对象</li><li>获取：使用windows.location获取，其中windows.可以省略</li><li>属性：<ul><li>href：设置或返回完整的URL</li></ul></li></ul></li></ul><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p><strong>概念</strong>：Document Object Model，文档对象模型</p><p><strong>分类</strong>：将标记语言的各个组成部分封装为对应的对象</p><ul><li>Document：整个文档对象</li><li>Element：元素对象（每一个标签）</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p><strong>作用</strong>：</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式（CSS）</li><li>对HTML DOM事件作出反应</li><li>添加和删除HTML元素</li></ul><p><strong>组成</strong>：</p><ul><li>Core DOM - 所有文档类型的标准模型<ul><li>Document：整个文档对象</li><li>Element：元素对象（每一个标签）</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li>XML DOM - XML文档的标准模型</li><li>HTML DOM - HTML文档的标准模型<ul><li>Image：&lt;img&gt;</li><li>Button：&lt;input type&#x3D;’button’&gt;</li><li>……</li></ul></li></ul><p><strong>获取方式</strong>：</p><ul><li>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的</li><li>Document对象中提供了以下获得Element元素对象的函数：<ul><li>根据id属性值，返回当Element对象：var h1 &#x3D; document.getElementById(‘h1’);</li><li>根据标签名，返回数组：getElementsByTagName</li><li>根据name属性值，返回数组：getElementsByName</li><li>根据class属性值，返回数组：getElementsByClassName</li></ul></li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h4><p>HTML事件是发生在HTML元素上的”事情“。比如：点击按钮、按下键盘……</p><h4 id="事件监听："><a href="#事件监听：" class="headerlink" title="事件监听："></a>事件监听：</h4><p>JS可以在事件被侦测到时<strong>执行代码</strong></p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ul><li>方式一：通过HTML标签中的事件属性进行绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;我被点击了&#x27;</span>)；</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方式二：通过DOM元素属性进行绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;我被点击了&#x27;</span>)；</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h4><ul><li>onclick：点击</li><li>onblur：失去焦点</li><li>onfocus：获得焦点</li><li>onload：页面或图像完全加载</li><li>onsubmit：表单提交</li><li>onkeydown：按下键盘上某个键</li><li>onmouseover：鼠标移到某元素之上</li><li>onmouseout：鼠标从某元素移开</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>是一套<strong>前端框架</strong>，免除原生JS中的DOM操作，简化书写。</p><p>基于<strong>MVVM</strong>（Model-View-ViewModer）思想，实现数据的*双向绑定**，将编程的关注点放在数据上。</p><p><strong>格式</strong>：</p><ul><li>新建HTML页面，引入Vue.js文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在JS代码区域，创建Vue核心对象，定义数据类型</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">new Vue&#123;&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">message: “Hello Vue&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handle: functiono()&#123;</span><br><span class="line">                alert(&quot;点击&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写视图</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>插值表达式</strong>：</p><ul><li>形式：</li><li>内容可以是：变量、三元运算符、函数调用、算术运算</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>v-bind：动态绑定属性值，如：href、css样式等</li><li>v-model：为表单元素创建双向数据绑定（可简写为@）</li><li>v-on：为html标签添加事件</li><li>v-if：为true时渲染某元素，否则不渲染（就是没有了）</li><li>v-else-if：跟if组合用</li><li>v-else：跟if组合用</li><li>v-show：展示某元素（区别：切换的是display属性的值，true则展示，否则隐藏，而不是没有）</li><li>v-for：列表渲染，变量容器的元素或对象的属性</li></ul><p>注意：</p><ul><li>通过v-bind或者v-model绑定的变量，必须在数据模型中声明</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>概念</strong>：指一个对象从创建到销毁的整个过程</p><p><strong>八个阶段</strong>：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted：挂载完成——Vue初始化成功，HTML页面渲染成功。（发送请求到服务端，加载数据）</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>以.vue结尾</p><p><strong>组成部分</strong>：</p><ul><li>&lt;template&gt;：模板部分，由它生成HTML代码</li><li>&lt;script&gt;：控制模板的数据来源和行为，相当于js文件</li><li>&lt;style&gt;：css样式部分</li></ul><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul><li>创建页面，完成页面的整体布局规划</li><li>布局中各个部分的组件实现</li><li>列表数据的异步加载，并渲染展示</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><strong>前端路由</strong>：URL中的hash（#号）与组件之间的对应关系</p><p><strong>Vue Router</strong>：</p><p>组成：</p><ul><li>VueRouter：路由器类，根据路由请求在路由视图中动态渲染选中的组件</li><li>&lt;router-link&gt;：请求链接组件，浏览器会解析为&lt;a&gt;<ul><li>eg. &lt;router-link to&#x3D;”&#x2F;dept”&gt;部门&lt;&#x2F;router-link&gt;</li></ul></li><li>&lt;router-view&gt;：动态视图组件，用来渲染展示与路由路径对应的组件<ul><li>eg. 写在APP.vue的&lt;template&gt;中：&lt;router-view&gt;&lt;&#x2F;router-view&gt;</li></ul></li></ul><h1 id="web后端"><a href="#web后端" class="headerlink" title="web后端"></a>web后端</h1><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>是一款管理和构建java项目的工具</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题</li><li><strong>统一项目结构</strong>：提供标准、统一的项目结构</li><li><strong>项目构建</strong>：标准跨平台的自动化项目构建方式</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><strong>groupId</strong>：项目隶属组织名称（通常是域名反写）</li><li><strong>artifactId</strong>：项目名称</li><li><strong>version</strong>：项目版本号</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li><p>依赖具有<strong>传递性</strong>：分为直接依赖和间接依赖</p><ul><li>为了主动断开依赖的资源，需要<strong>排除依赖</strong>——&lt;exclusions&gt;（被排除的资源无需指定版本）</li></ul></li><li><p><strong>依赖范围</strong>：用&lt;scope&gt;…&lt;&#x2F;scope&gt;设置其作用范围</p><ul><li>包括主程序有效、测试程序有效、参与打包运行三种范围</li></ul></li><li><p><strong>生命周期</strong>：为了所有的maven项目构建过程进行抽象和统一，包括以下三套生命周期：</p><ul><li>clean：清理工作<ul><li>clean：移除上一次构建生成的文件</li></ul></li><li>default：核心工作<ul><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架进行测试（junit）</li><li>package：将编译后的文件打包</li><li>install：安装项目到本地仓库</li></ul></li><li>site：生成报告、发布站点等</li></ul><p>注意：在同一套<strong>生命周期</strong>中当运行后面的阶段时，前面的阶段都会运行。</p></li></ul><h4 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h4><p>简化依赖配置，引入起步依赖就相当于引入了这一块业务开发所需要的全部依赖。原理是Maven的依赖传递。</p><ul><li><p>spring-boot-starter-web：包含了web应用开发所需的常见依赖</p></li><li><p>spring-boot-starter-test：包含了单元测试所需的常见依赖</p></li></ul><p><em>起步依赖的版本无须声明，在父工程中进行了统一管理</em></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>基于TCP协议：面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>无状态：对于事务处理没有记忆能力。每次请求-响应都是独立的。<ul><li>缺点：多次请求间不能共享数据</li><li>优点：速度快</li></ul></li></ul><h3 id="请求数据格式："><a href="#请求数据格式：" class="headerlink" title="请求数据格式："></a>请求数据格式：</h3><ul><li><p>请求行：请求数据第一行（请求方式、资源路径、协议）</p></li><li><p>请求头：第二行开始，格式key：value</p><ul><li>Host：请求的主机名</li><li>User-Agent：浏览器版本</li><li>Accept：浏览器能接收的资源类型</li><li>Accept-Language：浏览器偏好的语言，服务器可以据此返回不同语言的网页</li><li>Accept-Encoding：浏览器可以支持的压缩类型</li><li>Content-Type：请求主体的数据类型</li><li>Content-Length：请求主体的大小（单位：字节）</li></ul></li><li><p>请求体：Post请求，存放请求参数</p></li></ul><p><strong>请求方式-GET</strong>：请求参数在请求行中，没有请求体，如：&#x2F;brand&#x2F;findAll？name&#x3D;OPPO&amp;status&#x3D;1。GET请求大小是有限制的。</p><p><strong>请求方式-POST</strong>：请求参数在请求体中，POST请求大小是没有限制的。</p><h3 id="响应格式："><a href="#响应格式：" class="headerlink" title="响应格式："></a>响应格式：</h3><ul><li>响应行：响应数据第一行（协议、状态码、描述）<ul><li>200：客户端请求成功</li><li>404：请求资源不存在，一般是URL输入错误，或者网站资源被删除了</li><li>500：服务器发生不可预期的错误</li></ul></li><li>响应头：第二行开始，格式key：value<ul><li>Content-Type：响应内容的类型</li><li>Content-Length：响应内容的长度（字节数）</li><li>Content-Encoding：响应压缩算法</li><li>Cache-Control：客户端应该如何缓存</li><li>Set-Cookie：告诉浏览器为当前页面所在的域设置cookie</li></ul></li><li>响应体：存放响应数据</li></ul><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务“。</p><ul><li>对HTTP协议的操作进行封装，简化web程序开发</li><li>部署web项目，对外提供网上信息浏览服务</li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ul><li>一个轻量级的web容器，支持servlet、jsp等少量javaEE规范</li><li>也称为web容器、servlet容器（servlet程序需要依赖于Tomcat才能运行）</li></ul><p><em>（HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时将不需要输入端口号）</em></p><p>基于SpringBoot开发的web应用程序，内置了tomcat服务器，当启动类运行时，会自动启动内嵌的tomcat服务器。</p><h2 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>请求响应：</p><ul><li>请求（HttpServletRequest）：获取请求数据</li><li>响应（HttpServletResponse）：设置响应数据</li><li>BS架构：Browser&#x2F;Server，浏览器&#x2F;服务器架构模式，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。（优点：维护方便；缺点：体验一般）</li><li>CS架构：Client&#x2F;Server，客户端&#x2F;服务器架构模式。（优点：体验好；缺点：开发、维护麻烦）</li></ul><h3 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h3><h4 id="原始方式："><a href="#原始方式：" class="headerlink" title="原始方式："></a>原始方式：</h4><ul><li>Controller方法形参中声明HttpServletRequest对象</li><li>调用对象的getParameter（参数名）</li></ul><h4 id="SpringBoot中接收简单参数"><a href="#SpringBoot中接收简单参数" class="headerlink" title="SpringBoot中接收简单参数"></a>SpringBoot中接收简单参数</h4><ul><li>请求参数名与方法形参变量名相同</li><li>会自动进行类型转换</li></ul><h4 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h4><ul><li>方法形参名称与请求参数名称不匹配，通过该注解完成映射</li><li>该注解的required属性默认为true，代表请求参数必须传递</li></ul><h3 id="实体参数"><a href="#实体参数" class="headerlink" title="实体参数"></a>实体参数</h3><p><strong>简单实体参数</strong>：请求参数名与形参对象属性名相同即可</p><p><strong>复杂实体对象</strong>：请求参数名与形参对象属性名相同，按照对象层次结构关系即可</p><h3 id="数组集合参数"><a href="#数组集合参数" class="headerlink" title="数组集合参数"></a>数组集合参数</h3><p><strong>数组</strong>：请求参数名与形参中数组变量名相同，可以直接使用数组封装</p><p><strong>集合</strong>：请求参数名与形参中集合变量名相同，通过@RequestParam绑定参数关系（因为默认是用数组传递的）</p><h3 id="日期参数"><a href="#日期参数" class="headerlink" title="日期参数"></a>日期参数</h3><p>使用@DateTimeFormat注解完成日期参数格式转换</p><p>eg.(@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”) LocalDateTime updateTime)</p><h3 id="JSON参数"><a href="#JSON参数" class="headerlink" title="JSON参数"></a>JSON参数</h3><p>JSON数据键名与形参对象属性名相同，需要使用@RequestBody标识</p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>通过请求URL直接传递参数，使用{…}来标识路径参数，需要使用**@PathVariable**获取路径参数</p><p><strong>一个方法中可以有多个路径参数，每个路径参数前均需要注解</strong></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p><strong>@ResponseBody</strong></p><ul><li>类型：方法注解、类注解</li><li>位置：Controller方法&#x2F;类上</li><li>作用：将方法返回值直接响应，如果返回值类型是实体对象&#x2F;集合，将会转换成JSON格式响应</li><li>说明：@RestController&#x3D;@Controller+@ResponseBody（所以一般写@RestController）</li></ul><p><strong>统一响应结果</strong></p><p>Result(code, msg, data)</p><h2 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h2><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>为了单一职责原则，一个类或一个方法只做一件事，所以web开发有了<strong>三层架构</strong>：</p><ul><li>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据</li><li>service：业务逻辑层，处理具体的业务逻辑</li><li>dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增删改查</li></ul><p><strong>好处</strong>：复用性强、便于维护、利于扩展</p><h4 id="分层解耦-1"><a href="#分层解耦-1" class="headerlink" title="分层解耦"></a>分层解耦</h4><ul><li><strong>内聚</strong>：软件中各个功能模块内部的功能联系</li><li><strong>耦合</strong>：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度</li><li>软件设计原则：高内聚低耦合</li></ul><p><strong>控制反转</strong>：Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器）</p><p><strong>依赖注入</strong>：Dependency Injection，简称DI。容器为应用程序提供运行时所依赖的资源。</p><p><strong>Bean对象</strong>：IOC容器创建、管理的对象</p><h4 id="IOC和DI："><a href="#IOC和DI：" class="headerlink" title="IOC和DI："></a>IOC和DI：</h4><ul><li>Service层和Dao层的实现类，交给IOC容器管理<ul><li>在类前加上@Component</li></ul></li><li>为Controller和Service注入运行依赖的对象<ul><li>在成员变量前加上@Autowired</li></ul></li></ul><p><strong>Bean的声明</strong>：</p><p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一</p><ul><li>@Component：声明Bean的基础注解。以下三个都是它的衍生注解。不属于以下三类时使用。</li><li>@Controller：标注在控制器类上。</li><li>@Service：标注在业务类上。</li><li>@Repository：标注在数据访问类上。</li></ul><p>注意：</p><ul><li>声明bean时，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li><li>使用以上四个注解都可以声明bean，但在springboot集成web开发中，声明控制器bean只能用@Controller</li></ul><p><strong>Bean组件扫描</strong>：</p><ul><li>前面声明的bean四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描</li><li>@ComponentScan注解虽然没有显示配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication中，默认扫描的范围是启动类所在包及其子包</li></ul><p><strong>Bean注入</strong>：</p><ul><li>@Autowired注解，默认是按照<strong>类型</strong>进行，如果存在多个相同类型的bean，将会报错</li><li>解决方案：<ul><li>@Primary：在@Service前加。</li><li>@Qualifier：在@Autowired后加。eg.@Qualifier(“empServiceA”)</li><li>@Resource：代替@Autowired的位置。eg.@Resource(name&#x3D;”empServiceB”)</li></ul></li></ul><p><strong>@Resource和@Autowired的区别</strong></p><ul><li>后者是spring框架提供的注解，而前者是JDK提供的注解</li><li>后者默认是按照类型注入，而前者默认是按照名称注入</li></ul><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><h2 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h2><p>REST（REpresentation State Transfer），表述性状态转换，是一种软件架构风格。</p><ul><li>URL定位资源</li><li>HTTP动词描述操作</li><li>前后端交互统一响应结果Result（包括code响应码、msg响应信息、data返回数据）</li></ul><p><strong>注意</strong>：</p><ol><li>REST是风格，是约定方式，不是规定，可以打破</li><li>描述模块的功能通常使用复数来表示此类资源，而非单个资源</li></ol><h2 id="日志小技巧"><a href="#日志小技巧" class="headerlink" title="日志小技巧"></a>日志小技巧</h2><ol><li>添加注解@Slf4j</li><li>添加Log.info()</li></ol><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/depts&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.info(<span class="string">&quot;查询全部部门数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>一个完整的请求路径，应该是类上的@RequestMapping的value属性+方法上的@RequestMapping的value属性。</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>设置请求参数默认值：</p><p>@RequestParam(defaultValue&#x3D;”1”)</p><h2 id="PageHelper分页插件"><a href="#PageHelper分页插件" class="headerlink" title="PageHelper分页插件"></a>PageHelper分页插件</h2><ul><li><p>引入依赖：pagehelper-spring-boot-starter</p></li><li><p>使用：</p><ul><li>EmpServiceImpl：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;Emp&gt; list = empMapper.list();</span><br><span class="line">Page&lt;Emp&gt; page = (Page&lt;Emp&gt;)list;</span><br></pre></td></tr></table></figure><ul><li>EmpMapper：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程</li><li>文件上传在项目中应用非常广泛，eg. 发微博、发朋友圈</li></ul><h2 id="前端页面三要素"><a href="#前端页面三要素" class="headerlink" title="前端页面三要素"></a>前端页面三要素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctyoe</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>表单提交方式 method&#x3D;”post”</li><li>表单属性 enctyoe&#x3D;”multipart&#x2F;form-data”：表单提交时作为多个数据提交</li><li>表单项 type&#x3D;”file”</li></ul><h2 id="服务端接收文件"><a href="#服务端接收文件" class="headerlink" title="服务端接收文件"></a>服务端接收文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过MultipartFile这个API接收上传的文件，上传上来临时文件，当请求响应结束后，临时文件会自动删除</li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>将上传的文件存储到本地服务器磁盘中</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//获得文件后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">        <span class="comment">//构造唯一的文件名（不重复） - uuid（通用唯一识别码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">        <span class="comment">//将文件存储在服务器磁盘目录中</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\images\\&quot;</span> + newFileName));</span><br><span class="line"><span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改最大允许上传文件"><a href="#修改最大允许上传文件" class="headerlink" title="修改最大允许上传文件"></a>修改最大允许上传文件</h3><p>在SpringBoot中，文件上传，默认单个文件允许最大为1M</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置单个文件最大上传大小</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment">#配置单个请求最大上传大小（一次请求可以上传多个文件）</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br></pre></td></tr></table></figure><p><strong>缺点：前端无法直接访问、磁盘空间限制、磁盘损坏</strong></p><h2 id="第三方服务—阿里云"><a href="#第三方服务—阿里云" class="headerlink" title="第三方服务—阿里云"></a>第三方服务—阿里云</h2><h3 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h3><ul><li>准备工作<ul><li>注册阿里云（实名认证）</li><li>充值</li><li>开通对象存储服务（OSS)</li><li>创建<strong>bucket</strong>—存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间</li><li>获取AccessKey（密钥）</li></ul></li><li>参考官方SDK编写入门程序</li><li>集成使用</li></ul><p><strong>SDK：Software Development Kit的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等</strong></p><h3 id="集成步骤："><a href="#集成步骤：" class="headerlink" title="集成步骤："></a>集成步骤：</h3><ul><li>引入阿里云OSS上传文件工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取上传文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//获得文件后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">        <span class="comment">//构造唯一的文件名（不重复） - uuid（通用唯一识别码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">        <span class="comment">//上传文件到OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">        ossClient.putObject(bucketName, fileName, inputStream);</span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + newFileName;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上传图片接口开发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSUtils aliOSSUtils;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line"><span class="keyword">return</span> Result.success(url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置文件（application-properties"><a href="#配置文件（application-properties" class="headerlink" title="配置文件（application.properties)"></a>配置文件（application.properties)</h1><h2 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h2><p>将技术或服务所使用的参数直接配置在配置文件中，交给配置文件进行统一的管理和维护。</p><p>java代码中使用**@Value**注解通常用于外部配置的属性注入，具体用法：@Value(“${配置文件中的key}”)</p><h2 id="yml格式文件"><a href="#yml格式文件" class="headerlink" title="yml格式文件"></a>yml格式文件</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>XML：臃肿</li><li>properties：层次结构不清晰</li><li>yml&#x2F;yaml：简洁，数据为中心（推荐）</li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li>大小写敏感</li><li>数值前必须有空格，作为分隔符</li><li>使用缩进来表示层级关系，缩进时，不允许使用Tab键，只能用空格（但是idea里可以将Tab自动识别为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><h3 id="数据格式："><a href="#数据格式：" class="headerlink" title="数据格式："></a>数据格式：</h3><ul><li>对象&#x2F;Map集合：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>数组&#x2F;List&#x2F;Set集合：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><h3 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h3><p>在utils文件夹中添加AliOSSProperties：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先的AliOSSUtils改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> aliOSSProperties.getEndpoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOSSProperties.getAccessKeyId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOSSProperties.getAccessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> aliOSSProperties.getBucketName;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConfigurationProperties与-Value"><a href="#ConfigurationProperties与-Value" class="headerlink" title="@ConfigurationProperties与@Value"></a>@ConfigurationProperties与@Value</h3><h4 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h4><ul><li>都是用来注入外部配置的属性的</li></ul><h4 id="不同："><a href="#不同：" class="headerlink" title="不同："></a>不同：</h4><ul><li>@Value注解只能一个一个的进行外部属性的注入</li><li>@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中</li></ul><h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一个浏览器，以便在同一次会话的多次请求间共享数据。</li><li>会话跟踪方案：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul></li></ul><p><strong>Cookie</strong>：</p><ul><li>优点：HTTP协议支持的技术</li><li>缺点：<ul><li>移动端APP无法使用</li><li>不安全，用户可以自己禁用</li><li>不能跨域（跨域的三个维度：协议、IP&#x2F;域名、端口）</li></ul></li></ul><p><strong>Session</strong>：</p><ul><li>优点：存储在服务端，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>Cookie的缺点</li></ul></li></ul><p><strong>令牌技术</strong>：（主流）</p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器端存储压力（不需要服务器端存储任何的数据）</li></ul></li><li>缺点：需要自己实现</li></ul><h3 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h3><p>JSON Web Token，定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><p><strong>组成</strong>：</p><ol><li>Head（头），记录令牌类型，签名算法。通过Base64编码获得。</li><li>Payload（有效载荷），携带一些自定义信息、默认信息。通过Base64编码获得。</li><li>Signaure（签名），防止Token被篡改，确保安全性。将header、payload加入指定密钥，通过指定签名算法计算而来。</li></ol><p><em>Base64：基于64个可打印字符（A-Z，a-z，0-9，+，&#x2F;）来进行二进制数据的编码方式</em></p><p><strong>场景</strong>：登录认证</p><ol><li>令牌生成：登录成功后，生成令牌，并返回给前端</li><li>令牌校验：再请求到达服务端后，对令牌进行统一拦截、校验。后续每个请求，都需要携带JWT令牌，系统在每次请求处理之前，先校验令牌，通过后再处理</li></ol><p><strong>生成</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims)  <span class="comment">//自定义内容（载荷）</span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256,<span class="string">&quot;itheima&quot;</span>)  <span class="comment">//签名算法 </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">12</span>*<span class="number">3600</span>*<span class="number">1000</span>))  <span class="comment">//有效期</span></span><br><span class="line">        .compact();</span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">&quot;itheima&quot;</span>)  <span class="comment">//指定签名密钥</span></span><br><span class="line">        .parseClaimsJws(<span class="string">&quot;……&quot;</span>)  <span class="comment">//解析令牌</span></span><br><span class="line">        .getBody();</span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>JWT校验时使用的签名密钥，必须和生成JWT令牌时使用的密钥是配套的</li><li>如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法</li></ul><h3 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>Filter过滤器，JavaWeb三大组件（Servlet、Filter、Listener）之一</li><li>过滤器可以把资源的请求拦截下来，从而实现一些特殊的功能</li><li>过滤器一般完成一些通用的操作，如：登录校验、统一编码处理、敏感字符处理等</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>定义Filter：定义一个类，实现Filter接口，并重写其所有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123; <span class="comment">//初始化方法，Web服务器启动，创建Filter时调用，只调用一次</span></span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>&#123; <span class="comment">//拦截到请求时，调用该方法，可调用多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123; <span class="comment">//销毁方法，服务器关闭时调用，只调用一次</span></span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置Filter：Filter类加上@WebFilter注解，配置拦截资源的路径，引导类上加@ServletComponentScan开启Servlet组件（Java Web）支持（加在@SpringBootApplication之前）</li></ul><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><ul><li>具体路径：&#x2F;login</li><li>目录拦截：&#x2F;emps&#x2F;*</li><li>拦截所有：&#x2F;*</li></ul><h4 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h4><ul><li>一个web应用中，可以配置多个过滤器，多个过滤器形成一个过滤器链</li><li>顺序：优先级按照过滤器类名（字符串）的自然排序</li></ul><h4 id="登录校验过滤器"><a href="#登录校验过滤器" class="headerlink" title="登录校验过滤器"></a>登录校验过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestYRL().toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，若包含，说明时登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.判断令牌是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象-&gt;json （阿里巴巴fastJSON）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.解析token</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        JWTUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.errOr(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul><li>概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。</li><li>作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>定义拦截器，实现HandlerInterceptor接口，并重写其所有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行前执行，返回true则放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler, Exception ex)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*这里的&#x2F;*<em>表示拦截所有</em></p><h4 id="拦截路径-1"><a href="#拦截路径-1" class="headerlink" title="拦截路径"></a>拦截路径</h4><ul><li>addPathPatterns：需要拦截的资源</li><li>excludePathPatterns：不需要拦截的资源</li></ul><p>拦截路径：</p><ul><li>&#x2F;*：一级路径（包括&#x2F;depts，不包括&#x2F;depts&#x2F;1）</li><li>&#x2F;**：任意级路径</li></ul><h4 id="过滤器于拦截器同时存在"><a href="#过滤器于拦截器同时存在" class="headerlink" title="过滤器于拦截器同时存在"></a>过滤器于拦截器同时存在</h4><p>先执行过滤器，过滤器放行后执行拦截器</p><h4 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行前执行，返回true则放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestYRL().toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，若包含，说明时登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.判断令牌是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象-&gt;json （阿里巴巴fastJSON）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.解析token</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        JWTUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.errOr(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="Filter与Interceptor"><a href="#Filter与Interceptor" class="headerlink" title="Filter与Interceptor"></a>Filter与Interceptor</h3><ul><li>接口规范不同：前者需要实现Filter接口，后者需要实现HandlerInterceptor接口</li><li>拦截范围不同：前者拦截所有资源，后者之后拦截Spring环境中的资源</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>在Controller的方法中进行try…catch处理（代码臃肿，不推荐）</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>全局异常处理器（简单，推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span>&#123; </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//捕获所有的异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</em></p><h1 id="事务管理-AOP"><a href="#事务管理-AOP" class="headerlink" title="事务管理&amp;AOP"></a>事务管理&amp;AOP</h1><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin；</li><li>提交事务（这组操作全部成功后，提交事务）：commit；</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback；</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>注解：@Transactional</li><li>位置：业务（service）层的方法上、类上、接口上</li><li>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</li></ul><h2 id="事务属性—回滚"><a href="#事务属性—回滚" class="headerlink" title="事务属性—回滚"></a>事务属性—回滚</h2><h4 id="rollbackFor"><a href="#rollbackFor" class="headerlink" title="rollbackFor"></a>rollbackFor</h4><ul><li>默认情况下，只有出现RuntimeException才回滚异常。rollbackFor属性用于控制出现何种的异常类型才会回滚事务。</li><li>@Transactional(rollbackFor &#x3D; Exception.class)  代表所有的异常都会回滚。</li></ul><h3 id="事务属性—传播行为"><a href="#事务属性—传播行为" class="headerlink" title="事务属性—传播行为"></a>事务属性—传播行为</h3><h4 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h4><ul><li>事务传播行为：指当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。<ul><li>REQUIRED：（默认值）需要事务，有则加入，无则创建新事务。</li><li>REQUIRES_NEW：需要新事务，无论有无，总是创建新事务。</li></ul></li></ul><p>eg. @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)  代表会创建一个新的事务。</p><p><em>当被调用的事务方法和原先的事务方法在一个事务中时，一旦出现问题就会全部回滚，所以用REQUIRES_NEW可以事务之间不影响，比如下订单前需要记录日志，无论订单保存成功与否都需要保证日志记录能够记录成功</em></p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul><li>AOP：Aspect Oriented Programming（面向切片编程、面向方面编程），就是面向特定方法编程。</li><li>实现：动态代理是面向切面编程最主流的实现，而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定方法进行编程。</li><li>场景：记录操作日志，权限控制，事务管理……</li><li>优势：代码无侵入，减少重复代码，提高开发效率，维护方便</li></ul><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>场景：统计每一个业务方法的执行耗时</p><ul><li>导入依赖</li><li>编写AOP程序：针对于特定方法根据业务需要进行编程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//AOP类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span> <span class="comment">// 切入点表达式，这里表示业务层的所有方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1.记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2.调用原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="comment">//3.记录结束时间，计算方法执行耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(joinPoint.getSignature() + <span class="string">&quot;方法执行耗时： &#123;&#125;ms&quot;</span>, end - begin);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</li><li>通知：Advice，指重复的逻辑，也就是共性功能（最终体现为一个方法）</li><li>切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时会被应用</li><li>切面：Aspect，描述通知与切入点的对应关系（通知+切入点）</li><li>目标对象：Target，通知所应用的对象</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>一旦进行AOP程序的开发，最终运行的就不再是原始的目标对象，而是基于目标对象所生成的代理对象。</strong></p><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><ul><li>@Aroud：环绕通知，标注的通知方法在目标方法前后都被执行</li><li>@Before：前置通知，标注的通知方法在目标方法前被执行</li><li>@After：后置通知（最终通知），标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li><li>@AfterReturning：返回后通知，标注的通知方法在目标方法后被执行，有异常不会执行</li><li>@AfterThrowing：异常后通知，标注的通知方法发生异常后执行</li></ul><p><strong>注意</strong>：</p><ul><li>@Around环绕通知需要自己调用ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值</li></ul><h4 id="PointCut"><a href="#PointCut" class="headerlink" title="@PointCut"></a>@PointCut</h4><p>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.service.impl.DeptServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private：仅能在当前切面类中引用</p><p>public：在其他外部的切面类中也能引用</p><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h3><p>当有多个切面的切入点都匹配了目标方法时，多个通知方法都会被执行。</p><ul><li>不同切面类中，默认按照切面类的类名字母顺序<ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul></li><li>用@Order(数字)加在切面类上来控制顺序<ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="execution-…-：根据方法的签名来匹配"><a href="#execution-…-：根据方法的签名来匹配" class="headerlink" title="execution(…)：根据方法的签名来匹配"></a>execution(…)：根据方法的签名来匹配</h4><p>主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配</p><p>语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)</p><p>其中?表示可省略：</p><ul><li>访问修饰符：比如pulic，protected</li><li>包名.类名.：不建议省略</li><li>throws 异常：是方法上声明抛出的异常，不是实际抛出的异常</li></ul><p>通配符：</p><ul><li>*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名，任意类型的一个参数，也可以通配包、类、方法名的一部分</li><li>..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ul><p>注意：根据业务需要，可以使用&amp;&amp;、||、！来组合比较复杂的切入点表达式</p><p>书写建议：</p><ul><li>所有业务方法名在命名时尽量规范。方便切入点表达式快速匹配（如：查询类方法均以find开头等）</li><li>描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性</li><li>在满足业务需要前提下，尽量缩小切入点的匹配范围（如：包名匹配尽量不使用..，使用*匹配单个包）</li></ul><h4 id="annotation-…-：根据注解匹配"><a href="#annotation-…-：根据注解匹配" class="headerlink" title="@annotation(…)：根据注解匹配"></a>@annotation(…)：根据注解匹配</h4><p>用于匹配标识有特定注解的方法</p><p>eg. @annotation(com.itheima.aop.MyLog)可以匹配所有有@MyLog注解的方法</p><p>需要在com.itheima.aop目录下新建一个命名为MyLog的Annotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//运行时有效</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">//在Method上生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint</li><li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li></ul><p>示例：</p><ul><li>joinPoint.getTarget().getClass().getName() &#x2F;&#x2F; 获取目标类名</li><li>joinPoint.getSignature() &#x2F;&#x2F; 获取目标方法签名</li><li>joinPoint.getSignature().getName() &#x2F;&#x2F; 获取目标方法名</li><li>joinPoint.getArgs() &#x2F;&#x2F; 获取目标方法运行参数</li></ul><h3 id="获取当前用户"><a href="#获取当前用户" class="headerlink" title="获取当前用户"></a>获取当前用户</h3><p>获取request对象，从请求头中获取到jwt令牌，解析令牌获取出当前用户的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">……&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">operateUser</span> <span class="operator">=</span> (Integer)claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>properties &gt; yml &gt; yaml</p><p><strong>虽然SpringBoot支持多种格式配置文件，但是在项目开发时，推荐使用统一的一种配置（yml是主流）</strong></p><h2 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h2><h3 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h3><ul><li>默认在Spring项目启动后，会把bean都创建好放在IOC容器中（主要针对于默认的单例非延迟加载的bean，正常情况下还会受到作用域和延迟初始化影响），如果想要主动获得这些bean，方式如下：<ul><li>根据name获取bean：Object getBean(String name)</li><li>根据类型获取bean：&lt;T&gt; T getBean(Class&lt;T&gt; requiredType)</li><li>根据name获取bean(带类型转换)：&lt;T&gt; T getBean(Stirng name, Class&lt;T&gt; requiredType)</li></ul></li></ul><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><ul><li>singleton：容器中同名称的bean只有一个实例（单例）（默认）</li><li>prototype：每次使用该bean时会创建新的实例（非单例）</li></ul><p>通过@Scope注解来配置作用域</p><p>eg. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Lazy</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line">RequestMapping(<span class="string">&quot;/depts&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）</li><li>实际开发大部分的bean是单例的，一般不需要配置Scope属性</li></ul><h3 id="第三方bean"><a href="#第三方bean" class="headerlink" title="第三方bean"></a>第三方bean</h3><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解声明bean的，就需要用到@Bean注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span>&#123;</span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//将方法返回值交给IOC容器管理，成为IOC容器的bean对象</span></span><br><span class="line">    <span class="keyword">public</span> SAXReander <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要管理第三方bean对象，建议进行集中分类配置，可以通过@Configuration注解声明一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>通过@Bean注解的name&#x2F;value属性指定bean名称，如果未指定，默认是方法名</li><li>如果第三方bean需要依赖其他的bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配</li></ul><h3 id="Component及衍生注解与-Bean注解的使用场景"><a href="#Component及衍生注解与-Bean注解的使用场景" class="headerlink" title="@Component及衍生注解与@Bean注解的使用场景"></a>@Component及衍生注解与@Bean注解的使用场景</h3><ul><li>项目中自定义的使用@Component及衍生注解</li><li>项目中引入第三方的使用@Bean注解</li></ul><h2 id="SpringBoot原理"><a href="#SpringBoot原理" class="headerlink" title="SpringBoot原理"></a>SpringBoot原理</h2><h3 id="起步依赖-1"><a href="#起步依赖-1" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>maven的依赖传递</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><h4 id="自动配置方案"><a href="#自动配置方案" class="headerlink" title="自动配置方案"></a>自动配置方案</h4><ul><li>方案一：@ComponentScan组件扫描</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&#123;&quot;com.example&quot;,&quot;com.itheima&quot;&#125;)</span>  <span class="comment">// 还需要包括原先的目录，因为是声明后是覆盖关系</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用繁琐，性能低</p><ul><li>方案二：@Import导入。使用@Import导入的类会被Spring加载到IOC容器中，导入形式主要包括：<ul><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li><li>@EnableXxx注解，封装@Import注解（推荐）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Impor(&#123;TokenParser.class,HeaderConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>@SpringBootApplication</p><p>该注解标识在SpringBoot工程引导类上，是SpringBoot中最重要的注解，由三部分组成：</p><ul><li>@SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解</li></ul><p><strong>注意</strong>：SpringBoot会根据@Conditional注解条件装配，而不是全部注册为IOC容器的bean。</p><h5 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h5><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中</li><li>位置：方法、类</li><li>@Conditional本身是一个父注解，派生出大量的子注解：<ul><li>@ConditionalOnClass：判断环境中是否有对应字节码文件（name &#x3D; “…”)，有才注册bean到IOC容器</li><li>@ConditionalOnMissingBean：判断环境中是否有对应的bean（可以根据类型value属性或名称name属性来判断是否存在），没有才注册bean到IOC容器。通常用来设置一个默认的bean对象。</li><li>@ConditionalOnProperty：判断配置文件中是否有对应属性和值（name &#x3D; “…”, havingValue &#x3D; “…”)，有才注册bean到IOC容器</li></ul></li></ul><h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter。</p><p><em>起步依赖分类：</em></p><ul><li>SpringBoot官方：spring-boot-starter-xxx</li><li>其他技术提供：xxx-spring-boot-starter</li></ul><p>eg.</p><p><strong>需求</strong>：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置</p><p><strong>目标</strong>：引入起步依赖之后，要使用阿里云OSS，注入AliyunOSSUtils直接使用即可</p><p><strong>步骤</strong>：</p><ul><li>创建aliyun-oss-spring-boot-starter模块（依赖管理功能）</li><li>创建aliyun-oss-spring-boot-autoconfigure模块（自动配置功能），在starter中引入该模块</li><li>在aliyun-oss-spring-boot-autoconfigure模块中定义自动配置功能，并定义自动配置文件META-INF&#x2F;spring&#x2F;xxx.imports</li></ul><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h2 id="分模块设计与开发"><a href="#分模块设计与开发" class="headerlink" title="分模块设计与开发"></a>分模块设计与开发</h2><p>分模块设计：将项目按照功能拆分成若干个子模块</p><p>原因：方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享</p><p><strong>注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。</strong></p><h2 id="继承与聚合"><a href="#继承与聚合" class="headerlink" title="继承与聚合"></a>继承与聚合</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</p><p>作用：简化依赖配置、统一管理依赖</p><p>实现：&lt;parent&gt;…&lt;&#x2F;parent&gt;</p><ul><li>创建maven模块tlias-parent，该工程为父工程，设置打包方式为pom（默认jar）<ul><li>&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</li></ul></li><li>在子工程的pom.xml文件中，配置继承关系<ul><li>&lt;relativePath&gt;..&#x2F;tlias-parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</li></ul></li><li>在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）</li></ul><p><em>打包方式</em>：</p><ul><li>jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</li><li>war：普通web程序打包，需要部署在外部的tomcat服务器中运行</li><li>pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</li></ul><h3 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h3><p>在maven中，可以在父工程的pom文件中通过&lt;dependencyManagement&gt;来统一管理依赖版本</p><p><strong>注意</strong>：子工程引入依赖时，无需指定&lt;version&gt;版本号，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</p><p>自定义属性&#x2F;引用属性：放在&lt;properties&gt;…&lt;&#x2F;properties&gt;中</p><h4 id="与的区别："><a href="#与的区别：" class="headerlink" title="&lt;dependencyManagement&gt;与&lt;dependencies&gt;的区别："></a>&lt;dependencyManagement&gt;与&lt;dependencies&gt;的区别：</h4><ul><li>后者是直接依赖，在父工程配置了依赖，子工程会直接继承下来</li><li>前者是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖（无需指定版本）</li></ul><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合：将多个模块组织成一个整体，同时进行项目的构建</p><p>聚合工程：一个不具有业务功能的”空“工程（有且仅有一个pom文件）（所以使用父工程作为聚合工程）</p><p>作用：快速构建项目（无需根据依赖关系手动创建，直接在聚合工程上构建即可）</p><p>写法：maven中可以通过&lt;modules&gt;设置当前聚合工程所包含的子模块名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-web-management<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：聚合工程所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。</p><h3 id="继承与聚合："><a href="#继承与聚合：" class="headerlink" title="继承与聚合："></a>继承与聚合：</h3><ul><li>作用<ul><li>聚合用于快速构建项目</li><li>继承用于简化依赖配置、统一管理依赖</li></ul></li><li>相同点：<ul><li>pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>均属于设计类模块，并无实际的模块内容</li></ul></li><li>不同点：<ul><li>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>私服是一种特殊的远程仓库，架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。</p><p><strong>依赖查找顺序</strong>：</p><ul><li>本地仓库</li><li>私服</li><li>中央仓库</li></ul><p><strong>注意</strong>：私服在企业项目开发中，一个项目&#x2F;公司，只需要一台即可。</p><h3 id="资源上传与下载"><a href="#资源上传与下载" class="headerlink" title="资源上传与下载"></a>资源上传与下载</h3><ul><li>设置私服的访问用户名&#x2F;密码（settings.xml中的servers中配置）</li><li>IDEA的maven工程的pom文件中配置上传（发布）地址</li><li>设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）</li><li>执行deploy</li></ul><p><strong>项目版本</strong>：</p><ul><li>RELEASE（发行版本）：功能趋于稳定，当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中</li><li>SNAOSHOT（快照版本）：功能不稳定、尚处于开发中的版本，存储在私服中的SNAOSHOT仓库中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/11/01/MySQL/"/>
      <url>/2024/11/01/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>数据库</strong>：DataBase（DB），是存储和管理数据的仓库</p><p><strong>数据库管理系统</strong>：DataBase Management System（DBMS），操纵和管理数据库的大型软件</p><p><strong>SQL</strong>：Structured Query Language，操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</p><p><strong>关系型数据库</strong>：（RDBMS），建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p><p>特点：</p><ul><li>使用表存储数据，格式统一，便于维护</li><li>使用SQL语言操作，标准统一，使用方便，可用于复杂查询</li></ul><p><strong>数据模型</strong>：在一个数据库服务器中可以创建多个数据库，而且多个数据库相互独立；在一个数据库中可以创建多张表，一张表中可以存储多条的数据。</p><h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p><strong>SQL</strong>：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。</p><p><strong>通用语法</strong>：</p><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性，不影响效果</li><li>MySQL数据库的SQL语句不区分大小写</li><li>注释：<ul><li>单行：– 注释内容 &#x2F; # 注释内容（MySQL特有）</li><li>多行：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><p><strong>分类</strong>：</p><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML（Data Manipulation Language）：数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL（Data Query Language）：数据查询语言，用来查询数据库中表的记录</li><li>DCL（Data Control Language）：数据控制语言，用来创建数据库用户、控制数据库的访问权限</li></ul><h1 id="数据库设计—DDL"><a href="#数据库设计—DDL" class="headerlink" title="数据库设计—DDL"></a>数据库设计—DDL</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>查询所有数据库：show databases;</li><li>查询当前数据库：select database();</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>使用数据库：use 数据库名;</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>创建数据库：create database [if not exists] 数据库名;</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>删除数据库：drop database [if exists] 数据库名;</li></ul><p><strong>注意</strong>：上述语法中的database也可替换成schema</p><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段类型 [约束] [comment 字段<span class="number">2</span>注释]</span><br><span class="line">&#125;[comment 表注释];</span><br></pre></td></tr></table></figure><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>概念：作用于表中字段上的规则，用于限制存储在表中的数据</p></li><li><p>目的：保证数据库中数据的正确性、有效性和完整性</p></li><li><p>包括：</p><ul><li>非空约束：not null</li><li>唯一约束：unique</li><li>主键约束：primary key（非空且唯一）<strong>（auto_increment：自动增长）</strong></li><li>默认约束：default（后接默认值，表示若未指定字段值，则采用默认值）</li><li>外键约束：foreign key（让两张表的数据建立连接，保证数据的一致性和完整性）</li></ul></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>数值类型<ul><li><strong>tinyint</strong>：1byte，小整数值</li><li>smallint：2byte，中整数值</li><li>mediumint：3byte，大整数值</li><li><strong>int</strong>：4byte，大整数值</li><li><strong>bigint</strong>：8byte，极大整数值</li><li>float：4byte，单精度浮点数</li><li><strong>double</strong>：8byte，双精度浮点数，eg.double(5,2)，5为整个数字长度，2为小数位个数</li><li>decimal：小数值（精度更高）（用字符串存储，精准）</li></ul></li><li>字符串类型<ul><li><strong>char</strong>：定长字符串，性能高，但是浪费空间</li><li><strong>varchar</strong>：变长字符串，节省空间，但是性能低</li></ul></li><li>日期时间类型<ul><li><strong>date</strong>：日期值，YYYY-MM-DD</li><li>time：时间值或持续时间，HH:MM:SS</li><li>year：年份值</li><li><strong>datetime</strong>：混合日期和时间值</li></ul></li></ul><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p>页面原型+需求 &#x3D;&gt; 原型字段（类型、约束）+ 基础字段（id、create_time、update_time）</p><p><em>create_time记录当前数据的插入时间，update_time记录当前数据最后的更新时间</em></p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><ul><li>查询当前数据库所有表：show tables;</li><li>查询表结构：desc 表名;</li><li>查询建表语句：show create table 表名;</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>添加字段：alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</li><li>修改字段类型：alter table 表名 modify 字段名 新数据类型(长度);</li><li>修改字段名和字段类型：alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</li><li>删除字段：alter table 表名 drop column 字段名;</li><li>修改表名：rename table 表名 to 新表名;</li></ul><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li>删除表：drop table [if exists] 表名;</li></ul><p><em>在删除表时，表中的数据也都会被删除</em></p><h1 id="数据库操作—DML"><a href="#数据库操作—DML" class="headerlink" title="数据库操作—DML"></a>数据库操作—DML</h1><h2 id="添加数据-INSERT"><a href="#添加数据-INSERT" class="headerlink" title="添加数据(INSERT)"></a>添加数据(INSERT)</h2><ul><li>指定字段添加数据：insert into 表名(字段名1, 字段名2) values (值1, 值2);</li><li>全部字段添加数据：insert into 表名 values (值1, 值2, …);</li><li>批量添加数据(指定字段)：insert into 表名(字段名1, 字段名2) values (值1, 值2), (值1, 值2);</li><li>批量添加数据(全部字段)：insert into 表名 values (值1, 值2, …), (值1, 值2, …);</li></ul><p><strong>注意</strong>：</p><ol><li>插入数据时，指定的字段顺序需要与值的顺序一一对应</li><li>字符串和日期型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li><li>插入数据时别忘了create_time和update_time值为now()</li></ol><h2 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据(UPDATE)"></a>修改数据(UPDATE)</h2><ul><li>update 表名 set 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2, … [where 条件];</li></ul><p><strong>注意</strong>：</p><ol><li>修改语句的条件没有时，则会修改整张表的所有数据</li><li>修改时别忘了修改update_time为now()</li></ol><h2 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据(DELETE)"></a>删除数据(DELETE)</h2><ul><li>delete from 表名 [where 条件];</li></ul><p><strong>注意</strong>：</p><ol><li>删除语句的条件没有时，则会删除整张表的所有数据</li><li>不能删除某一个字段的值（需要使用UPDATE，将该字段的值置为NULL）</li></ol><h1 id="数据库操作—DQL"><a href="#数据库操作—DQL" class="headerlink" title="数据库操作—DQL"></a>数据库操作—DQL</h1><p>格式：select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后条件列表 order by 排序字段列表 limit 分页参数</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><ul><li>查询多个字段：select 字段1，字段2，字段3 from 表名；</li><li>查询所有字段（通配符）：select * from 表名；（不推荐：不直观、性能低）</li><li>设置别名：select 字段1 [as 别名1]，字段2 [as 别名2] from 表名；</li><li>去除重复记录：select distinct 字段列表 from 表名；</li></ul><h2 id="条件查询（where）"><a href="#条件查询（where）" class="headerlink" title="条件查询（where）"></a>条件查询（where）</h2><ul><li>select 字段列表 from 表名 where 条件列表；</li></ul><p><strong>比较运算符</strong>：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;、&lt;&gt;或!&#x3D;、between…and…<em>（含最大最小值）</em>、in(…)<em>（在括号内列表中的值，多选一）</em>、like 占位符（模糊匹配：_匹配一个字符、%匹配任意个字符（<em>可以为0个</em>））、is null、is not null</p><p><strong>逻辑运算符</strong>：and或&amp;&amp;、or或||、not或！</p><h2 id="分组查询（group-by）"><a href="#分组查询（group-by）" class="headerlink" title="分组查询（group by）"></a>分组查询（group by）</h2><ul><li>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]；</li></ul><p><strong>where和having的区别</strong>：</p><ol><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ol><p><strong>注意</strong>：</p><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li><li>执行顺序：where &gt; 分组操作+聚合函数 &gt; having</li></ul><p><strong>聚合函数</strong>：将一列数据作为一个整体，进行纵向运算。</p><p>select 聚合函数(字段列表) from 表名；</p><p>聚合函数包括：</p><ul><li>count：统计数量</li><li>max</li><li>min</li><li>avg：平均值</li><li>sum</li></ul><p><strong>注意</strong>：</p><ol><li>null值不参与所有聚合函数的运算</li><li>统计数量可以用count(*)、count(字段)、count(常量)，推荐使用count(*)</li></ol><h2 id="排序查询（order-by）"><a href="#排序查询（order-by）" class="headerlink" title="排序查询（order by）"></a>排序查询（order by）</h2><ul><li>select 字段列表 from 表名 [where 条件列表] [group by 分组字段]  order by 字段1 排序方式1，字段2 排序方式2，…；</li></ul><p><strong>排序方式</strong>：</p><ul><li>ASC：升序（默认值）</li><li>DESC：降序</li></ul><p><strong>注意</strong>：如果是多个字段排序，只有当第一个字段值相同时，才会根据第二个字段进行排序。</p><h2 id="分页查询（limit）"><a href="#分页查询（limit）" class="headerlink" title="分页查询（limit）"></a>分页查询（limit）</h2><ul><li>select 字段列表 from 表名 limit 起始索引, 查询记录数;</li></ul><p><strong>注意</strong>：</p><ol><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 查询记录数</li></ol><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><ul><li>if(表达式, true_value, false_value)</li><li>case expr when value1 then result1 [when value2 then result2…] [else result] end</li></ul><h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，分为：</p><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一的一方叫父表，多的叫子表。</p><p><strong>实现</strong>：在数据库表中多的一方添加字段，来关联一的一方的主键。</p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p><strong>语法</strong>：</p><ul><li><p>创建表时指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">字段名 数据类型，</span><br><span class="line">…</span><br><span class="line">[<span class="keyword">constraint</span>][外键名称] <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(字段名)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>建完表后添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(字段名)</span><br></pre></td></tr></table></figure></li></ul><h4 id="物理外键"><a href="#物理外键" class="headerlink" title="物理外键"></a>物理外键</h4><p><strong>概念</strong>：使用foreign key 定义外键关联另外一张表</p><p><strong>缺点</strong>：</p><ul><li>影响增、删、改的效率（需要检查外键关系）</li><li>仅用于单节点数据库，不适用与分布式、集群场景</li><li>容易引发数据库的死锁问题，消耗性能</li></ul><h4 id="逻辑外键（推荐）"><a href="#逻辑外键（推荐）" class="headerlink" title="逻辑外键（推荐）"></a>逻辑外键（推荐）</h4><p><strong>概念</strong>：在业务层逻辑中，解决外键关联</p><p><em>通过逻辑外键可以解决上述问题</em></p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率</p><p><strong>实现</strong>：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p><strong>实现</strong>：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><ol><li>阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系</li><li>阅读页面原型及需求文档，分析各个表结构中具体的字段及约束</li></ol><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>多表查询：指从多张表中查询数据</p><p><strong>笛卡尔积</strong>：在数学中，两个集合的所有组合情况。（在多表查询中，需要消除无效的笛卡尔积）</p><p><strong>分类</strong>：</p><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据（包括两张表交集部分数据）</li><li>右外连接：查询右表所有数据（包括两张表交集部分数据）</li></ul></li></ul></li><li>子查询</li></ul><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><strong>语法</strong>：</p><ul><li>隐式内连接：select 字段列表 from 表1，表2 where 条件…；</li><li>显示内连接：select 字段列表 from 表1 [inner] join 表2 on 连接条件…；</li></ul><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p><strong>语法</strong>：</p><ul><li>左外连接：select 字段列表 from 表1 left [outer] join 表2 on 连接条件…；</li><li>右外连接：select 字段列表 from 表1 right [outer] join 表2 on 连接条件…；</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>概述</strong>：SQL语句中嵌套select语句，称为嵌套查询，也叫子查询</p><p><strong>形式</strong>：select * from t1 where column1 &#x3D; (select column1 from t2 …)；</p><p>子查询外部的语句可以是insert&#x2F;update&#x2F;delete&#x2F;select的任何一个，最常见的是select。</p><p><strong>分类</strong>：</p><ul><li>标量子查询：返回单个值</li><li>列子查询：返回一列</li><li>行子查询：返回一行</li><li>表子查询：返回多行多列</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><ul><li>返回单个值（数字、字符串、日期等），最简单的形式</li><li>常用的操作符：&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</li></ul><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><ul><li>返回一列（可以是多行）</li><li>常用的操作符：in、not in等</li></ul><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><ul><li>返回一行（可以是多列）</li><li>常见的操作符：&#x3D;、&lt;&gt;、in、not in（左右都用括号括起来，然后左右相等即可）</li></ul><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><ul><li><p>返回多行多列，常作为临时表（放在from后面）</p></li><li><p>常见的操作符：in</p></li></ul><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><ol><li>先分析涉及到的表有哪些</li><li>然后分析表之间的关系，如何进行联查</li><li>最后考虑sql语句怎么写</li></ol><p><strong>子查询性能不高，能用连接查询时尽量用连接查询</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>注意</strong>：默认MySQL的事务是自动提交的，即当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><ul><li>开启事务：start transaction; &#x2F; begin;</li><li>提交事务：commit;</li><li>回滚事务：rollback;</li></ul><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变就是永久的</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>索引（index）是帮助数据库高效获取数据的数据结构。</p><p><strong>优点</strong>：</p><ul><li>提高数据查询的效率，降低数据库的IO成本</li><li>通过索引对数据进行排序，降低数据排序的成本，降低CPU消耗</li></ul><p><strong>缺点</strong>：</p><ul><li>索引会占用存储空间</li><li>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。一般默认指B+Tree结构组织的索引。</p><p><em>若用二叉搜索树或者红黑树，会在大数据量的情况下，层级深，检索速度慢</em></p><p><strong>B+Tree（多路平衡搜索树）</strong></p><ul><li>每一个节点，可以存储多个key（有n个key，就有n个指针）</li><li>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据（最终都要找到叶子节点才能拿到相应的数据）</li><li>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul><li><p>创建索引：create [unique] index 索引名 on 表名(字段名…);</p></li><li><p>查看索引：show index from 表名;</p></li><li><p>删除索引：drop index 索引名 on 表名;</p></li></ul><p><strong>注意</strong>：</p><ol><li>主键字段，在建表时会自动创建主键索引（主键索引的性能是最高的）</li><li>添加唯一约束时，数据库实际上会添加唯一索引</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2024/10/30/Mybatis/"/>
      <url>/2024/10/30/Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MyBatis是一款优秀的<strong>持久层</strong>框架，用于简化JDBC的开发。</p><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p><strong>使用Mybatis查询所有用户数据</strong></p><ul><li><p>准备工作（创建springboot工程、数据库表user、实体类User）</p></li><li><p>引入Mybatis的相关依赖，配置Mybatis（数据库连接信息）</p><ul><li><p>在application.properties中写（其中mybatis是数据库名称，需要根据具体情况进行修改）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写SQL语句（注解&#x2F;XML）</p><ul><li><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部用户的信息</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单元测试</p><ul><li><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        userList.stream().forEach(user -&gt; &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>JDBC：（Java DataBase Connectivity），就是使用java语言操作关系型数据库的一套API。</p><h2 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h2><ul><li>一套操作所有关系型数据库的规范，即接口</li><li>各个数据库厂商去实现这个接口，提供数据库<strong>驱动jar包</strong></li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>硬编码</li><li>繁琐</li><li>资源浪费，性能降低</li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul><li>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li></ul><p><strong>优势</strong>：</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul><p><strong>标准接口</strong>：</p><ul><li>DataSource是官方提供的数据库连接池接口，所有的第三方组织都必须实现此接口</li><li>功能：获取连接（Connection getConnection() throws SQLException;）</li></ul><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>是一个实用的Java类库，能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易阅读的toSring方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写equals方法和hashCode方法</td></tr><tr><td><strong>@Data</strong></td><td>提供了更综合的生成代码功能（@Getter+@Setter+@ToString+@EqualsAndHashCode）</td></tr><tr><td><strong>@NoArgsConstructor</strong></td><td>为实体类生成无参的构造器方法</td></tr><tr><td><strong>@AllArgsConstructor</strong></td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法</td></tr></tbody></table><p><strong>Lombok会在编译时，自动生成对应的java代码</strong></p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>准备数据库表emp</li><li>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</li><li>application.properties中引入数据库连接信息</li><li>创建对应的实体类Emp（实体类属性采用驼峰命名）</li><li>准备Mapper接口—EmpMapper</li></ul><h2 id="删除员工"><a href="#删除员工" class="headerlink" title="删除员工"></a>删除员工</h2><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果mapper接口方法形参只有一个普通类型的参数，#{…}里面的属性名可以随便写，如：#{id}、#{value}。</p><h4 id="预编译SQL"><a href="#预编译SQL" class="headerlink" title="预编译SQL"></a>预编译SQL</h4><p>优势：</p><ul><li><p>性能更高</p><p><img src="/2024/10/30/Mybatis/image-20241027151745180.png" alt="image-20241027151745180"></p></li><li><p>更安全（防止SQL注入）</p></li></ul><p><strong>SQL注入</strong>：通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</p><p><strong>参数占位符</strong>：</p><ul><li>#{…}<ul><li>执行SQL时，会将#{…}替换为？，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递</li></ul></li><li>${…}<ul><li>拼接SQL，直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><h2 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(username, name, gender, image, job, entrydate, dept_id,create_time, update_time) <span class="keyword">values</span>(<span class="string">&#x27;songyuanqiao&#x27;</span>, <span class="string">&#x27;宋远桥&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1.jpg&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;2012-10-01 10:00:00&#x27;</span>, <span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; + &quot; values(#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125; ,#&#123;updateTime&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure><h3 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h3><p><strong>描述</strong>：在数据添加成功后，需要获取插入数据库数据的主键。如：添加套餐数据时，还需要维护套餐菜品关系表数据。</p><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Options(keyProperty = &quot;id&quot;, userGeneratedKeys = true)</span></span><br><span class="line"><span class="meta">@Insert</span>……</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>会自动将生成的主键值赋值给emp对象的id属性</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>与新增员工时类似</p><ul><li><p>SQL语句：update update set  …，…  where id &#x3D; 19;</p></li><li><p>接口方法：@Update(“……”)</p></li></ul><h2 id="查询（根据ID）"><a href="#查询（根据ID）" class="headerlink" title="查询（根据ID）"></a>查询（根据ID）</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>但是发现返回的部分属性值为null</strong></p><p><strong>数据封装</strong>：</p><ul><li>实体类属性名与数据库表查询返回的字段名一致，mybatis会自动封装</li><li>如果不一致，不能自动封装</li></ul><p><strong>解决方案</strong>：</p><ul><li>方案一：给字段起别名，让别名与实体类属性一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id, username, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><ul><li>方案二：通过@Results，@Result注解手动映射封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><ul><li>方案三：在application.properties中开启驼峰命名自动映射开关（推荐）</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="查询（条件查询）"><a href="#查询（条件查询）" class="headerlink" title="查询（条件查询）"></a>查询（条件查询）</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span><span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> entrydate <span class="keyword">between</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where name like &#x27;%$&#123;name&#125;%&#x27; and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br></pre></td></tr></table></figure><p><strong>由于预编译的?占位符不能出现在引号内，所有需要用$占位符。但是这样性能低，不安全，存在SQL注入问题。</strong></p><p><strong>改进方案</strong>：通过tomcat进行字符串拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><em>参数说明</em></h2><p>eg. 在String name前可加上@Param(“name”)，从而能够与注解中使用的参数一致</p><p><em>但是在springboot2.x版本内置了编译插件，可以省略这一部分。</em></p><h1 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h1><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ul><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）</li><li>XML映射文件的namespace属性为Mapper接口全限定名一致</li><li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</li></ul><p><img src="/2024/10/30/Mybatis/image-20241027162439599.png" alt="image-20241027162439599"></p><p><em>resultType：单条记录所封装的类型</em></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>使用Mybatis的注解，主要是来完成一些简单的增删改查功能；如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。</p><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态SQL：随着用户的输入或外部条件的变化而变化的SQL语句（一般用XML文件来定义）</p><h2 id><a href="#" class="headerlink" title="&lt;if&gt;"></a>&lt;if&gt;</h2><ul><li><strong>&lt;if&gt;<strong>：用于</strong>判断条件</strong>是否成立，使用test属性进行条件判断，如果为true，则拼接SQL。</li><li>**&lt;where&gt;**：只有内部包含的子元素存在true时才会插入where，并且能够自动去除子句开头的AND或OR。</li></ul><p>eg. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**&lt;set&gt;**：动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;foreach&gt;"></a>&lt;foreach&gt;</h2><ul><li><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure></li><li><p>XML映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>collection：集合名称</li><li>item：集合遍历出来的元素</li><li>separator：每一次遍历使用的分隔符</li><li>open：遍历开始前拼接的片段</li><li>close：遍历结束后拼接的片段</li></ul></li></ul><h2 id="和"><a href="#和" class="headerlink" title="&lt;sql&gt;和&lt;include&gt;"></a>&lt;sql&gt;和&lt;include&gt;</h2><ul><li>**&lt;sql&gt;**：定义可重用的SQL片段</li><li>**&lt;include&gt;**：通过属性refid，指定包含的sql片段</li></ul><p><em>二者配对使用，将多次使用到的部分包装起来，减少代码量</em></p><p>eg.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line">    select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2024/10/17/Java%E9%9B%86%E5%90%88/"/>
      <url>/2024/10/17/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="数组和集合两种数据结构的区别"><a href="#数组和集合两种数据结构的区别" class="headerlink" title="数组和集合两种数据结构的区别"></a>数组和集合两种数据结构的区别</h2><p>数组：固定长度（一旦创建长度无法改变）；可以包含基本数据类型和对象；可以直接访问元素</p><p>集合：动态长度（可以根据需要动态增加或减少元素）；只能包含对象；需要迭代器或其他方法访问元素</p><p><em>（迭代器：一种设计模式，用于遍历数据结构）</em></p><p><em>（迭代器常用方法：hasNext(), next(), remove()）</em></p><h2 id="用过的一些Java集合类"><a href="#用过的一些Java集合类" class="headerlink" title="用过的一些Java集合类"></a>用过的一些Java集合类</h2><p><strong>ArrayList</strong>：动态数组，实现了List接口，支持动态增长</p><p><em>（List接口：List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引，可以根据序号存取容器中的元素）</em></p><p><strong>LinkedList</strong>：双向链表，也实现了LIst接口，支持快速的插入和删除操作</p><p><strong>HashMap</strong>：基于哈希表的Map实现，存储键值对，通过键快速查找值</p><p><strong>HashSet</strong>：基于HahsMap实现的Set集合，用于存储唯一元素</p><p><strong>TreeMap</strong>：基于红黑树实现的有序Map集合，可以按照键的顺序进行排序</p><p><strong>LinkedHashMap</strong>：基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序</p><p><strong>PriorityQueue</strong>：优先队列，可以按照比较器或元素的自然顺序进行排序</p><h2 id="Java中的集合"><a href="#Java中的集合" class="headerlink" title="Java中的集合"></a>Java中的集合</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="img"></p><p><strong>List</strong>：有序的Collection，能精准控制元素的插入位置，能根据索引访问元素。常用的类有LinkedList，ArrayList，Vector，Stack。</p><ul><li><strong>ArrayList</strong>：容量可变的非线程安全列表，支持快速随机访问，但插入和删除速度很慢。</li><li><strong>LinkedList</strong>：本质是一个双向链表，与上面相比插入和删除速度更快，但随机访问速度更慢。</li></ul><p><strong>Set</strong>：元素不允许重复，无序。常用的实现有HashSet，LinkedHashSet，TreeSet。</p><ul><li><strong>HashSet</strong>：通过HashMap实现，使用key保证元素唯一性，但不保证有序性，线程不安全。</li><li><strong>LinkedHashSet</strong>：继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。</li><li><strong>TreeSet</strong>：通过TreeMap实现，按照比较规则插入新元素，保证插入后集合仍然有序。</li></ul><p><strong>Map</strong>：键值对集合，存储键、值和之间的映射。Key无序且唯一，value不要求有序且允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值。常用的实现有TreeMap，HashMap，HashTable，LinkedHashMap，ConcurrentHashMap。</p><ul><li><p><strong>HashMap</strong>：JDK1.8前由数组+链表组成，数组是主体，链表解决哈希冲突。之后改变了解决哈希冲突的方式，即当链表长度大于阈值时，链表转化为红黑树，减少搜索时间。</p></li><li><p><strong>LinkedHashMap</strong>：继承自HashMap，底层仍然是基于拉链式散列结构<em>（即由数组和链表或红黑树组成）</em>。另外增加了一条双向链表，使得可以保持键值对的插入顺序。同时实现了访问顺序相关逻辑。</p></li><li><p><strong>HashTable</strong>：数组+链表，数组是主体，链表解决哈希冲突。</p></li><li><p><strong>TreeMap</strong>：红黑树（自平衡的排序二叉树）</p></li><li><p><strong>ConcurrentHashMap</strong>：Node数组+链表+红黑树，线程安全。</p><p><em>（线程安全：多个线程访问同一段代码时，采用加锁机制，确保同一时刻只有一个线程在操作共享数据，避免数据不一致或污染的问题）</em></p></li></ul><h2 id="Java中线程安全的集合有哪些"><a href="#Java中线程安全的集合有哪些" class="headerlink" title="Java中线程安全的集合有哪些"></a>Java中线程安全的集合有哪些</h2><ul><li><p>java.util包：Vector、HashTable</p></li><li><p>java.util.concurrent包</p><ul><li><p>并发Map：ConcurrentHashMap、ConcurrentSkipListMap</p></li><li><p>并发Set：ConcurrentSkipListSet、CopyOnWriteArraySet</p></li><li><p>并发List：CopyOnWriteArrayList</p></li><li><p>并发Queue：ConcurrentLinkedQueue、BlockingQueue</p></li><li><p>并发Deque：LinkedBlockingDeque、ConcurrentLinkedDeque</p><p><em>（Deque：双端队列）</em></p></li></ul></li></ul><h2 id="Collections和Collection的区别"><a href="#Collections和Collection的区别" class="headerlink" title="Collections和Collection的区别"></a>Collections和Collection的区别</h2><p><strong>Collections</strong>：Java提供的一个工具类，位于java.util包中，提供了一系列静态方法，用于对集合进行操作和算法。该类中的方法包括排序、查找、替换、反转、随机化等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</p><p><strong>Collection</strong>：Java集合框架中的一个接口，是所有集合类的基础接口。定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。该接口有许多实现类，如List、Set和Queue等。</p><h2 id="集合遍历的方法有哪些"><a href="#集合遍历的方法有哪些" class="headerlink" title="集合遍历的方法有哪些"></a>集合遍历的方法有哪些</h2><ul><li>普通for循环</li><li>增强for循环（for—each循环）<ul><li>eg. for(String element : list){}</li></ul></li><li>Iterator迭代器（特别适用于需要删除元素的情况）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ListIterator列表迭代器：是迭代器的子类，可以双向访问列表并在迭代过程中修改元素</p><p><em>（与上面的区别为：ListIterator<String> listIterator &#x3D; list.listIterator();）</String></em></p></li><li><p>使用forEach方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><ul><li>Sream API：可以对集合进行函数式操作，如过滤、映射等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="List的几种实现及其不同"><a href="#List的几种实现及其不同" class="headerlink" title="List的几种实现及其不同"></a>List的几种实现及其不同</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807143695-c1058186-be42-4746-a273-6302a128e328.png" alt="image.png"></p><ul><li>Vector：线程安全的动态数组，内部使用对象数组来保存数据，可以根据需要自动增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li><li>ArrayList：非线程安全的动态数组，性能更好，应用更加广泛，也可以根据需要调整容量。</li><li>LinkedList：双向链表，不需要像上面那样调整容量，非线程安全。</li></ul><p>综上，前两个作为动态数组，内部元素以数组形式顺序存储，适合随机访问。除了在尾部的插入和删除操作，性能相对较差<em>（比如中间插入一个元素，需要移动后续所有元素）</em>。第三个进行节点插入、删除较高效，但随机访问性能较慢。</p><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ul><li><strong>底层数据结构不同</strong>：前者使用数组实现，通过索引进行快速访问元素；后者使用链表实现，通过节点之间的指针进行元素的访问和操作。</li><li><strong>插入和删除操作的效率不同</strong>：前者在尾部操作效率较高，在中间或开头操作效率较低；后者在任意位置操作效率都较高。但是后者不支持随机访问，所以除了头结点外插入和删除的时间复杂度都是O(n)，效率不是很高。</li><li><strong>随机访问的效率不同</strong>：前者支持通过索引快速随机访问，时间复杂度为O(1)；后者需要从头或尾开始遍历链表，时间复杂度为O(n)。</li><li><strong>空间占用</strong>：前者在创建时需要分配一段连续的内存空间，会占用较大的空间；后者每个节点只需要存储元素和指针，占用空间相对较小。</li><li><strong>使用场景</strong>：前者适用于频繁随机访问和尾部的插入删除操作；后者适用于频繁的中间插入删除操作和不需要随机访问的场景。</li><li><strong>线程安全</strong>：两个集合都不是线程安全的。</li></ul><h2 id="为什么ArrayList不是线程安全的"><a href="#为什么ArrayList不是线程安全的" class="headerlink" title="为什么ArrayList不是线程安全的"></a>为什么ArrayList不是线程安全的</h2><p>在高并发添加数据下，ArrayList会暴露以下三个问题及其可能情况：</p><ul><li>部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。</li><li>索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；</li><li>size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的</li></ul><h2 id="把ArrayList变成线程安全的方式"><a href="#把ArrayList变成线程安全的方式" class="headerlink" title="把ArrayList变成线程安全的方式"></a>把ArrayList变成线程安全的方式</h2><ul><li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用Vector类代替ArrayList，Vector是线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList的应用场景"><a href="#ArrayList和LinkedList的应用场景" class="headerlink" title="ArrayList和LinkedList的应用场景"></a>ArrayList和LinkedList的应用场景</h2><ul><li>前者适用于需要频繁访问和遍历集合元素，并且集合大小不经常改变的场景。</li><li>后者适用于频繁进行插入和删除操作，或者集合大小经常改变的场景。</li></ul><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>在添加元素时，如果当前元素个数已经达到了内部数组的容量上限就会触发扩容操作。</p><p>步骤如下：</p><ul><li>计算新的容量：一般会扩大为原容量的1.5倍，然后检查是否超过了最大容量限制。</li><li>创建新的数组：根据新容量创建更大的新数组。</li><li>复制元素：将原数组的元素逐个复制到新数组。</li><li>更新引用：将ArrayList内部指向原数组的引用指向新数组。</li><li>完成扩容：扩容完成后，可以继续添加新元素。</li></ul><p><em>（1.5倍可以充分利用移位操作，减少浮点数或者运算时间和运算次数）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新容量计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="线程安全的-List——CopyonWriteArraylist如何实现线程安全"><a href="#线程安全的-List——CopyonWriteArraylist如何实现线程安全" class="headerlink" title="线程安全的 List——CopyonWriteArraylist如何实现线程安全"></a>线程安全的 List——CopyonWriteArraylist如何实现线程安全</h2><p>CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到当前List集合保存数据的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//将当前数组拷贝一份的同时，让其长度加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//替换引用，将数组的引用指向给新数组的地址</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到源码可以知道写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。</p><p>在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。</p><p>以下为读操作，读没有加锁，所以一直能读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><ul><li>JDK1.7之前，HashMap数据结构是数组和链表，通过哈希算法将元素的键映射到数组中的槽位。如果多个键映射到同一个槽位则会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt="img"></p><ul><li>JDK1.8进行优化，当一个链表的长度超过8时就转换数据结构，不再使用链表存储，而是红黑树，查找时使用红黑树，时间复杂度为O(log n)，可以提高查询性能，但在数量较少时(数量小于6)，会将红黑树转换回链表。</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt="img"></p><h2 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="headerlink" title="哈希冲突解决方法"></a>哈希冲突解决方法</h2><ul><li><strong>链接法</strong>：使用链表或其他数据结构来存储冲突的键值对，将他们链接在同一个哈希桶中。</li><li><strong>开放寻址法</strong>：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</li><li><strong>再哈希法</strong>：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</li><li><strong>哈希桶扩容</strong>：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</li></ul><h2 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h2><p>不是。HashMap在多线程会存在下面的问题：</p><ul><li>JDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。</li><li>JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。</li></ul><p><em>如果要保证线程安全，可以通过这些方法来保证：</em></p><ul><li><em>多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</em></li><li><em>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</em></li></ul><h2 id="HashMap的put过程"><a href="#HashMap的put过程" class="headerlink" title="HashMap的put过程"></a>HashMap的put过程</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="img"></p><ul><li>根据要添加的键的哈希码计算在数组中的位置（索引）</li><li>检查该位置是否为空（即没有键值对存在）<ul><li>如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数加1，以便在进行迭代时发现并发修改。</li></ul></li><li>如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同<ul><li>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</li></ul></li><li>如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键<ul><li>如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。<ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到链表的头部。</li></ul></li><li>如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。<ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到红黑树中。</li></ul></li></ul></li><li>检查链表长度是否达到阈值（默认为8）<ul><li>如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。</li></ul></li><li>检查负载因子是否超过阈值（默认为0.75）<ul><li>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。</li></ul></li><li>扩容操作<ul><li>创建一个新的两倍大小的数组。</li><li>将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。</li><li>更新HashMap的数组引用和阈值参数。</li></ul></li><li>完成添加操作</li></ul><p><em>（HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。）</em></p><h2 id="HashMap的put-key-val-和get-key-过程"><a href="#HashMap的put-key-val-和get-key-过程" class="headerlink" title="HashMap的put(key, val)和get(key)过程"></a>HashMap的put(key, val)和get(key)过程</h2><ul><li>存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。</li><li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li></ul><h2 id="HashMap调用get方法一定安全吗"><a href="#HashMap调用get方法一定安全吗" class="headerlink" title="HashMap调用get方法一定安全吗"></a>HashMap调用get方法一定安全吗</h2><p>不一定。需注意以下两点：</p><ul><li>空指针异常：如果用null作为键调用get方法，而且HashMap没有初始化，那么会抛出空指针异常。（如果HashMap已经初始化，允许使用null为键）</li><li>线程安全：HashMap本身不是线程安全，如果需要在多线程环境使用类似HashMap的数据结构，可以考虑用ConcurrentHashMap。</li></ul><h2 id="HashMap一般用什么作为Key"><a href="#HashMap一般用什么作为Key" class="headerlink" title="HashMap一般用什么作为Key"></a>HashMap一般用什么作为Key</h2><p>用String作为Key，因为String对象不可变，一旦创建不可修改，确保了Key的稳定性。（如果Key可变，可能会导致HashCode和equals方法的不一致，进而影响HashMap的准确性。）</p><h2 id="为什么HashMap用红黑树而不是平衡二叉树"><a href="#为什么HashMap用红黑树而不是平衡二叉树" class="headerlink" title="为什么HashMap用红黑树而不是平衡二叉树"></a>为什么HashMap用红黑树而不是平衡二叉树</h2><ul><li>平衡二叉树追求”<strong>完全平衡</strong>“状态——任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li><li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是为什么大多数情况下使用红黑树的原因。</li></ul><h2 id="HashMap的Key可以为null吗"><a href="#HashMap的Key可以为null吗" class="headerlink" title="HashMap的Key可以为null吗"></a>HashMap的Key可以为null吗</h2><p>可以。</p><ul><li>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1720685862193-66a32b79-ddf0-46d5-87df-d2fc2b3d87cb.png" alt="img"></p><ul><li>hashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；</li><li>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个。</li></ul><h2 id="重写HashMap的equal和hashcode方法需要注意什么"><a href="#重写HashMap的equal和hashcode方法需要注意什么" class="headerlink" title="重写HashMap的equal和hashcode方法需要注意什么"></a>重写HashMap的equal和hashcode方法需要注意什么</h2><p>HashMap使用Key对象的hashCode()和equals方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p><p>同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li><p>如果o1.equals(o2)，那么o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为true的。</p></li><li><p>如果o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着o1.equals(o2)会为true。</p><p><em>（可以把hashCode理解为房间号，而equals理解为身份证号，住在同一个房间，不一定是同一个人，不住在同一个房间，必然不是同一个人。）</em></p></li></ul><h2 id="重写HashMap的equal方法不当会出现什么问题"><a href="#重写HashMap的equal方法不当会出现什么问题" class="headerlink" title="重写HashMap的equal方法不当会出现什么问题"></a>重写HashMap的equal方法不当会出现什么问题</h2><p>HashMap在比较元素时，会先通过hashCode进行比较，相同的情况下再通过equals进行比较。</p><p>所以 equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）</p><p>重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false，这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。</p><h2 id="列举HashMap在多线程下可能会出现的问题"><a href="#列举HashMap在多线程下可能会出现的问题" class="headerlink" title="列举HashMap在多线程下可能会出现的问题"></a>列举HashMap在多线程下可能会出现的问题</h2><ul><li>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul><h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>HashMap默认的负载因子是0.75，即如果HashMap中的元素个数超过了总容量的75%，就会触发扩容。</p><p>扩容包括以下两个步骤：</p><ul><li>对哈希表长度的扩展（2倍）</li><li>将旧哈希表中的数据放到新的哈希表中</li></ul><p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p><p>这个设计既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="HashMap的大小为什么是2的n次方大小呢？"><a href="#HashMap的大小为什么是2的n次方大小呢？" class="headerlink" title="HashMap的大小为什么是2的n次方大小呢？"></a>HashMap的大小为什么是2的n次方大小呢？</h2><p>在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize &#x3D; 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</p><p>之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p><h2 id="往hashmap存20个元素，会扩容几次？"><a href="#往hashmap存20个元素，会扩容几次？" class="headerlink" title="往hashmap存20个元素，会扩容几次？"></a>往hashmap存20个元素，会扩容几次？</h2><p>当插入 20 个元素时，HashMap 的扩容过程如下：</p><p><strong>初始容量</strong>：16</p><ul><li>插入第 1 到第 12 个元素时，不需要扩容。</li><li>插入第 13 个元素时，达到负载因子限制，需要扩容。此时，HashMap 的容量从 16 扩容到 32。</li></ul><p><strong>扩容后的容量</strong>：32</p><ul><li>插入第 14 到第 24 个元素时，不需要扩容。</li></ul><p>因此，总共会进行一次扩容。</p><h2 id="说说hashmap的负载因子"><a href="#说说hashmap的负载因子" class="headerlink" title="说说hashmap的负载因子"></a>说说hashmap的负载因子</h2><p>HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。</p><p>默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。</p><p>负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p><h2 id="HashMap和HashTable有什么区别"><a href="#HashMap和HashTable有什么区别" class="headerlink" title="HashMap和HashTable有什么区别"></a>HashMap和HashTable有什么区别</h2><ul><li><strong>HashMap线程不安全</strong>，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li><strong>HashTable线程安全</strong>，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li></ul><h2 id="HashMap一般怎么用"><a href="#HashMap一般怎么用" class="headerlink" title="HashMap一般怎么用"></a>HashMap一般怎么用</h2><p>HashMap主要用来存储键值对，可以调用put方法向其中加入元素，调用get方法获取某个键对应的值，也可以通过containsKey方法查看某个键是否存在。</p><h2 id="ConcurrentHashMap是怎么实现的"><a href="#ConcurrentHashMap是怎么实现的" class="headerlink" title="ConcurrentHashMap是怎么实现的"></a>ConcurrentHashMap是怎么实现的</h2><p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="img"></p><p>JDK 1.7 ConcurrentHashMap 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p><p>在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表，而 JDK 1.8 则使用了数组 + 链表&#x2F;红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="img"></p><p>JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 CAS 来初始化</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。<ul><li>如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul></li></ul><p>简而言之，就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</p><p>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。</p><h2 id="分段锁是怎么加锁的"><a href="#分段锁是怎么加锁的" class="headerlink" title="分段锁是怎么加锁的"></a>分段锁是怎么加锁的</h2><p>在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</p><p>在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。</p><h2 id="分段锁是可重入的吗"><a href="#分段锁是可重入的吗" class="headerlink" title="分段锁是可重入的吗"></a>分段锁是可重入的吗</h2><p>JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</p><h2 id="已经用了synchronized，为什么还要用CAS呢？"><a href="#已经用了synchronized，为什么还要用CAS呢？" class="headerlink" title="已经用了synchronized，为什么还要用CAS呢？"></a>已经用了synchronized，为什么还要用CAS呢？</h2><p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。</p><p><em>比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</em></p><p><em>当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</em></p><h2 id="ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="ConcurrentHashMap用了悲观锁还是乐观锁?"></a>ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p>悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。</li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul><h2 id="HashTable-底层实现原理是什么？"><a href="#HashTable-底层实现原理是什么？" class="headerlink" title="HashTable 底层实现原理是什么？"></a>HashTable 底层实现原理是什么？</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt="img"></p><ul><li>Hashtable的底层数据结构主要是<strong>数组加上链表</strong>，数组是主体，链表是解决hash冲突存在的。</li><li>HashTable是线程安全的，实现方式是<strong>Hashtable的所有公共方法均采用synchronized关键字</strong>，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。</li></ul><h2 id="HashTable线程安全是怎么实现的？"><a href="#HashTable线程安全是怎么实现的？" class="headerlink" title="HashTable线程安全是怎么实现的？"></a>HashTable线程安全是怎么实现的？</h2><p>因为它的put，get做成了同步方法，保证了Hashtable的线程安全性，每个操作数据的方法都进行同步控制之后，由此带来的问题——任何一个时刻<strong>只能有一个线程可以操纵HashTable，所以其效率比较低</strong>。</p><p><strong>HashTable是通过使用了 synchronized 关键字来保证其线程安全</strong>。</p><p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p><h2 id="HashTable和ConcurrentHashMap的区别"><a href="#HashTable和ConcurrentHashMap的区别" class="headerlink" title="HashTable和ConcurrentHashMap的区别"></a>HashTable和ConcurrentHashMap的区别</h2><ul><li><p>底层数据结构：</p><ul><li>前者采用数组+链表，数组是主体，链表解决哈希冲突；</li><li>后者在JDK7之前采用分段的数组+链表，JDK8之后采用数组+链表&#x2F;红黑树。</li></ul></li><li><p>实现线程安全的方式：</p><ul><li>前者将所有的方法都加了锁，效率低下，当一个线程访问同步方法，另一个线程也访问时，就会陷入阻塞轮询状态。</li><li>后者在JDK8之前采用分段锁，对整个数组进行分段分割，多线程访问不同数据段里的数据，不存在锁竞争，提高了并发访问；JDK8之后采用数组+链表&#x2F;红黑树，并发控制使用CAS和synchronized操作，更加提高了速度。</li></ul></li></ul><h2 id="HashMap，HashTable和ConcurrentMap的区别"><a href="#HashMap，HashTable和ConcurrentMap的区别" class="headerlink" title="HashMap，HashTable和ConcurrentMap的区别"></a>HashMap，HashTable和ConcurrentMap的区别</h2><ul><li>HashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li>HashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li>ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="Set集合的特点"><a href="#Set集合的特点" class="headerlink" title="Set集合的特点"></a>Set集合的特点</h2><p>元素唯一，不会出现重复的元素</p><h2 id="Set集合如何实现Key无重复的"><a href="#Set集合如何实现Key无重复的" class="headerlink" title="Set集合如何实现Key无重复的"></a>Set集合如何实现Key无重复的</h2><p>通过内部的数据结构（如哈希表、红黑树等）来实现Key的无重复。当向Set集合中插入元素时，会先根据以上的hashcode值来确定元素的存储位置，然后通过equals方法来判断是否已经存在相同的元素。<em>（如果存在就不会再次插入，保持了元素的唯一性。）</em></p><h2 id="有序的Set是什么"><a href="#有序的Set是什么" class="headerlink" title="有序的Set是什么"></a>有序的Set是什么</h2><p>TreeSet和LinkedHashSet。</p><p>前者基于红黑树实现，保证元素的自然顺序；后者基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序。</p><h2 id="记录插入顺序的集合是什么"><a href="#记录插入顺序的集合是什么" class="headerlink" title="记录插入顺序的集合是什么"></a>记录插入顺序的集合是什么</h2><p>通常指LinkedHashSet，不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/10/17/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/17/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><ul><li><strong>平台无关性</strong>：Java编写一次，运行无处不在。Java编译器将源代码编译成字节码，可以在任何安装了JVM的系统上运行。</li><li><strong>面向对象</strong>：Java是一门严格的面向对象的编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类、对象、继承、多态、抽象和封装。</li><li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关问题。</li></ul><h2 id="Java为什么是跨平台的"><a href="#Java为什么是跨平台的" class="headerlink" title="Java为什么是跨平台的"></a>Java为什么是跨平台的</h2><p>主要依赖于JVM。JVM也是一个软件，不同的平台有不同的版本。编写的Java源码编译后会生成一种.class文件，称为字节码文件。JVM就是负责将字节码文件翻译成特定平台下的机器码然后运行。只要在不同平台上安装对应的JVM就可以运行字节码文件，运行编写的Java程序。</p><p><em>（不同平台下编译生成的字节码是一样的，但是由 JVM编译成的机器码却不一样）</em></p><p><em>（跨平台的是 Java程序，不是 JVM。JVM是用 C&#x2F;C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM。）</em></p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713860588639-bb89fc8e-30b6-4d18-a329-f3fea52c729a.png" alt="img"></p><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p>JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p><h2 id="JVM、JDK、JRE三者的关系"><a href="#JVM、JDK、JRE三者的关系" class="headerlink" title="JVM、JDK、JRE三者的关系"></a>JVM、JDK、JRE三者的关系</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240725230247664.png" alt="image-20240725230247664"></p><ul><li>JVM是Java虚拟机，是Java程序运行的环境，负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li><li>JDK是Java开发工具包，是开发Java程序所需的工具集合。包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li><li>JRE是Java运行时的环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li></ul><h2 id="为什么Java解释和编译都有"><a href="#为什么Java解释和编译都有" class="headerlink" title="为什么Java解释和编译都有"></a>为什么Java解释和编译都有</h2><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤——编译和解释。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="img"></p><p><strong>编译性</strong>：</p><ul><li>Java源代码首先被编译成字节码，JIT会把编译过的机器码保存起来，以备下次使用。</li></ul><p><strong>解释性</strong>：</p><ul><li>JVM中有一个方法调用计数器，当累计计数大于一定值时，就使用JIT进行编译生成机器码文件，否则就使用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li></ul><p>所以Java既是编译性也是解释性语言，默认采用解释器和编译器混合的模式。</p><h2 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a><strong>编译型语言和解释型语言的区别？</strong></h2><p>编译型语言和解释型语言的区别在于：</p><ul><li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。</li><li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</li><li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li></ul><h2 id="Python和Java区别是什么？"><a href="#Python和Java区别是什么？" class="headerlink" title="Python和Java区别是什么？"></a>Python和Java区别是什么？</h2><ul><li>Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行</li><li>python是一种解释语言，翻译时会在执行程序的同时进行翻译。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><p>Java支持数据类型分为：<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><p>基本数据类型包括：</p><ul><li>数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</li><li>字符型：char</li><li>布尔型：boolean</li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><p><strong>注意</strong>：</p><ul><li>java八种基本数据类型的字节数:1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li><li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li><li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li><li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li><li>char类型是无符号的，不能为负，所以是0开始的</li></ul><h2 id="数据类型转换方式"><a href="#数据类型转换方式" class="headerlink" title="数据类型转换方式"></a>数据类型转换方式</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240726003850183.png" alt="image-20240726003850183"></p><ul><li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。</li><li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。</li><li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。</li><li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。</li></ul><h2 id="类型互转会出现什么问题"><a href="#类型互转会出现什么问题" class="headerlink" title="类型互转会出现什么问题"></a>类型互转会出现什么问题</h2><ul><li>数据丢失：大类型转小类型，可能截断后高位丢失，如long转int</li><li>数据溢出：如double转int</li><li>精度损失：浮点数类型转换，如float转double</li><li>类型不匹配</li></ul><h2 id="为什么用bigDecimal而不用double"><a href="#为什么用bigDecimal而不用double" class="headerlink" title="为什么用bigDecimal而不用double"></a>为什么用bigDecimal而不用double</h2><p>double执行二进制浮点运算，会出现精度丢失，Decimal是精确运算，一般用于金钱的运算。</p><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p><p>eg. Integer i &#x3D; 10；&#x2F;&#x2F;装箱</p><p>​int n &#x3D; i；&#x2F;&#x2F;拆箱</p><p>自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p><p><strong>赋值时</strong>：</p><p>最常见的一种情况，Java1.5前需要手动转换，现在所有转换由编译器完成。</p><p><strong>方法调用时</strong>：</p><p>可以传入原始数据值或者对象，同样编译器会帮我们转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p><strong>自动装箱的弊端</strong>：</p><p>如果在一个循环中进行自动装箱操作，下面的例子会创建多个多余的对象，影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>sum进行自动拆箱，然后数值相加，最好自动装箱转换成Integer对象。所以循环中会创建4000个无用的Integer对象，会降低程序性能并且加重垃圾回收的工作量。所以应该正确声明变量类型，避免自动装箱引起的性能问题。</p><h2 id="Java为什么要有Integer"><a href="#Java为什么要有Integer" class="headerlink" title="Java为什么要有Integer"></a>Java为什么要有Integer</h2><ul><li><p>Integer是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性（数据）跟处理这些数据的方法结合在一起。（比如Integer中的parseInt()等方法）。</p></li><li><p>Java绝大部分方法或类都是用来处理类类型对象的。</p><ul><li><p>泛型中：只能使用引用类型，而不能使用基本类型。如果在泛型中使用int类型，就必须使用Integer包装类。（例如：Collections.sort()内部放Integer而不是int。）</p></li><li><p>转换中：基本类型和引用类型不能直接进行转换，必须使用包装类来实现。（例如，int不能直接转成String，需要先转换成Integer类型，再转成String类型。）</p></li><li><p>集合中：Java集合只能存储对象，而不能存储基本数据类型。（例如，ArrayList集合类就只能以类作为他的存储对象，如果用Integer包装类，可以直接使用stream()方法来计算所有元素的和：int sum &#x3D; list.stream().mapToInt(Integer::intValue).sum();）</p></li></ul></li></ul><h2 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h2><ul><li>类型：int是基本数据类型，Integer是引用类型。前者是预定义的，不需要实例化就可以使用，而后者需要通过实例化对象来使用。意味着前者不需要额外的内存分配，而后者必须为对象分配内存。性能方面，前者通常较快。</li><li>自动装箱与拆箱：可以自动装箱和拆箱。</li><li>空指针异常：int可以直接赋值为0，而Integer必须实例化对象来赋值，否则操作时会出现空指针异常，因为被赋予了null值，而null值无法自动拆箱。</li></ul><h2 id="为什么要保留int类型"><a href="#为什么要保留int类型" class="headerlink" title="为什么要保留int类型"></a>为什么要保留int类型</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身，所以基本数据类型读写效率更高。此外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存方面，而一个int类型数据只占用4字节的内存空间。所以读写效率和存储效率基本类型都比包装类高效。</p><h2 id="Integer的缓存"><a href="#Integer的缓存" class="headerlink" title="Integer的缓存"></a>Integer的缓存</h2><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。默认情况下这个范围是-128-127，当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><p>面向对象是一种编程范式，<strong>将现实世界中的事物抽象成对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的性能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul><li><strong>封装</strong>：将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。目的是增强安全性和简化编程，使对象更加独立。</li><li><strong>继承</strong>：使得子类自动共享父类数据结构和方法的机制。是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li><li><strong>多态</strong>：允许不同类的对象对同一消息作出响应，即同一个接口，使得不同的实例而执行不同操作、可分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。</li></ul><h2 id="多态体现在哪几个方面"><a href="#多态体现在哪几个方面" class="headerlink" title="多态体现在哪几个方面"></a>多态体现在哪几个方面</h2><ul><li><strong>方法重载</strong>：指同一个类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但传入的参数不同，编译器会在编译时确定调用哪个方法。<ul><li>示例：对于一个add方法，可以定义为add(int a, int b)和add(double a, double b)。</li></ul></li><li><strong>方法重写</strong>：指子类能够提供父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。<ul><li>示例：在一个动物类中，定义一个sound方法，子类Dog可以重写该方法以实现bark，而Cat可以实现meow。</li></ul></li><li><strong>接口与实现</strong>：多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法，使得程序在面对不同具体实现时保持一贯的调用方式。<ul><li>示例：多个类（如Dog，cat）都实现了一个Animal接口，当用Animal类型的引用来调用makeSound方法时，会触发对应的实现。</li></ul></li><li><strong>向下转型和向上转型</strong>：向上转型：可以使用父类类型的引用指向子类对象，这样可以在运行时采用不同的子类实现；向下转型：父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免ClassCastException。</li></ul><h2 id="多态解决了什么问题"><a href="#多态解决了什么问题" class="headerlink" title="多态解决了什么问题"></a>多态解决了什么问题</h2><p><em>多态指子类可以替换父类，在实际的代码运行中调用子类的方法实现。</em></p><p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的if-else语句等。</p><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><ul><li><strong>单一职责原则（SRP）</strong>：一个类只负责处理一种改变（一项职责）。</li><li><strong>开放封闭原则（OCP）</strong>：对扩展开放，对修改关闭。</li><li><strong>里氏替换原则（LSP）</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。子类继承父类时，除了添加新的方法完成新增功能外，尽量不要重写父类的方法。</li><li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li><li><strong>最少知识原则（迪米特法则）（Law of Demeter）</strong>：一个对象应当对其他对象有尽可能少的了解。</li><li><strong>组合&#x2F;聚合复用原则</strong>：优先使用对象组合，而不是类继承。</li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul><li><strong>重载</strong>：同一个类中可以定义多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序），编译器会根据调用时的参数类型决定调用哪个方法。</li><li><strong>重写</strong>：子类重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@Override注解来表示重写。</li></ul><h2 id="抽象类和普通类的区别"><a href="#抽象类和普通类的区别" class="headerlink" title="抽象类和普通类的区别"></a>抽象类和普通类的区别</h2><ul><li><strong>实例化</strong>：普通类可以直接使用new关键字来实例化对象；而抽象类不能直接实例化，只能被继承。</li><li><strong>方法实现</strong>：普通类的方法可以有具体实现；而抽象类中没有方法体，必须在继承它的子类中被重写（除非子类也是抽象类）。</li><li><strong>继承</strong>：一个类可以继承一个普通类，继承后的新类可以选择重写父类的方法，而且可以继承多个接口；而一个类只能继承一个抽象类，子类必须实现父类中的所有抽象方法，除非子类也是抽象类，但可以同时实现多个接口。</li><li><strong>实现限制（用途）</strong>：普通类可以被其他类继承和使用；而抽象类一般用于作为基类，被其他类继承和扩展使用。</li></ul><h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p><strong>两者特点</strong>：</p><ul><li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li><li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java8以后可以有默认方法和静态方法）。适用于定义类的能力和功能。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>实现方式</strong>：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可以在抽象类中实现。</li><li><strong>访问修饰符</strong>：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可以被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li><li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态变量）。</li></ul><h2 id="抽象类能否加final修饰"><a href="#抽象类能否加final修饰" class="headerlink" title="抽象类能否加final修饰"></a>抽象类能否加final修饰</h2><p>不能。</p><p>Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p><h2 id="接口里面可以定义的方法"><a href="#接口里面可以定义的方法" class="headerlink" title="接口里面可以定义的方法"></a>接口里面可以定义的方法</h2><ul><li><strong>抽象方法</strong>：接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是public和abstract，这些修饰符可以省略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>默认方法</strong></li></ul><p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法</strong></li></ul><p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>私有方法</strong></li></ul><p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类能否被实例化"><a href="#抽象类能否被实例化" class="headerlink" title="抽象类能否被实例化"></a>抽象类能否被实例化</h2><p>不能。</p><p>所以不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p><p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码可以运行</span></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure><p>在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。</p><p>简而言之，抽象类不能直接实例化，但<strong>通过继承抽象类</strong>并<strong>实现所有抽象方法</strong>的子类是可以被实例化的。</p><h2 id="接口能否包含构造函数"><a href="#接口能否包含构造函数" class="headerlink" title="接口能否包含构造函数"></a>接口能否包含构造函数</h2><p>在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p><p><em>（构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用。）</em></p><p>java的接口不能new所以不需要构造函数，根本就没法调用。</p><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><p>二者与类本身关联，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</p><p><strong>静态变量</strong>（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p><ul><li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li><li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次分配内存。</li><li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</li></ul><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int staticVar = 0; // 静态变量</span><br><span class="line"></span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        staticVar++; // 每创建一个对象，静态变量自增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void printStaticVar() &#123;</span><br><span class="line">        System.out.println(&quot;Static Var: &quot; + staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = new MyClass();</span><br><span class="line">MyClass.printStaticVar(); // 输出 Static Var: 2</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong>是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p><ul><li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</li><li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</li><li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static void incrementCount() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void displayCount() &#123;</span><br><span class="line">        System.out.println(&quot;Count: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass.incrementCount(); // 调用静态方法</span><br><span class="line">MyClass.displayCount();   // 输出 Count: 1</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>静态变量</strong>：常用于需要在所有对象间共享的数据，如计数器、常量等。</li><li><strong>静态方法</strong>：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理</li></ul><h2 id="非静态内部类和静态内部类的区别"><a href="#非静态内部类和静态内部类的区别" class="headerlink" title="非静态内部类和静态内部类的区别"></a>非静态内部类和静态内部类的区别</h2><ul><li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li><li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</li><li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li><li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li><li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li></ul><h2 id="非静态内部类可以直接访问外部方法，编译器是怎么做到的"><a href="#非静态内部类可以直接访问外部方法，编译器是怎么做到的" class="headerlink" title="非静态内部类可以直接访问外部方法，编译器是怎么做到的"></a>非静态内部类可以直接访问外部方法，编译器是怎么做到的</h2><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p><p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</p><h2 id="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"><a href="#有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的" class="headerlink" title="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"></a>有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的</h2><p>当实例化一个子类对象时，静态成员变量、静态构造方法和静态方法的加载顺序遵循以下步骤：</p><ul><li>在创建子类对象之前，首先会加载父类的静态成员变量和静态代码块（构造方法无法被 <code>static</code> 修饰，因此这里是静态代码块）。这个加载是在类首次被加载时进行的，且只会发生一次。</li><li>接下来，加载子类的静态成员变量和静态代码块。这一过程也只发生一次，即当首次使用子类的相关代码时。</li><li>之后，执行实例化子类对象的过程。这时会呼叫父类构造方法，然后是子类的构造方法。</li></ul><p>具体加载顺序可以简要总结为：</p><ul><li><strong>父类静态成员变量、静态代码块</strong>（如果有）</li><li><strong>子类静态成员变量、静态代码块</strong>（如果有）</li><li><strong>父类构造方法</strong>（实例化对象时）</li><li><strong>子类构造方法</strong>（实例化对象时）</li></ul><p><strong>示例代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">parentStaticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">childStaticVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Child() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line">Child <span class="keyword">static</span> block</span><br><span class="line">Parent constructor</span><br><span class="line">Child constructor</span><br></pre></td></tr></table></figure><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="img"></p><ul><li><strong>浅拷贝</strong>：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。相当于只是创建了一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型字段，只是将引用复制到新对象中，两个对象指向同一个引用对象。</li><li><strong>深拷贝</strong>：复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。相当于会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li></ul><h2 id="实现深拷贝的三种方法"><a href="#实现深拷贝的三种方法" class="headerlink" title="实现深拷贝的三种方法"></a>实现深拷贝的三种方法</h2><ul><li>实现 Cloneable 接口并重写 clone() 方法</li></ul><p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用序列化和反序列化</li></ul><p>通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动递归复制</li></ul><p>针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p><p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><ul><li><strong>适用于多种数据类型执行相同的代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。</p><p>引入泛型，它将提供类型的约束，提供编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><p><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><p><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure><p><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure><p><strong>使用clone()方法</strong>：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure><p><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SerializedObject.java</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeserializedObject.java</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h2 id="Java创建对象除了new还有什么方式"><a href="#Java创建对象除了new还有什么方式" class="headerlink" title="Java创建对象除了new还有什么方式"></a>Java创建对象除了new还有什么方式</h2><ul><li><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过反序列化创建对象</strong>：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过clone创建对象</strong>：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new出的对象什么时候回收"><a href="#new出的对象什么时候回收" class="headerlink" title="new出的对象什么时候回收"></a>new出的对象什么时候回收</h2><p>由Java的垃圾回收器（Garbage Collector）负责回收。其工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p><p>回收的算法：</p><ul><li><strong>引用计数法</strong>：个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li><li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li><li><strong>终结器</strong>：如果对象重写了finalize()方法，垃圾回收器会在回收对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。但是由于终结器机制的执行时间不确定，可能会导致不可预测的问题，所以不推荐使用。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h2 id="反射的特性"><a href="#反射的特性" class="headerlink" title="反射的特性"></a>反射的特性</h2><ul><li><p><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</p></li><li><p><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</p></li><li><p><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</p></li><li><p><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</p></li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="img"></p><h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><ul><li><strong>加载数据库驱动</strong></li></ul><p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。</p><p>这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>配置文件加载</strong></li></ul><p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><p>Spring通过XML配置模式装载Bean的过程：</p><ul><li>将程序中所有XML或properties配置文件加载入内存</li><li>Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li><li>使用反射机制，根据这个字符串获得某个类的Class实例</li><li>动态配置实例的属性</li></ul><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析配置文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestInvoke</span><br><span class="line">I am fine</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h2 id="注解的作用域"><a href="#注解的作用域" class="headerlink" title="注解的作用域"></a>注解的作用域</h2><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p><ul><li><p>类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</p></li><li><p>方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</p></li><li><p>字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</p></li></ul><p>除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="介绍一下异常"><a href="#介绍一下异常" class="headerlink" title="介绍一下异常"></a>介绍一下异常</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="img"></p><ul><li><strong>Error（错误）</strong>：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常程序不应该捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。</li><li><strong>Exception（异常）</strong>：表示程序本身可以处理的异常事件。<ul><li><strong>非运行时异常</strong>：在编译时必须被捕获或者声明抛出。通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。这种异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li><li><strong>运行时异常（RuntimeException）</strong>：由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。这种异常不需要在编译时强制捕获或声明。</li></ul></li></ul><h2 id="Java异常处理有哪些"><a href="#Java异常处理有哪些" class="headerlink" title="Java异常处理有哪些"></a>Java异常处理有哪些</h2><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p><ul><li>try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType3 e3) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionType(&quot;Exception message&quot;);</span><br></pre></td></tr></table></figure><ul><li>throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常为什么不用throws"><a href="#抛出异常为什么不用throws" class="headerlink" title="抛出异常为什么不用throws"></a>抛出异常为什么不用throws</h2><p>如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。</p><ul><li><strong>Unchecked Exceptions</strong>：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。</li><li><strong>捕获和处理异常</strong>：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。</li></ul><h2 id="try-catch中的语句运行情况"><a href="#try-catch中的语句运行情况" class="headerlink" title="try-catch中的语句运行情况"></a>try-catch中的语句运行情况</h2><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。</p><h2 id="try-return-“a”-fianlly-return-“b”-这条语句返回什么"><a href="#try-return-“a”-fianlly-return-“b”-这条语句返回什么" class="headerlink" title="try{return “a”} fianlly{return “b”}这条语句返回什么"></a>try{return “a”} fianlly{return “b”}这条语句返回什么</h2><p>finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。</p><h1 id="object"><a href="#object" class="headerlink" title="object"></a>object</h1><h2 id="与-equals-有什么区别？"><a href="#与-equals-有什么区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals 有什么区别？"></a>&#x3D;&#x3D; 与 equals 有什么区别？</h2><p>对于字符串变量来说，使用”=&#x3D;”和”equals”比较字符串时，其比较方法不同。”&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址，”equals”比较字符串包含内容是否相同。</p><p>对于非字符串变量来说，如果没有对equals()进行重写的话，”&#x3D;&#x3D;” 和 “equals”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。</p><ul><li>&#x3D;&#x3D;：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</li><li>equals()：比较的是两个字符串的内容，属于内容比较。</li></ul><h2 id="StringBuffer和StringBuild区别是什么？"><a href="#StringBuffer和StringBuild区别是什么？" class="headerlink" title="StringBuffer和StringBuild区别是什么？"></a>StringBuffer和StringBuild区别是什么？</h2><p>区别：</p><ul><li>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</li><li>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</li><li>StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</li></ul><p>线程安全：</p><ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul><p>使用场景：</p><ul><li>操作少量的数据使用 String。</li><li>单线程操作大量数据使用 StringBuilder。</li><li>多线程操作大量数据使用 StringBuffer。</li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716098439957-a080de5a-d69e-4c6e-a5e8-111f976f9b5b.webp" alt="img"></p><h1 id="Java-1-8-新特性"><a href="#Java-1-8-新特性" class="headerlink" title="Java 1.8 新特性"></a>Java 1.8 新特性</h1><h2 id="stream的API"><a href="#stream的API" class="headerlink" title="stream的API"></a>stream的API</h2><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理。</p><p>适用场景举例：</p><ul><li>场景一：过滤并收集满足条件的元素</li></ul><p>eg. 从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。</p><p><strong>没有Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。</p><p><strong>使用Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这里，我们直接在原始列表上调用.stream()方法创建了一个流，使用.filter()中间操作筛选出长度大于3的字符串，最后使用.collect(Collectors.toList())终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。</p><ul><li>场景二：计算列表中所有数字的总和</li></ul><p>eg. 计算一个数字列表中所有元素的总和。</p><p><strong>没有Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。</p><p><strong>使用Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure><p>通过Stream API，我们可以先使用.mapToInt()将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用.sum()方法来计算总和，极大地简化了代码。</p><h2 id="Stream流的并行API是什么？"><a href="#Stream流的并行API是什么？" class="headerlink" title="Stream流的并行API是什么？"></a>Stream流的并行API是什么？</h2><p>是 ParallelStream。</p><p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。</p><p>Stream串行流与并行流的主要区别：</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="img"></p><p>对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I&#x2F;O密集的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择。</p><h2 id="completableFuture怎么用的？"><a href="#completableFuture怎么用的？" class="headerlink" title="completableFuture怎么用的？"></a>completableFuture怎么用的？</h2><p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p><ul><li>Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。</li><li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。</li></ul><p>下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。</p><p>Future(ListenableFuture)的实现（回调地狱）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure><p>CompletableFuture的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure><p>显然，CompletableFuture的实现更为简洁，可读性更好。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="img"></p><p>CompletableFuture实现了两个接口（如上图所示)：Future、CompletionStage。</p><ul><li>Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。</li><li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="怎么把一个对象从一个jvm转移到另一个jvm?"></a>怎么把一个对象从一个jvm转移到另一个jvm?</h2><ul><li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li><li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li><li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li><li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li></ul><h2 id="序列化和反序列化的缺点"><a href="#序列化和反序列化的缺点" class="headerlink" title="序列化和反序列化的缺点"></a>序列化和反序列化的缺点</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。</p><ul><li>无法跨语言： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</li><li>容易被攻击：Java 序列化是不安全的，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。</li><li>序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</li></ul><h2 id="那么该如何实现"><a href="#那么该如何实现" class="headerlink" title="那么该如何实现"></a>那么该如何实现</h2><p>考虑用主流序列化框架，比如FastJson、Protobuf来替代Java序列化。</p><p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。</p><h2 id="将对象转为二进制字节流具体怎么实现"><a href="#将对象转为二进制字节流具体怎么实现" class="headerlink" title="将对象转为二进制字节流具体怎么实现?"></a>将对象转为二进制字节流具体怎么实现?</h2><p>像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。</p><p>在Java中通过序列化对象流来完成序列化和反序列化：</p><ul><li>ObjectOutputStream：通过writeObject(）方法做序列化操作。</li><li>ObjectInputStrean：通过readObject()方法做反序列化操作。</li></ul><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p><p>实现对象序列化：</p><ul><li>让类实现Serializable接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建输出流并写入对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对象反序列化：</p><ul><li>创建输入流并读取对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="volatile和sychronized如何实现单例模式"><a href="#volatile和sychronized如何实现单例模式" class="headerlink" title="volatile和sychronized如何实现单例模式"></a>volatile和sychronized如何实现单例模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字修饰变量 防止指令重排序</span></span><br><span class="line">    private <span class="keyword">static</span> volatile <span class="title class_">SingleTon</span> instance = <span class="literal">null</span>;</span><br><span class="line">    private <span class="title class_">SingleTon</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">static</span>  <span class="title class_">SingleTon</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块 只有在第一次获取对象的时候会执行到，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦</span></span><br><span class="line">            <span class="title function_">synchronized</span>(<span class="params">SingleTon.<span class="keyword">class</span></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。</p><ul><li>保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。</li><li>禁止指令重排序优化。</li></ul><p>由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p><h2 id="代理模式和适配器模式有什么区别？"><a href="#代理模式和适配器模式有什么区别？" class="headerlink" title="代理模式和适配器模式有什么区别？"></a>代理模式和适配器模式有什么区别？</h2><ul><li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。</li><li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。</li><li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Java怎么实现网络IO高并发编程？"><a href="#Java怎么实现网络IO高并发编程？" class="headerlink" title="Java怎么实现网络IO高并发编程？"></a><strong>Java怎么实现网络IO高并发编程？</strong></h2><p>可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112641716.png" alt="image-20240820112641716"></p><p>NIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112656259.png" alt="image-20240820112656259"></p><h2 id="BIO、NIO、AIO区别是什么？"><a href="#BIO、NIO、AIO区别是什么？" class="headerlink" title="BIO、NIO、AIO区别是什么？"></a>BIO、NIO、AIO区别是什么？</h2><ul><li>BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul><h2 id="NIO是怎么实现的？"><a href="#NIO是怎么实现的？" class="headerlink" title="NIO是怎么实现的？"></a>NIO是怎么实现的？</h2><p>NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。</p><p>同步的核心就Selector（I&#x2F;O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。</p><p>NIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。</p><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p><p>Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="img"></p><h2 id="有哪个框架用到NIO了吗？"><a href="#有哪个框架用到NIO了吗？" class="headerlink" title="有哪个框架用到NIO了吗？"></a>有哪个框架用到NIO了吗？</h2><p><strong>Netty。</strong></p><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="img"></p><p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">// 添加学生对象到列表中</span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure><h2 id="Native方法解释一下"><a href="#Native方法解释一下" class="headerlink" title="Native方法解释一下"></a>Native方法解释一下</h2><p>在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。</p><p>在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现native方法，你需要完成以下步骤：</p><ol><li><strong>生成JNI头文件</strong>：使用javah工具从你的Java类生成C&#x2F;C++的头文件，这个头文件包含了所有native方法的原型。</li><li><strong>编写本地代码</strong>：使用C&#x2F;C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。</li><li><strong>编译本地代码</strong>：将C&#x2F;C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）</li><li><strong>加载本地库</strong>：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145028364.png" alt="image-20240814145028364"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145056943.png" alt="image-20240814145056943"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145133144.png" alt="image-20240814145133144"></p><h1 id="客户-服务器方式和对等方式"><a href="#客户-服务器方式和对等方式" class="headerlink" title="客户-服务器方式和对等方式"></a>客户-服务器方式和对等方式</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145212152.png" alt="image-20240814145212152"></p><h2 id="C-S方式"><a href="#C-S方式" class="headerlink" title="C&#x2F;S方式"></a>C&#x2F;S方式</h2><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145533399.png" alt="image-20240814145533399"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145557894.png" alt="image-20240814145557894"></p><h2 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h2><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145720582.png" alt="image-20240814145720582"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145740501.png" alt="image-20240814145740501"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145828368.png" alt="image-20240814145828368"></p><h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145940754.png" alt="image-20240814145940754"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150003692.png" alt="image-20240814150003692"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150312518.png" alt="image-20240814150312518"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150257580.png" alt="image-20240814150257580"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150351930.png" alt="image-20240814150351930"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150416657.png" alt="image-20240814150416657"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150542283.png" alt="image-20240814150542283"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150604076.png" alt="image-20240814150604076"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150630692.png" alt="image-20240814150630692"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150854576.png" alt="image-20240814150854576"></p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151011045.png" alt="image-20240814151011045"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151041427.png" alt="image-20240814151041427"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151120515.png" alt="image-20240814151120515"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151219973.png" alt="image-20240814151219973"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151248886.png" alt="image-20240814151248886"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152200176.png" alt="image-20240814152200176"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152300753.png" alt="image-20240814152300753"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152329601.png" alt="image-20240814152329601"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152352852.png" alt="image-20240814152352852"></p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152818541.png" alt="image-20240814152818541" style="zoom:80%;"><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152725867.png" alt="image-20240814152725867"></p><h1 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152906799.png" alt="image-20240814152906799"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153752164.png" alt="image-20240814153752164"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153700428.png" alt="image-20240814153700428"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153846608.png" alt="image-20240814153846608"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153934314.png" alt="image-20240814153934314"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154019389.png" alt="image-20240814154019389"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154122663.png" alt="image-20240814154122663"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154223820.png" alt="image-20240814154223820"></p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154259210.png" alt="image-20240814154259210"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160421162.png" alt="image-20240814160421162"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160450645.png" alt="image-20240814160450645"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160606888.png" alt="image-20240814160606888"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160613521.png" alt="image-20240814160613521"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160702858.png" alt="image-20240814160702858"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160740305.png" alt="image-20240814160740305"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160759152.png" alt="image-20240814160759152"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160859362.png" alt="image-20240814160859362"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160951504.png" alt="image-20240814160951504"></p><h1 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161135431.png" alt="image-20240814161135431"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161200612.png" alt="image-20240814161200612"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161240233.png" alt="image-20240814161240233"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161316978.png" alt="image-20240814161316978"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161709904.png" alt="image-20240814161709904"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161743596.png" alt="image-20240814161743596"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161811782.png" alt="image-20240814161811782"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161920500.png" alt="image-20240814161920500"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161927901.png" alt="image-20240814161927901"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161948924.png" alt="image-20240814161948924"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162012460.png" alt="image-20240814162012460"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162051922.png" alt="image-20240814162051922"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162139785.png" alt="image-20240814162139785"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162230627.png" alt="image-20240814162230627"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162353628.png" alt="image-20240814162353628"></p><p><strong>若Web缓存的命中率比较高，则大大减少了该链路上的通信量，因此减少了访问因特网的时延。</strong></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162552152.png" alt="image-20240814162552152"></p><p>若已过期，则如下图：</p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162532542.png" alt="image-20240814162532542"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162708178.png" alt="image-20240814162708178"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162749726.png" alt="image-20240814162749726"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191337579.png" alt="image-20240813191337579"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191428500.png" alt="image-20240813191428500"></p><h1 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191540313.png" alt="image-20240813191540313"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191728152.png" alt="image-20240813191728152"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191749334.png" alt="image-20240813191749334"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191859414.png" alt="image-20240813191859414"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191939871.png" alt="image-20240813191939871"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192023369.png" alt="image-20240813192023369"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192100188.png" alt="image-20240813192100188"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192132584.png" alt="image-20240813192132584"></p><h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192240304.png" alt="image-20240813192240304"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192338267.png" alt="image-20240813192338267"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192410822.png" alt="image-20240813192410822"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192512481.png" alt="image-20240813192512481"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192628455.png" alt="image-20240813192628455"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192659817.png" alt="image-20240813192659817"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192709502.png" alt="image-20240813192709502"></p><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192759530.png" alt="image-20240813192759530"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193254468.png" alt="image-20240813193254468"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193014418.png" alt="image-20240813193014418"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193140423.png" alt="image-20240813193140423"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193221498.png" alt="image-20240813193221498"></p><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102444644.png" alt="image-20240814102444644"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102509059.png" alt="image-20240814102509059"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102546596.png" alt="image-20240814102546596"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102755530.png" alt="image-20240814102755530"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102848409.png" alt="image-20240814102848409"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102932658.png" alt="image-20240814102932658"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103106041.png" alt="image-20240814103106041"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103136291.png" alt="image-20240814103136291"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103253170.png" alt="image-20240814103253170"></p><h1 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114522435.png" alt="image-20240814114522435"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114600883.png" alt="image-20240814114600883"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114636925.png" alt="image-20240814114636925"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114841235.png" alt="image-20240814114841235"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115004457.png" alt="image-20240814115004457"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115046267.png" alt="image-20240814115046267"></p><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115512173.png" alt="image-20240814115512173"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115551907.png" alt="image-20240814115551907"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115756066.png" alt="image-20240814115756066"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115908782.png" alt="image-20240814115908782"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120023961.png" alt="image-20240814120023961"></p><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120107047.png" alt="image-20240814120107047"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120123394.png" alt="image-20240814120123394"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120330906.png" alt="image-20240814120330906"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120601606.png" alt="image-20240814120601606"></p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120610887.png" alt="image-20240814120610887" style="zoom:67%;"><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120820903.png" alt="image-20240814120820903"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814121911333.png" alt="image-20240814121911333"></p><p>若不等待2MSL，则如下图</p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122043286.png" alt="image-20240814122043286"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122153570.png" alt="image-20240814122153570"></p><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122324269.png" alt="image-20240814122324269"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123143671.png" alt="image-20240814123143671"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122407436.png" alt="image-20240814122407436"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122524309.png" alt="image-20240814122524309"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122543714.png" alt="image-20240814122543714"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122558058.png" alt="image-20240814122558058"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122635196.png" alt="image-20240814122635196"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122657087.png" alt="image-20240814122657087"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122719616.png" alt="image-20240814122719616"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122728111.png" alt="image-20240814122728111"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122746186.png" alt="image-20240814122746186"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122818216.png" alt="image-20240814122818216"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122857566.png" alt="image-20240814122857566"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122923360.png" alt="image-20240814122923360"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122956048.png" alt="image-20240814122956048"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123010140.png" alt="image-20240814123010140"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123037611.png" alt="image-20240814123037611"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123103340.png" alt="image-20240814123103340"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123118430.png" alt="image-20240814123118430"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812201248589.png" alt="image-20240812201248589"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812201327196.png" alt="image-20240812201327196"></p><h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205024568.png" alt="image-20240812205024568"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205120097.png" alt="image-20240812205120097"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205133787.png" alt="image-20240812205133787"></p><h1 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205211373.png" alt="image-20240812205211373"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205257315.png" alt="image-20240812205257315"></p><h2 id="分类编址的IPv4服务"><a href="#分类编址的IPv4服务" class="headerlink" title="分类编址的IPv4服务"></a>分类编址的IPv4服务</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205437686.png" alt="image-20240812205437686"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205613833.png" alt="image-20240812205613833"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205733387.png" alt="image-20240812205733387"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205818054.png" alt="image-20240812205818054"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205855760.png" alt="image-20240812205855760"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205933774.png" alt="image-20240812205933774"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205946994.png" alt="image-20240812205946994"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210127298.png" alt="image-20240812210127298"></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210245529.png" alt="image-20240812210245529"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210307165.png" alt="image-20240812210307165"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210346139.png" alt="image-20240812210346139"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210806177.png" alt="image-20240812210806177"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210832696.png" alt="image-20240812210832696"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210852592.png" alt="image-20240812210852592"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210908542.png" alt="image-20240812210908542"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210648408.png" alt="image-20240812210648408"></p><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211246069.png" alt="image-20240812211246069"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211317457.png" alt="image-20240812211317457"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211356139.png" alt="image-20240812211356139"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211505076.png" alt="image-20240812211505076"></p><h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212511827.png" alt="image-20240812212511827"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211758455.png" alt="image-20240812211758455"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211846486.png" alt="image-20240812211846486"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211932600.png" alt="image-20240812211932600"></p><p>从子网1~8中任选5个分配给左图中的N1~N5</p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212323608.png" alt="image-20240812212323608"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212429093.png" alt="image-20240812212429093"></p><h1 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151158274.png" alt="image-20240813151158274"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151241091.png" alt="image-20240813151241091"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151306838.png" alt="image-20240813151306838"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813152058421.png" alt="image-20240813152058421"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151343600.png" alt="image-20240813151343600"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151416984.png" alt="image-20240813151416984"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151515452.png" alt="image-20240813151515452"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151808369.png" alt="image-20240813151808369"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151834342.png" alt="image-20240813151834342"></p><h1 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813152127920.png" alt="image-20240813152127920"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160658240.png" alt="image-20240813160658240"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160037987.png" alt="image-20240813160037987"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160208394.png" alt="image-20240813160208394"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160309433.png" alt="image-20240813160309433"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160359795.png" alt="image-20240813160359795"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160514548.png" alt="image-20240813160514548"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160610452.png" alt="image-20240813160610452"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160712299.png" alt="image-20240813160712299"></p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160826607.png" alt="image-20240813160826607"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161005663.png" alt="image-20240813161005663"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161059383.png" alt="image-20240813161059383"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161145597.png" alt="image-20240813161145597"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163521582.png" alt="image-20240813163521582"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163554414.png" alt="image-20240813163554414"></p><h2 id="RIP的基本工作原理"><a href="#RIP的基本工作原理" class="headerlink" title="RIP的基本工作原理"></a>RIP的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163650949.png" alt="image-20240813163650949"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163741435.png" alt="image-20240813163741435"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163821659.png" alt="image-20240813163821659"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164029695.png" alt="image-20240813164029695"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164440827.png" alt="image-20240813164440827"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164515494.png" alt="image-20240813164515494"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164643536.png" alt="image-20240813164643536"></p><h2 id="开放最短路径优先OSPF的基本工作原理"><a href="#开放最短路径优先OSPF的基本工作原理" class="headerlink" title="开放最短路径优先OSPF的基本工作原理"></a>开放最短路径优先OSPF的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813165529224.png" alt="image-20240813165529224"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813165603466.png" alt="image-20240813165603466"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170002116.png" alt="image-20240813170002116"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170058350.png" alt="image-20240813170058350"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170312189.png" alt="image-20240813170312189"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170336748.png" alt="image-20240813170336748"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170417287.png" alt="image-20240813170417287"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170500348.png" alt="image-20240813170500348"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170554159.png" alt="image-20240813170554159"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170723337.png" alt="image-20240813170723337"></p><h2 id="边界网关协议BGP的基本工作原理"><a href="#边界网关协议BGP的基本工作原理" class="headerlink" title="边界网关协议BGP的基本工作原理"></a>边界网关协议BGP的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170812638.png" alt="image-20240813170812638"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170934632.png" alt="image-20240813170934632"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171009427.png" alt="image-20240813171009427"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171036364.png" alt="image-20240813171036364"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171106065.png" alt="image-20240813171106065"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171127832.png" alt="image-20240813171127832"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171307237.png" alt="image-20240813171307237"></p><h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172023580.png" alt="image-20240813172023580"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172329225.png" alt="image-20240813172329225"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172429600.png" alt="image-20240813172429600"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172616881.png" alt="image-20240813172616881"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172636415.png" alt="image-20240813172636415"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172759368.png" alt="image-20240813172759368"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172857248.png" alt="image-20240813172857248"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172925377.png" alt="image-20240813172925377"></p><h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182228362.png" alt="image-20240813182228362"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182303630.png" alt="image-20240813182303630"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182334996.png" alt="image-20240813182334996"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182410662.png" alt="image-20240813182410662"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182419437.png" alt="image-20240813182419437"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182443369.png" alt="image-20240813182443369"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182514899.png" alt="image-20240813182514899"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182536842.png" alt="image-20240813182536842"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182632326.png" alt="image-20240813182632326"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182926421.png" alt="image-20240813182926421"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813183000508.png" alt="image-20240813183000508"></p><h1 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813184743437.png" alt="image-20240813184743437"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813185043444.png" alt="image-20240813185043444"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813185112872.png" alt="image-20240813185112872"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190521871.png" alt="image-20240813190521871"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190622629.png" alt="image-20240813190622629"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190710951.png" alt="image-20240813190710951"></p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190729005.png" alt="image-20240813190729005" style="zoom:67%;"><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190759977.png" alt="image-20240813190759977"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190824343.png" alt="image-20240813190824343"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190847503.png" alt="image-20240813190847503"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200439428.png" alt="image-20240811200439428"></p><p> <img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200621626.png" alt="image-20240811200621626"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200703874.png" alt="image-20240811200703874"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200836633.png" alt="image-20240811200836633"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201003064.png" alt="image-20240811201003064"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201036469.png" alt="image-20240811201036469"></p><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201415193.png" alt="image-20240811201415193"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201646586.png" alt="image-20240811201646586"></p><p>在每5个连续的1后加一个0，确保了帧定界在整个帧中的唯一性（与帧头帧尾区分开）；</p><p>从物理层交付的比特流中提取帧时，将帧的数据部分中的每5个连续的比特1后面的那个比特0剔除即可。</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202150622.png" alt="image-20240811202150622"></p><h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202407835.png" alt="image-20240811202407835"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202520317.png" alt="image-20240811202520317"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203429392.png" alt="image-20240811203429392"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203503802.png" alt="image-20240811203503802"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203557361.png" alt="image-20240811203557361"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203636275.png" alt="image-20240811203636275"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203826087.png" alt="image-20240811203826087"></p><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203946372.png" alt="image-20240811203946372"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204059585.png" alt="image-20240811204059585"></p><h2 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204211275.png" alt="image-20240811204211275"></p><h3 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204345219.png" alt="image-20240811204345219"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204423460.png" alt="image-20240811204423460"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204550832.png" alt="image-20240811204550832"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204642254.png" alt="image-20240811204642254"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205418830.png" alt="image-20240811205418830"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205447010.png" alt="image-20240811205447010"></p><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205755977.png" alt="image-20240811205755977"></p><p><strong>累积确认</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210050686.png" alt="image-20240811210050686"></p><p>优点：即使确认分组丢失，发送方也可能不必重传</p><p>缺点：不能向发送方即使反映接收方已经正确接收的数据分组信息</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210317077.png" alt="image-20240811210317077"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210411671.png" alt="image-20240811210411671"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210503831.png" alt="image-20240811210503831"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210804540.png" alt="image-20240811210804540"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210933593.png" alt="image-20240811210933593"></p><h3 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211033403.png" alt="image-20240811211033403"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211248655.png" alt="image-20240811211248655"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211339656.png" alt="image-20240811211339656"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211448408.png" alt="image-20240811211448408"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211615317.png" alt="image-20240811211615317"></p><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112454069.png" alt="image-20240812112454069"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112554216.png" alt="image-20240812112554216"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112728218.png" alt="image-20240812112728218"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112756706.png" alt="image-20240812112756706"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112949890.png" alt="image-20240812112949890"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113020608.png" alt="image-20240812113020608"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113051032.png" alt="image-20240812113051032"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113144684.png" alt="image-20240812113144684"></p><h1 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h1><h2 id="媒体接入控制的基本概念"><a href="#媒体接入控制的基本概念" class="headerlink" title="媒体接入控制的基本概念"></a>媒体接入控制的基本概念</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113712904.png" alt="image-20240812113712904"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113518653.png" alt="image-20240812113518653"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113659021.png" alt="image-20240812113659021"></p><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120612592.png" alt="image-20240812120612592"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120645749.png" alt="image-20240812120645749"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120710446.png" alt="image-20240812120710446"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120752098.png" alt="image-20240812120752098"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812121837751.png" alt="image-20240812121837751"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122126917.png" alt="image-20240812122126917"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122236376.png" alt="image-20240812122236376"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122359973.png" alt="image-20240812122359973"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122521074.png" alt="image-20240812122521074"></p><h2 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h2><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123741657.png" alt="image-20240812123741657"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123836878.png" alt="image-20240812123836878"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123924519.png" alt="image-20240812123924519"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812124042252.png" alt="image-20240812124042252"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812124203154.png" alt="image-20240812124203154"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131743488.png" alt="image-20240812131743488"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131846382.png" alt="image-20240812131846382"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131933201.png" alt="image-20240812131933201"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131952631.png" alt="image-20240812131952631"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132016992.png" alt="image-20240812132016992"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132336781.png" alt="image-20240812132336781"></p><h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132402876.png" alt="image-20240812132402876"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132436985.png" alt="image-20240812132436985"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132517404.png" alt="image-20240812132517404"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135113752.png" alt="image-20240812135113752"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135154263.png" alt="image-20240812135154263"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135228961.png" alt="image-20240812135228961"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135244375.png" alt="image-20240812135244375"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135309513.png" alt="image-20240812135309513"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135358783.png" alt="image-20240812135358783"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135437234.png" alt="image-20240812135437234"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143203410.png" alt="image-20240812143203410"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143304483.png" alt="image-20240812143304483"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143337676.png" alt="image-20240812143337676"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143442999.png" alt="image-20240812143442999"></p><p><strong>总结</strong>（易混淆知识分析）</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143639019.png" alt="image-20240812143639019"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143709627.png" alt="image-20240812143709627"></p><h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143844676.png" alt="image-20240812143844676"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144054228.png" alt="image-20240812144054228"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143946780.png" alt="image-20240812143946780"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144133180.png" alt="image-20240812144133180"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144244562.png" alt="image-20240812144244562"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144322168.png" alt="image-20240812144322168"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144358817.png" alt="image-20240812144358817"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144422749.png" alt="image-20240812144422749"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144500681.png" alt="image-20240812144500681"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144542722.png" alt="image-20240812144542722"></p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152206920.png" alt="image-20240812152206920"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152333832.png" alt="image-20240812152333832"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152447381.png" alt="image-20240812152447381"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152622576.png" alt="image-20240812152622576"></p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152948508.png" alt="image-20240812152948508"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153013683.png" alt="image-20240812153013683"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152843468.png" alt="image-20240812152843468"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152858247.png" alt="image-20240812152858247"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152931095.png" alt="image-20240812152931095"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153037913.png" alt="image-20240812153037913"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153103104.png" alt="image-20240812153103104"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153124385.png" alt="image-20240812153124385"></p><p><strong>总结</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153240577.png" alt="image-20240812153240577"></p><h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812164411856.png" alt="image-20240812164411856"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812164505986.png" alt="image-20240812164505986"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165249996.png" alt="image-20240812165249996"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165331614.png" alt="image-20240812165331614"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165430951.png" alt="image-20240812165430951"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165618984.png" alt="image-20240812165618984"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165640565.png" alt="image-20240812165640565"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165650394.png" alt="image-20240812165650394"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165723103.png" alt="image-20240812165723103"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165752003.png" alt="image-20240812165752003"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165807890.png" alt="image-20240812165807890"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165820095.png" alt="image-20240812165820095"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165925100.png" alt="image-20240812165925100"></p><h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170011452.png" alt="image-20240812170011452"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170142508.png" alt="image-20240812170142508"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170214302.png" alt="image-20240812170214302"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170246929.png" alt="image-20240812170246929"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170409360.png" alt="image-20240812170409360"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170443461.png" alt="image-20240812170443461"></p><p>因为可能交换机某个接口所连接的主机更换成了另一台主机，也可能主机中的网卡进行了更换。</p><h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171117949.png" alt="image-20240812171117949"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171227456.png" alt="image-20240812171227456"></p><h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171347338.png" alt="image-20240812171347338"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171416017.png" alt="image-20240812171416017"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171441551.png" alt="image-20240812171441551"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171512673.png" alt="image-20240812171512673"></p><p>同一个VLAN内部可以广播通信，不同的VLAN之间不能广播通信</p><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171705352.png" alt="image-20240812171705352"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171747169.png" alt="image-20240812171747169"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171920482.png" alt="image-20240812171920482"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172005866.png" alt="image-20240812172005866"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172148900.png" alt="image-20240812172148900"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172245951.png" alt="image-20240812172245951"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172516159.png" alt="image-20240812172516159"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172556741.png" alt="image-20240812172556741"></p><p><strong>总结</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172623937.png" alt="image-20240812172623937"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143116330.png" alt="image-20240811143116330"></p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143315583.png" alt="image-20240811143315583"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143404201.png" alt="image-20240811143404201"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144124746.png" alt="image-20240811144124746"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144228004.png" alt="image-20240811144228004"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144259077.png" alt="image-20240811144259077"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144354650.png" alt="image-20240811144354650"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144538493.png" alt="image-20240811144538493"></p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144814162.png" alt="image-20240811144814162"></p><p>远距离用串行传输，计算机内部用并行传输</p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811145140938.png" alt="image-20240811145140938"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811145208675.png" alt="image-20240811145208675"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152045479.png" alt="image-20240811152045479"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152254222.png" alt="image-20240811152254222"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152407222.png" alt="image-20240811152407222"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152425853.png" alt="image-20240811152425853"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152528815.png" alt="image-20240811152528815"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152625365.png" alt="image-20240811152625365"></p><p><strong>使用基本调制方法，1个码元只能包含1个比特信息</strong></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152828567.png" alt="image-20240811152828567"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152839088.png" alt="image-20240811152839088"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153017598.png" alt="image-20240811153017598"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153056845.png" alt="image-20240811153056845"></p><p>所以不可以随便定义</p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153202481.png" alt="image-20240811153202481"></p><p><em><strong>格雷码即为任意两个相邻码元只有1个比特不同</strong></em></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811160722538.png" alt="image-20240811160722538"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811160952098.png" alt="image-20240811160952098"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161004415.png" alt="image-20240811161004415"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161410382.png" alt="image-20240811161410382"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161419636.png" alt="image-20240811161419636"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网概述</title>
      <link href="/2024/08/09/%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/09/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204622155.png" alt="image-20240809204622155"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204730835.png" alt="image-20240809204730835"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204807848.png" alt="image-20240809204807848"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204913000.png" alt="image-20240809204913000"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204954611.png" alt="image-20240809204954611"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205034605.png" alt="image-20240809205034605"></p><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205755668.png" alt="image-20240809205755668"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205909024.png" alt="image-20240809205909024"></p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210048654.png" alt="image-20240809210048654"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>与分组交换类似，报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就需要<strong>交换结点需要较大的缓存空间</strong></p><p><em>报文交换现在较少使用，通常被分组交换取代</em></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210437760.png" alt="image-20240809210437760"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210700240.png" alt="image-20240809210700240"></p><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214427402.png" alt="image-20240809214427402"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214650566.png" alt="image-20240809214650566"></p><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214750698.png" alt="image-20240809214750698"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215011750.png" alt="image-20240809215011750"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215126975.png" alt="image-20240809215126975"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215202123.png" alt="image-20240809215202123"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215433390.png" alt="image-20240809215433390"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215600876.png" alt="image-20240809215600876"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215703401.png" alt="image-20240809215703401"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215744290.png" alt="image-20240809215744290"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215852942.png" alt="image-20240809215852942"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215952112.png" alt="image-20240809215952112"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104105708.png" alt="image-20240810104105708"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104251458.png" alt="image-20240810104251458"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104336672.png" alt="image-20240810104336672"></p><h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104510188.png" alt="image-20240810104510188"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104623757.png" alt="image-20240810104623757"></p><p> <img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105439764.png" alt="image-20240810105439764"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105619383.png" alt="image-20240810105619383"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105710059.png" alt="image-20240810105710059"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105742492.png" alt="image-20240810105742492"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105813500.png" alt="image-20240810105813500"></p><h2 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810110913730.png" alt="image-20240810110913730"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810110927133.png" alt="image-20240810110927133"></p><h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111026913.png" alt="image-20240810111026913"></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111105360.png" alt="image-20240810111105360"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111223421.png" alt="image-20240810111223421"></p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111306763.png" alt="image-20240810111306763"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111337180.png" alt="image-20240810111337180"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111421848.png" alt="image-20240810111421848"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制单元</title>
      <link href="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/"/>
      <url>/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="微操作命令分析"><a href="#微操作命令分析" class="headerlink" title="微操作命令分析"></a>微操作命令分析</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728143935656.png" alt="image-20240728143935656"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144052638.png" alt="image-20240728144052638"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144435273.png" alt="image-20240728144435273"></p><p>算术右移时ACC<del>0</del>写回ACC<del>0</del>是为了保存符号位，</p><p>循环左移时ACC<del>0</del>移到ACC<del>n</del></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144559981.png" alt="image-20240728144559981"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728145011998.png" alt="image-20240728145011998"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728145118107.png" alt="image-20240728145118107"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150008671.png" alt="image-20240728150008671"></p><h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150057558.png" alt="image-20240728150057558"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150134150.png" alt="image-20240728150134150"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150226031.png" alt="image-20240728150226031"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150601463.png" alt="image-20240728150601463"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150739209.png" alt="image-20240728150739209"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150940886.png" alt="image-20240728150940886"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151223085.png" alt="image-20240728151223085"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151343865.png" alt="image-20240728151343865"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151444661.png" alt="image-20240728151444661"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151638534.png" alt="image-20240728151638534"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151814993.png" alt="image-20240728151814993"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151849300.png" alt="image-20240728151849300"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153621420.png" alt="image-20240728153621420"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153701666.png" alt="image-20240728153701666"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153823779.png" alt="image-20240728153823779"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153843830.png" alt="image-20240728153843830"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728154019519.png" alt="image-20240728154019519"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728154146349.png" alt="image-20240728154146349"></p><h1 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728155008228.png" alt="image-20240728155008228"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728155033471.png" alt="image-20240728155033471"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161022916.png" alt="image-20240728161022916"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161124560.png" alt="image-20240728161124560"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161358661.png" alt="image-20240728161358661"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161502365.png" alt="image-20240728161502365"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163241675.png" alt="image-20240728163241675"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163353280.png" alt="image-20240728163353280"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163850317.png" alt="image-20240728163850317"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728164547812.png" alt="image-20240728164547812"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165006200.png" alt="image-20240728165006200"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165133820.png" alt="image-20240728165133820"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165057671.png" alt="image-20240728165057671"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165116985.png" alt="image-20240728165116985"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165149854.png" alt="image-20240728165149854"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165208790.png" alt="image-20240728165208790"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165233289.png" alt="image-20240728165233289"></p><h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729111935421.png" alt="image-20240729111935421"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729112551877.png" alt="image-20240729112551877"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729113249236.png" alt="image-20240729113249236"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729113443616.png" alt="image-20240729113443616"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729121233938.png" alt="image-20240729121233938"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729121504957.png" alt="image-20240729121504957"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122231332.png" alt="image-20240729122231332"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122804135.png" alt="image-20240729122804135"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122846828.png" alt="image-20240729122846828"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122952615.png" alt="image-20240729122952615"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132337267.png" alt="image-20240729132337267"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132457898.png" alt="image-20240729132457898"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132552681.png" alt="image-20240729132552681"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132825836.png" alt="image-20240729132825836"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132856283.png" alt="image-20240729132856283"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134504305.png" alt="image-20240729134504305"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134706283.png" alt="image-20240729134706283"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134905248.png" alt="image-20240729134905248"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134942430.png" alt="image-20240729134942430"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140541662.png" alt="image-20240729140541662"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140620497.png" alt="image-20240729140620497"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140703095.png" alt="image-20240729140703095"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140718988.png" alt="image-20240729140718988"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140742245.png" alt="image-20240729140742245"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140752954.png" alt="image-20240729140752954"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140835462.png" alt="image-20240729140835462"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140929205.png" alt="image-20240729140929205"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141131618.png" alt="image-20240729141131618"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141253665.png" alt="image-20240729141253665"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141459809.png" alt="image-20240729141459809"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141506449.png" alt="image-20240729141506449"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU的结构和功能</title>
      <link href="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155039834.png" alt="image-20240727155039834"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155004784.png" alt="image-20240727155004784"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155234559.png" alt="image-20240727155234559"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727161424913.png" alt="image-20240727161424913"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727161515714.png" alt="image-20240727161515714"></p><h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192450699.png" alt="image-20240727192450699"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192654906.png" alt="image-20240727192654906"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192754511.png" alt="image-20240727192754511"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192841629.png" alt="image-20240727192841629">、<img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192959755.png" alt="image-20240727192959755"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193252306.png" alt="image-20240727193252306"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193433446.png" alt="image-20240727193433446"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193600286.png" alt="image-20240727193600286"></p><h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727204609300.png" alt="image-20240727204609300"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727204734640.png" alt="image-20240727204734640"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205128538.png" alt="image-20240727205128538"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205552285.png" alt="image-20240727205552285"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205656676.png" alt="image-20240727205656676"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210031476.png" alt="image-20240727210031476"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210502228.png" alt="image-20240727210502228"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210607754.png" alt="image-20240727210607754"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210651994.png" alt="image-20240727210651994"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194226442.png" alt="image-20240727194226442"></p><p>m*Δt是第一条指令的时间，后面的由于处在流水线上，所以每过Δt的时间完成一条指令</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194302099.png" alt="image-20240727194302099"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194334798.png" alt="image-20240727194334798"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194406081.png" alt="image-20240727194406081"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194832505.png" alt="image-20240727194832505"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194959746.png" alt="image-20240727194959746"></p><p>每个大段之间需要锁存，但是一个大段中分成若干小段时不需要锁存</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195220532.png" alt="image-20240727195220532"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195358737.png" alt="image-20240727195358737"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195458528.png" alt="image-20240727195458528"></p><p>如果不一致，则会按照操作时间最长的那个功能段去计算时钟长度，会降低整个流水线的速度。</p><h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210808750.png" alt="image-20240727210808750"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210843551.png" alt="image-20240727210843551"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211215465.png" alt="image-20240727211215465"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211603986.png" alt="image-20240727211603986"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211700830.png" alt="image-20240727211700830"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211943545.png" alt="image-20240727211943545"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727212044141.png" alt="image-20240727212044141"></p><p>软件方法更灵活，易于修改。</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727212207151.png" alt="image-20240727212207151"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727214854359.png" alt="image-20240727214854359"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215028038.png" alt="image-20240727215028038"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215058242.png" alt="image-20240727215058242"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215214614.png" alt="image-20240727215214614"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215444290.png" alt="image-20240727215444290"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215628886.png" alt="image-20240727215628886"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215716924.png" alt="image-20240727215716924"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220007165.png" alt="image-20240727220007165"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220041529.png" alt="image-20240727220041529"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220149300.png" alt="image-20240727220149300"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220323831.png" alt="image-20240727220323831"></p><p>JMP前恢复中断屏蔽字</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727104919686.png" alt="image-20240727104919686"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727105438047.png" alt="image-20240727105438047"></p><p> <img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727105854476.png" alt="image-20240727105854476"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727110538897.png" alt="image-20240727110538897"></p><p>4次访存：取指令、取A1、取A2、取A3保存结果</p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727110745461.png" alt="image-20240727110745461"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727111008111.png" alt="image-20240727111008111"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727111305161.png" alt="image-20240727111305161"></p><h1 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727112059684.png" alt="image-20240727112059684"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727112857536.png" alt="image-20240727112857536"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727113031672.png" alt="image-20240727113031672"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727113246050.png" alt="image-20240727113246050"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114454027.png" alt="image-20240727114454027"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114554952.png" alt="image-20240727114554952"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114817918.png" alt="image-20240727114817918"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115143391.png" alt="image-20240727115143391"></p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115505511.png" alt="image-20240727115505511"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115619437.png" alt="image-20240727115619437"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121352980.png" alt="image-20240727121352980"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121517105.png" alt="image-20240727121517105"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121629398.png" alt="image-20240727121629398"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121903296.png" alt="image-20240727121903296"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121944337.png" alt="image-20240727121944337"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122119494.png" alt="image-20240727122119494"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122204182.png" alt="image-20240727122204182"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122315754.png" alt="image-20240727122315754"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122352206.png" alt="image-20240727122352206"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122506060.png" alt="image-20240727122506060"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133208801.png" alt="image-20240727133208801"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133344069.png" alt="image-20240727133344069"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133438537.png" alt="image-20240727133438537"></p><p>所以位移量为06H</p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133742279.png" alt="image-20240727133742279"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133914748.png" alt="image-20240727133914748"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133935985.png" alt="image-20240727133935985"></p><h1 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134216251.png" alt="image-20240727134216251"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134424726.png" alt="image-20240727134424726"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134512040.png" alt="image-20240727134512040"></p><h1 id="RISC技术"><a href="#RISC技术" class="headerlink" title="RISC技术"></a>RISC技术</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134617159.png" alt="image-20240727134617159"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134726862.png" alt="image-20240727134726862"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134841983.png" alt="image-20240727134841983"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134921942.png" alt="image-20240727134921942"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机的运算方法</title>
      <link href="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084120453.png" alt="image-20240726084120453"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084202561.png" alt="image-20240726084202561"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084417594.png" alt="image-20240726084417594"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084706913.png" alt="image-20240726084706913"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100354359.png" alt="image-20240726100354359"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100616479.png" alt="image-20240726100616479"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100740554.png" alt="image-20240726100740554"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726101104461.png" alt="image-20240726101104461"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726103716497-17219614367821.png" alt="image-20240726103716497"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104026869.png" alt="image-20240726104026869"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104340275.png" alt="image-20240726104340275"></p><p><strong>求补码的快捷方式：当真值为负时，补码可用原码除符号位保持不变外，其余每位取反，末位加1求得。</strong></p><p><em>联系：</em></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104949978.png" alt="image-20240726104949978"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110622175.png" alt="image-20240726110622175"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110650415.png" alt="image-20240726110650415"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110810847.png" alt="image-20240726110810847"></p><p>如何从y的补码获得-y的补码？</p><p>将y中连同符号位的每一位取反，最后+1，即为-y的补码。</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111250181.png" alt="image-20240726111250181"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111411874.png" alt="image-20240726111411874"></p><p>移码定义中只给出了整数形式的定义，没有小数形式的定义。</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111602966.png" alt="image-20240726111602966"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111951746.png" alt="image-20240726111951746"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726112044955.png" alt="image-20240726112044955"></p><h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726112406221.png" alt="image-20240726112406221"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726113008038.png" alt="image-20240726113008038"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726113207558.png" alt="image-20240726113207558"></p><p>S是小于1的小数</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115202560.png" alt="image-20240726115202560"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115611019.png" alt="image-20240726115611019"></p><p><em>用有限的数据表示无限多的实数</em></p><p>阶码上溢时按出错处理</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115813887.png" alt="image-20240726115813887"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121313483.png" alt="image-20240726121313483"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121633506.png" alt="image-20240726121633506"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121907893.png" alt="image-20240726121907893"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726130313902.png" alt="image-20240726130313902"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726130622716.png" alt="image-20240726130622716"></p><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726131848646.png" alt="image-20240726131848646"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726132042314.png" alt="image-20240726132042314"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726144626746-17219763874883.png" alt="image-20240726144626746"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726144842232.png" alt="image-20240726144842232"></p><h2 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726145221455.png" alt="image-20240726145221455"></p><p><strong>溢出</strong></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726145801608-17219770818405.png" alt="image-20240726145801608"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726155645240.png" alt="image-20240726155645240"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726155825787.png" alt="image-20240726155825787"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160029431.png" alt="image-20240726160029431"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160151861.png" alt="image-20240726160151861"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160420485.png" alt="image-20240726160420485"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160642497.png" alt="image-20240726160642497"></p><p>3个寄存器：1个存被乘数，该寄存器不需要移位功能；另外两个一个先存乘数，后存结果的低位，另一个存结果的高位，这两个寄存器需要具有移位功能。</p><p>需要n+1位的全加器，而不是2*n+1位，因为只与高位相加</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161044929.png" alt="image-20240726161044929"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161216633.png" alt="image-20240726161216633"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161352775.png" alt="image-20240726161352775"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161450815.png" alt="image-20240726161450815"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161931927.png" alt="image-20240726161931927"></p><p>当前最后一位是1时，控制门打开，进行累加和右移；如果是0，送入0相加或者直接右移。</p><p>其中G<del>M</del>是乘法标志，S是符号位。</p><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163415540.png" alt="image-20240726163415540"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163549474.png" alt="image-20240726163549474"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163721714.png" alt="image-20240726163721714"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165052679.png" alt="image-20240726165052679"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165346644.png" alt="image-20240726165346644"></p><p><strong>如果第一次上商为1，则表示溢出</strong></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165953615.png" alt="image-20240726165953615"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170115295.png" alt="image-20240726170115295"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170343860.png" alt="image-20240726170343860"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170718668.png" alt="image-20240726170718668"></p><p>其中G<del>D</del>是除法标志，S是符号位，V表示是否发生溢出</p><h1 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726171132967.png" alt="image-20240726171132967"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726171329355.png" alt="image-20240726171329355"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726172246707.png" alt="image-20240726172246707"></p><p>主要根据<strong>第二条</strong>，看<strong>补码</strong>来判断</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726172411867.png" alt="image-20240726172411867"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726182921475.png" alt="image-20240726182921475"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726183121695.png" alt="image-20240726183121695"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726184655074.png" alt="image-20240726184655074"></p><p>如果发生下溢，则可以当作0处理；如果发生上溢，说明出错</p><h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726184938015.png" alt="image-20240726184938015"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726185752403.png" alt="image-20240726185752403"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726185926765.png" alt="image-20240726185926765"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190058550.png" alt="image-20240726190058550"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190232027.png" alt="image-20240726190232027"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190340273-17219918213137.png" alt="image-20240726190340273"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190648289.png" alt="image-20240726190648289"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190721252.png" alt="image-20240726190721252"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190813806.png" alt="image-20240726190813806"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726191320963.png" alt="image-20240726191320963"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726191223657.png" alt="image-20240726191223657"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出系统</title>
      <link href="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725151150308.png" alt="image-20240725151150308"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725151541579.png" alt="image-20240725151541579"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725152923581.png" alt="image-20240725152923581"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153101841.png" alt="image-20240725153101841"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153228627.png" alt="image-20240725153228627"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153520694.png" alt="image-20240725153520694"></p><p>CPU在原地等待I&#x2F;O，利用率低</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153829377.png" alt="image-20240725153829377"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153959012.png" alt="image-20240725153959012"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154533403.png" alt="image-20240725154533403"></p><p>在周期挪用期间，CPU不能访问主存，不能使用总线，但是可以进行缓存中的程序</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154816784.png" alt="image-20240725154816784"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154922419.png" alt="image-20240725154922419"></p><h1 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h1><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155152727.png" alt="image-20240725155152727"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155346845.png" alt="image-20240725155346845"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155452879.png" alt="image-20240725155452879"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155729064.png" alt="image-20240725155729064"></p><p>A指模拟信号，D指数字信号（计算机识别数字信号）</p><h1 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160014257.png" alt="image-20240725160014257"></p><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160134010.png" alt="image-20240725160134010"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160415218.png" alt="image-20240725160415218"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160610352.png" alt="image-20240725160610352"></p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160804803.png" alt="image-20240725160804803"></p><p>程序查询方式不需要接口进行控制</p><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725162650407.png" alt="image-20240725162650407"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725162900109.png" alt="image-20240725162900109"></p><h2 id="接口电路"><a href="#接口电路" class="headerlink" title="接口电路"></a>接口电路</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725163105166.png" alt="image-20240725163105166"></p><p>先是D为0，B为1，来启动设备，开始数据准备；准备好后，设备工作结束，将D改为1，B改为0，来接收数据。在此过程中 CPU原地踏步等待，不断循环查看。</p><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170626134.png" alt="image-20240725170626134"></p><h2 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I&#x2F;O中断的产生"></a>I&#x2F;O中断的产生</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170722412.png" alt="image-20240725170722412"></p><h2 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170920256.png" alt="image-20240725170920256"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725171133983.png" alt="image-20240725171133983"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725171421661.png" alt="image-20240725171421661"></p><p>紫色为低电平，黄色为高电平</p><p>上图中INTR2有请求，通过与非门和非门屏蔽了优先级比他低的请求，最终只有INTP2是高电平，由此筛选出了中断请求优先级最高的中断源。</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725172147493.png" alt="image-20240725172147493"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725172327266.png" alt="image-20240725172327266"></p><h2 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I&#x2F;O中断处理过程"></a>I&#x2F;O中断处理过程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725180833908.png" alt="image-20240725180833908"></p><h2 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725181423207.png" alt="image-20240725181423207"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193302659.png" alt="image-20240725193302659"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193448717.png" alt="image-20240725193448717"></p><h1 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h1><h2 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193819214.png" alt="image-20240725193819214"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194441311.png" alt="image-20240725194441311"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194648757.png" alt="image-20240725194648757"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194736394.png" alt="image-20240725194736394"></p><h2 id="DMA接口的功能和组成"><a href="#DMA接口的功能和组成" class="headerlink" title="DMA接口的功能和组成"></a>DMA接口的功能和组成</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194852625.png" alt="image-20240725194852625"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195220292.png" alt="image-20240725195220292"></p><h2 id="DMA的工作过程"><a href="#DMA的工作过程" class="headerlink" title="DMA的工作过程"></a>DMA的工作过程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195303647.png" alt="image-20240725195303647"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195513527.png" alt="image-20240725195513527"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195652131.png" alt="image-20240725195652131"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195801637.png" alt="image-20240725195801637"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195846382.png" alt="image-20240725195846382"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195959192.png" alt="image-20240725195959192"></p><p>越靠近CPU，DMA接口的优先级越高</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200046533.png" alt="image-20240725200046533"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200211175.png" alt="image-20240725200211175"></p><p><em>由于DMA方式是内存和外设之间直接进行数据交换，通常连接高速设备，所以DMA方式在I&#x2F;O和内存进行数据传输的模式下优先级更高。</em></p><h2 id="DMA接口的类型"><a href="#DMA接口的类型" class="headerlink" title="DMA接口的类型"></a>DMA接口的类型</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200525683.png" alt="image-20240725200525683"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200626870.png" alt="image-20240725200626870"></p><p>多路型允许多个设备同时准备，同时进行缓冲，但是每次只能处理一个请求。</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200835974.png" alt="image-20240725200835974"></p><p><em>（本题中假设每个DMA请求处理时间为5微秒，磁盘的DMA请求时间间隔为30微秒，磁带为45微秒，打印机为150微秒）</em></p><p><strong>速度越快的优先级越高，所以磁盘和磁带同时出现时，选择处理磁盘。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130008946.png" alt="image-20240724130008946"></p><p>其中（1）是易失的，另外三个是非易失的</p><p>主要相当于是三种：第一种是半导体存储器，利用0和1代表低电平和高电平；第二种是磁表面存储器，利用磁头读出与写入；第三种是光盘存储器，利用光烧制。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130627988.png" alt="image-20240724130627988"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130804075.png" alt="image-20240724130804075"></p><p>RAM即随机存储器，ROM即只读存储器</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724131046942.png" alt="image-20240724131046942"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724131724189.png" alt="image-20240724131724189"></p><p>缓存和主存用硬件连接成一个整体，主要解决速度问题；</p><p>主存和辅存用软硬件结合的方式连接成一个整体，主要解决容量问题。</p><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724134958736.png" alt="image-20240724134958736"></p><h3 id="主存与CPU之间的联系"><a href="#主存与CPU之间的联系" class="headerlink" title="主存与CPU之间的联系"></a>主存与CPU之间的联系</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135035979.png" alt="image-20240724135035979"></p><h3 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135610942.png" alt="image-20240724135610942"></p><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135750674.png" alt="image-20240724135750674"></p><h2 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135946685.png" alt="image-20240724135946685"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140423555.png" alt="image-20240724140423555"></p><p><strong>片选线</strong>：芯片选择信号，指出操作给出的地址是不是针对存储芯片的地址，被选择的字节是否在芯片中</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140705474.png" alt="image-20240724140705474"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140927773.png" alt="image-20240724140927773"></p><p>片选线让某一个芯片或某一组芯片开始工作。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724141425701.png" alt="image-20240724141425701"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724141621082.png" alt="image-20240724141621082"></p><h2 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h2><h3 id="静态RAM（SRAM）"><a href="#静态RAM（SRAM）" class="headerlink" title="静态RAM（SRAM）"></a>静态RAM（SRAM）</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142057829.png" alt="image-20240724142057829"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142209154.png" alt="image-20240724142209154"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142310937.png" alt="image-20240724142310937"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142559957.png" alt="image-20240724142559957"></p><p>WE是读写控制信号（低电平为写，高电平为读）</p><p>CS是片选信号，只有是低电平时芯片才会被选中</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142916821.png" alt="image-20240724142916821"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142936211.png" alt="image-20240724142936211"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724143159555.png" alt="image-20240724143159555"></p><h3 id="动态RAM（DRAM）"><a href="#动态RAM（DRAM）" class="headerlink" title="动态RAM（DRAM）"></a>动态RAM（DRAM）</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152738563.png" alt="image-20240724152738563"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152852273.png" alt="image-20240724152852273"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152923180.png" alt="image-20240724152923180"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153210832.png" alt="image-20240724153210832"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153415213.png" alt="image-20240724153415213"></p><p>若读放大器一侧为0，则经过后另一侧变为1（即变成相反），所以读出与原存信息相反</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153704527.png" alt="image-20240724153704527"></p><p>读出的时候做一次反向，写入的时候再做一次反向，所以写入与输入信息相同</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154143543.png" alt="image-20240724154143543"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154240944.png" alt="image-20240724154240944"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154327146.png" alt="image-20240724154327146"></p><h3 id="动态RAM和静态RAM的比较"><a href="#动态RAM和静态RAM的比较" class="headerlink" title="动态RAM和静态RAM的比较"></a>动态RAM和静态RAM的比较</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154509275.png" alt="image-20240724154509275"></p><h2 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154842683.png" alt="image-20240724154842683"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154957288.png" alt="image-20240724154957288"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724155100219.png" alt="image-20240724155100219"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724155202935.png" alt="image-20240724155202935"></p><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><h3 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724160535401.png" alt="image-20240724160535401"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724161026746.png" alt="image-20240724161026746"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724161158499.png" alt="image-20240724161158499"></p><h3 id="存储器与CPU的连接-1"><a href="#存储器与CPU的连接-1" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724162452972.png" alt="image-20240724162452972"></p><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724164242922.png" alt="image-20240724164242922"></p><p><em>由于百分之90出现的错误是1位错，所以默认为1位错</em>，即3中110默认为111出现1位错，而不是000出现2位错</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724164449657.png" alt="image-20240724164449657"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165623211.png" alt="image-20240724165623211"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165633635.png" alt="image-20240724165633635"></p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165927090.png" alt="image-20240724165927090" style="zoom: 80%;"><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170058283.png" alt="image-20240724170058283"></p><p>默认为偶校验</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170228664.png" alt="image-20240724170228664"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170346358.png" alt="image-20240724170346358"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170416112.png" alt="image-20240724170416112"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170613128.png" alt="image-20240724170613128"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170659444.png" alt="image-20240724170659444"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170731656.png" alt="image-20240724170731656"></p><h2 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171235754.png" alt="image-20240724171235754"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171400441.png" alt="image-20240724171400441"></p><p>由于顺序存储，会出现某个存储体非常忙，其余的存储体非常闲的问题。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171534349.png" alt="image-20240724171534349"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171729335.png" alt="image-20240724171729335"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171746395.png" alt="image-20240724171746395"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171842408.png" alt="image-20240724171842408"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171939659.png" alt="image-20240724171939659"></p><p>高位交叉主要应用于存储器容量的扩展，低位交叉用于存储器带宽和访问速度的提高</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724172234056.png" alt="image-20240724172234056"></p><h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185159497.png" alt="image-20240724185159497"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185329009.png" alt="image-20240724185329009"></p><p>主存和缓存<strong>按块存储</strong>，块的大小相同，B为块长</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185549270.png" alt="image-20240724185549270"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724190133649.png" alt="image-20240724190133649"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724193621766.png" alt="image-20240724193621766"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194134440.png" alt="image-20240724194134440"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194223818.png" alt="image-20240724194223818"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194521303.png" alt="image-20240724194521303"></p><p>写直达法的缺点：容易出现对同一个块频繁操作，而其他块不改变（例如累加操作）</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194748797.png" alt="image-20240724194748797"></p><p>分立缓存是将指令Cache和数据Cache区分开</p><h2 id="Cache—主存的地址映射"><a href="#Cache—主存的地址映射" class="headerlink" title="Cache—主存的地址映射"></a>Cache—主存的地址映射</h2><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195222352.png" alt="image-20240724195222352"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195455972.png" alt="image-20240724195455972"></p><p>优点：结构简单，速度快</p><p>缺点：利用率可能很低；调入时冲突概率大；不灵活</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195628998.png" alt="image-20240724195628998"></p><p>优点：利用率高</p><p>缺点：成本高；速度较低</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195806223.png" alt="image-20240724195806223"></p><p>即 i &#x3D; j mod Q，是直接映射和全相联映射的结合</p><p><strong>越靠近CPU的Cache对于速度要求越高，所以使用直接映射或者路数较少的组相联映射；中间的Cache使用组相联映射；距离CPU最远的对于利用率的要求较高，使用全相联映射。</strong></p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200452563.png" alt="image-20240724200452563"></p><h1 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200805304.png" alt="image-20240724200805304"></p><h3 id="磁记录原理"><a href="#磁记录原理" class="headerlink" title="磁记录原理"></a>磁记录原理</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200836851.png" alt="image-20240724200836851"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200902692.png" alt="image-20240724200902692"></p><h3 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201003297.png" alt="image-20240724201003297"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201057621.png" alt="image-20240724201057621"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201136280.png" alt="image-20240724201136280"></p><h3 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201247862.png" alt="image-20240724201247862"></p><p><em>软盘已经被淘汰</em></p><h3 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201448868.png" alt="image-20240724201448868"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/2024/07/23/%E6%80%BB%E7%BA%BF/"/>
      <url>/2024/07/23/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723154906559.png" alt="image-20240723154906559"></p><p>并行传输容易出错，所以一般距离较短</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155030862.png" alt="image-20240723155030862"></p><p>缺点：当主存和I&#x2F;O进行信息传输时，CPU不能运行</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155109089.png" alt="image-20240723155109089"></p><p>缺点：主存和I&#x2F;O不能直接进行信息传输，需要打断CPU的执行程序的任务</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155345605.png" alt="image-20240723155345605"></p><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163707908.png" alt="image-20240723163707908"></p><p><em>有出（CPU向外送的）：存储器读、存储器写，总线允许，中断确认</em></p><p><em>有入（由I&#x2F;O端口送给CPU）：中断请求、总线请求</em></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163755736.png" alt="image-20240723163755736"></p><h1 id="总线性能及性能指标"><a href="#总线性能及性能指标" class="headerlink" title="总线性能及性能指标"></a>总线性能及性能指标</h1><h2 id="总线物理实现"><a href="#总线物理实现" class="headerlink" title="总线物理实现"></a>总线物理实现</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163914464.png" alt="image-20240723163914464"></p><h2 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164014962.png" alt="image-20240723164014962"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164307600.png" alt="image-20240723164307600"></p><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164525560.png" alt="image-20240723164525560"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164549247.png" alt="image-20240723164549247"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164642430.png" alt="image-20240723164642430"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164725208.png" alt="image-20240723164725208"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164953962.png" alt="image-20240723164953962"></p><p>把高速设备和低速设备区分开，高速设备用高速总线进行组织，低速设备用扩展总线进行组织，使数据传输速率更高。</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165229027-172172475133729.png" alt="image-20240723165229027"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165244264.png" alt="image-20240723165244264"></p><p>同样区分了高速设备和低速设备（VL-BUS连接高速，ISA、EISA连接低速）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165326175.png" alt="image-20240723165326175"></p><p>（PCI总线连接高速，ISA、EISA连接低速）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165446833.png" alt="image-20240723165446833"></p><p>通过桥电路实现了总线的驱动能力的提高和总线的扩展</p><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723170550512.png" alt="image-20240723170550512"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723170641001.png" alt="image-20240723170641001"></p><p>BG的连接顺序就是I&#x2F;O接口的优先级顺序</p><p>优点：结构简单，增删设备容易，容易实现可靠性设计（比如增加一条BR线，防止出现问题）</p><p>缺点：某一处出现故障，信号无法继续向后传，后面的接口无法获得总线的使用权，所以对电路故障非常敏感</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723171754067.png" alt="image-20240723171754067"></p><p>优点：优先级灵活（可以通过计数器来控制优先级）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723172120313.png" alt="image-20240723172120313"></p><p>优点：优先级灵活（可以通过排队器的设置来控制优先级）</p><p>缺点：需要的线数比较多</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195012084.png" alt="image-20240723195012084"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195051085.png" alt="image-20240723195051085"></p><p>​                                                                 潜力</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195311877.png" alt="image-20240723195311877"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195448675.png" alt="image-20240723195448675"></p><p>同步式适用于总线长度较短，而且各个模块存取时间比较一致的情况</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723210631881.png" alt="image-20240723210631881"></p><p>不互锁：主设备发出请求后一段时间后即使没有收到应答信号也会撤销信号，从设备发出应答信号后一段时间后即使没有收到撤销信号也会撤销应答信号</p><p>半互锁：主设备发出信号后一直等到收到应答信号才会撤回信号，从设备发出应答信号后一段时间后即使没有收到撤销信号也会撤销应答信号</p><p>全互锁：主设备发出请求后直到收到应答信号才会撤销信号，从设备发出应答信号后直到收到撤销信号才会撤销应答信号</p><p><strong>异步通信可以完成可靠的数据传输</strong></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723210809190.png" alt="image-20240723210809190"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211040400.png" alt="image-20240723211040400"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211207579.png" alt="image-20240723211207579"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211249924.png" alt="image-20240723211249924"></p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211501971.png" alt="image-20240723211501971"><p>所有的模块都可以从从模块可以变成主模块</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211750657.png" alt="image-20240723211750657"></p><p>总线被占用时一定在进行数据通信或者在传输控制命令，<strong>充分利用了总线的带宽</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论</title>
      <link href="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220609924.png" alt="image-20240719220609924"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220810332.png" alt="image-20240719220810332"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220853358.png" alt="image-20240719220853358"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221014409.png" alt="image-20240719221014409"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221250112.png" alt="image-20240719221250112"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221519835.png" alt="image-20240719221519835"></p><p>中间的虚线完成了计算机系统当中软硬件功能的划分，也提供了软硬件的接口</p><p><em><strong>计算机组成与计算机体系结构从研究内容上来说有什么区别呢？</strong></em></p><p>计算机系统结构定义了计算机系统的软硬件的交界面，定义了哪些功能由软件实现，哪些功能由硬件实现，提供了上层软件进行编写的时候与硬件进行交互的接口。</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719222122165.png" alt="image-20240719222122165"></p><h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120255259.png" alt="image-20240723120255259"></p><p><strong>五大部件：运算器，控制器，寄存器，输入设备，输出设备</strong></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120736894.png" alt="image-20240723120736894"></p><p>（黑色的实线表示数据通路，虚线表示控制和状态反馈）</p><p>运算器：算术运算，逻辑运算</p><p>存储器：存放数据和程序</p><p>控制器：指挥程序运行</p><p>输入设备：将信息转换成机器能识别的形式</p><p>输出设备：将结果转换成人们熟悉的形式</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120912424.png" alt="image-20240723120912424"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120957365.png" alt="image-20240723120957365"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121200198.png" alt="image-20240723121200198"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121735627.png" alt="image-20240723121735627"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121747826.png" alt="image-20240723121747826"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121818404.png" alt="image-20240723121818404"></p><p>由上图可见，指令和数据都是保存在存储器中</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723122158051.png" alt="image-20240723122158051"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723122338179.png" alt="image-20240723122338179"></p><p>对于存储器的读出和写入需要用到MAR和MDR</p><p>上图中MAR为4位，则这4位可以从0000到1111，一共保存了16个地址，也就是存储体中一共有16个存储单元；MDR存储了数据，由于数据和地址的长度相同，所以也反映了存储的字长。</p><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723134957723.png" alt="image-20240723134957723"></p><p>在乘法运算时位数变成原先的两倍，所以需要MQ来存储</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135056105.png" alt="image-20240723135056105"></p><p>M给出了加数的<strong>地址</strong></p><p>需要把内存单元M中的内容取出来放入X寄存器中（即[M]—&gt;X）</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135309833.png" alt="image-20240723135309833"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135502874.png" alt="image-20240723135502874"></p><p><strong>控制器</strong>决定进行哪个操作的先后顺序，并且控制传送到哪个寄存器</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135752674.png" alt="image-20240723135752674"></p><p><em>MQ寄存器只在乘除法使用，所以又叫乘商寄存器</em></p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p><strong>功能</strong>：解释指令</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140219058.png" alt="image-20240723140219058"></p><h2 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h2><p>以取数指令为例</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140617030.png" alt="image-20240723140617030"></p><p>以存数指令为例</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140747841.png" alt="image-20240723140747841"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723141141959.png" alt="image-20240723141141959"></p><p>OP(IR)表示IR中存的指令的操作码；Ad(IR)表示IR中存的指令的地址码</p><h1 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723152035059.png" alt="image-20240723152035059"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723152950211.png" alt="image-20240723152950211"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h1><h2 id="概念与功能"><a href="#概念与功能" class="headerlink" title="概念与功能"></a>概念与功能</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423194707226.png" alt="image-20240423194707226"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423194841887.png" alt="image-20240423194841887"></p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195117102.png" alt="image-20240423195117102"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195216394.png" alt="image-20240423195216394"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195332150.png" alt="image-20240423195332150"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423201906314.png" alt="image-20240423201906314"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202038794.png" alt="image-20240423202038794"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202117687.png" alt="image-20240423202117687"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202324881.png" alt="image-20240423202324881"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202332741.png" alt="image-20240423202332741"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202549561.png" alt="image-20240423202549561"> </p><p>没有并发和共享，就没有虚拟和异步，所以并发和共享是两个最基本的特征。</p><h2 id="发展与分类"><a href="#发展与分类" class="headerlink" title="发展与分类"></a>发展与分类</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202902770.png" alt="image-20240423202902770"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203035194.png" alt="image-20240423203035194"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203120921.png" alt="image-20240423203120921"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203212927.png" alt="image-20240423203212927"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203302552.png" alt="image-20240423203302552"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203337113.png" alt="image-20240423203337113"></p><h1 id="操作系统的运行"><a href="#操作系统的运行" class="headerlink" title="操作系统的运行"></a>操作系统的运行</h1><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161413293.png" alt="image-20240424161413293"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161608749.png" alt="image-20240424161608749"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161646947.png" alt="image-20240424161646947"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161730273.png" alt="image-20240424161730273"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161925701.png" alt="image-20240424161925701"></p><p>内中断的例子：</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162131100.png" alt="image-20240424162131100"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162100314.png" alt="image-20240424162100314"></p><p>外中断的例子：</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162342891.png" alt="image-20240424162342891"></p><p>（每一条指令执行结束时，CPU都会例行检查是否有外中断信号）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162648223.png" alt="image-20240424162648223"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162732505.png" alt="image-20240424162732505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162750550.png" alt="image-20240424162750550"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163016612.png" alt="image-20240424163016612"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163133166.png" alt="image-20240424163133166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163227764.png" alt="image-20240424163227764"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163248719.png" alt="image-20240424163248719"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163517853.png" alt="image-20240424163517853"></p><p> <img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163556825.png" alt="image-20240424163556825"></p><h1 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172527821.png" alt="image-20240424172527821"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172556390.png" alt="image-20240424172556390"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172624554.png" alt="image-20240424172624554"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172747625.png" alt="image-20240424172747625"></p><p>（“变态”即CPU状态的转换）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172849193.png" alt="image-20240424172849193"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424173308508.png" alt="image-20240424173308508"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424174249792.png" alt="image-20240424174249792"></p><h1 id="操作系统的引导"><a href="#操作系统的引导" class="headerlink" title="操作系统的引导"></a>操作系统的引导</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424175832327.png" alt="image-20240424175832327"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424175920257.png" alt="image-20240424175920257"></p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424180221509.png" alt="image-20240424180221509"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424180529570.png" alt="image-20240424180529570"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425194050907.png" alt="image-20240425194050907"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425194501549.png" alt="image-20240425194501549"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425195833490.png" alt="image-20240425195833490"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425195950949.png" alt="image-20240425195950949"></p><p>更确切的说，应该是“进程实体（进程映像）的组成”</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202052767.png" alt="image-20240425202052767"></p><p>进程实体反应了进程在某一时刻的状态</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202251316.png" alt="image-20240425202251316"></p><p>（一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202536005.png" alt="image-20240425202536005"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202624628.png" alt="image-20240425202624628"></p><h2 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203158683.png" alt="image-20240425203158683"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203232076.png" alt="image-20240425203232076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203258368.png" alt="image-20240425203258368"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203341916.png" alt="image-20240425203341916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203616442.png" alt="image-20240425203616442"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203659892.png" alt="image-20240425203659892"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203729200.png" alt="image-20240425203729200"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203752369.png" alt="image-20240425203752369"></p><p>大多数使用链式方式</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203824211.png" alt="image-20240425203824211"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203843154.png" alt="image-20240425203843154"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204014861.png" alt="image-20240425204014861"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204142396.png" alt="image-20240425204142396"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204307182.png" alt="image-20240425204307182"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204414430.png" alt="image-20240425204414430"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204556522.png" alt="image-20240425204556522"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204644915.png" alt="image-20240425204644915"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205119950.png" alt="image-20240425205119950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204958551.png" alt="image-20240425204958551"></p><p>这样，当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205209183.png" alt="image-20240425205209183"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205526858.png" alt="image-20240425205526858"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205616344.png" alt="image-20240425205616344"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205743656.png" alt="image-20240425205743656"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205842141.png" alt="image-20240425205842141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205929221.png" alt="image-20240425205929221"></p><p> <img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210208090.png" alt="image-20240425210208090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210314279.png" alt="image-20240425210314279"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210729504.png" alt="image-20240425210729504"></p><p>先进先出（FIFO）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425211023890.png" alt="image-20240425211023890"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425211103113.png" alt="image-20240425211103113"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425212924612.png" alt="image-20240425212924612"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213012953.png" alt="image-20240425213012953"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213022270.png" alt="image-20240425213022270"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213504551.png" alt="image-20240425213504551"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213554685.png" alt="image-20240425213554685"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213745128.png" alt="image-20240425213745128"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213829589.png" alt="image-20240425213829589"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213923083.png" alt="image-20240425213923083"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214004512.png" alt="image-20240425214004512"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214042850.png" alt="image-20240425214042850"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214107952.png" alt="image-20240425214107952"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214252434.png" alt="image-20240425214252434"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214347873.png" alt="image-20240425214347873"></p><h2 id="状态与转换-1"><a href="#状态与转换-1" class="headerlink" title="状态与转换"></a>状态与转换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214516442.png" alt="image-20240425214516442"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214903060.png" alt="image-20240425214903060"></p><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="概念，层次"><a href="#概念，层次" class="headerlink" title="概念，层次"></a>概念，层次</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171438969.png" alt="image-20240426171438969"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171526532.png" alt="image-20240426171526532"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171612978.png" alt="image-20240426171612978"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171752119.png" alt="image-20240426171752119"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172310673.png" alt="image-20240426172310673"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172436227.png" alt="image-20240426172436227"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172751011.png" alt="image-20240426172751011"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172848352.png" alt="image-20240426172848352"></p><h2 id="进程调度的时机，切换与方式"><a href="#进程调度的时机，切换与方式" class="headerlink" title="进程调度的时机，切换与方式"></a>进程调度的时机，切换与方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426183054466.png" alt="image-20240426183054466"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426212516479.png" alt="image-20240426212516479"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426212715032.png" alt="image-20240426212715032"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215459885.png" alt="image-20240426215459885"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215508243.png" alt="image-20240426215508243"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215649600.png" alt="image-20240426215649600"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215759025.png" alt="image-20240426215759025"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215814790.png" alt="image-20240426215814790"></p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220036114.png" alt="image-20240426220036114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220048941.png" alt="image-20240426220048941"></p><h2 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220117897.png" alt="image-20240426220117897"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220251731.png" alt="image-20240426220251731"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220315202.png" alt="image-20240426220315202"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220403033.png" alt="image-20240426220403033"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220508876.png" alt="image-20240426220508876"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220623795.png" alt="image-20240426220623795"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220637861.png" alt="image-20240426220637861"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220647090.png" alt="image-20240426220647090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220746537.png" alt="image-20240426220746537"></p><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221105498.png" alt="image-20240426221105498"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221005368.png" alt="image-20240426221005368"></p><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221633075.png" alt="image-20240426221633075"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221227911.png" alt="image-20240426221227911"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221355660.png" alt="image-20240426221355660"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221426472.png" alt="image-20240426221426472"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221552888.png" alt="image-20240426221552888"></p><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221942370.png" alt="image-20240426221942370"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221907145.png" alt="image-20240426221907145"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222017800.png" alt="image-20240426222017800"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222310955.png" alt="image-20240426222310955"></p><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223150381.png" alt="image-20240426223150381"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222701916.png" alt="image-20240426222701916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222740205.png" alt="image-20240426222740205"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222754522.png" alt="image-20240426222754522"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222840849.png" alt="image-20240426222840849"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222922006.png" alt="image-20240426222922006"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223043674.png" alt="image-20240426223043674"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223049058.png" alt="image-20240426223049058"></p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223642340.png" alt="image-20240426223642340"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223343429.png" alt="image-20240426223343429"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223435568.png" alt="image-20240426223435568"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223623059.png" alt="image-20240426223623059"></p><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224052076.png" alt="image-20240426224052076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223933261.png" alt="image-20240426223933261"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224157458.png" alt="image-20240426224157458"></p><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224548604.png" alt="image-20240426224548604"></p><h1 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153146275.png" alt="image-20240427153146275"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153238267.png" alt="image-20240427153238267"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153329535.png" alt="image-20240427153329535"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153528037.png" alt="image-20240427153528037"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153536900.png" alt="image-20240427153536900"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153654004.png" alt="image-20240427153654004"></p><h2 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153905013.png" alt="image-20240427153905013"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153954228.png" alt="image-20240427153954228"></p><h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154050812.png" alt="image-20240427154050812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154158402.png" alt="image-20240427154158402"></p><h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154433993.png" alt="image-20240427154433993"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154506099.png" alt="image-20240427154506099"></p><h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154806950.png" alt="image-20240427154806950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154919393.png" alt="image-20240427154919393"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154909218.png" alt="image-20240427154909218"></p><h2 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155132426.png" alt="image-20240427155132426"></p><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155351280.png" alt="image-20240427155351280"></p><h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155549439.png" alt="image-20240427155549439"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155657037.png" alt="image-20240427155657037"></p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155714643.png" alt="image-20240427155714643"></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427161617855.png" alt="image-20240427161617855"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427161909400.png" alt="image-20240427161909400"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427162015247.png" alt="image-20240427162015247"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427162138098.png" alt="image-20240427162138098"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164404808.png" alt="image-20240427164404808"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427163801843.png" alt="image-20240427163801843"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427163931364.png" alt="image-20240427163931364"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164150523.png" alt="image-20240427164150523"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164224249.png" alt="image-20240427164224249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164238901.png" alt="image-20240427164238901"></p><h2 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427165838505.png" alt="image-20240427165838505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427165920640.png" alt="image-20240427165920640"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170038714.png" alt="image-20240427170038714"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170257233.png" alt="image-20240427170257233"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170413130.png" alt="image-20240427170413130"></p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230155371.png" alt="image-20240427230155371"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230456604.png" alt="image-20240427230456604"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230748836.png" alt="image-20240427230748836"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231003737.png" alt="image-20240427231003737"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231031143.png" alt="image-20240427231031143"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231115335.png" alt="image-20240427231115335"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428103345511.png" alt="image-20240428103345511"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428103541095.png" alt="image-20240428103541095"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104031040.png" alt="image-20240428104031040"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104232904.png" alt="image-20240428104232904"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104329673.png" alt="image-20240428104329673"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104355076.png" alt="image-20240428104355076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104409628.png" alt="image-20240428104409628"></p><h2 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104800043.png" alt="image-20240428104800043"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428110845067.png" alt="image-20240428110845067"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111135087.png" alt="image-20240428111135087"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111303598.png" alt="image-20240428111303598"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111510565.png" alt="image-20240428111510565"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111517724.png" alt="image-20240428111517724"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111556177.png" alt="image-20240428111556177"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111847322.png" alt="image-20240428111847322"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111953258.png" alt="image-20240428111953258"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112039907.png" alt="image-20240428112039907"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112334211.png" alt="image-20240428112334211"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112423236.png" alt="image-20240428112423236"></p><h3 id="检测和解除"><a href="#检测和解除" class="headerlink" title="检测和解除"></a>检测和解除</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112508031.png" alt="image-20240428112508031"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114206668.png" alt="image-20240428114206668"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114342738.png" alt="image-20240428114342738"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114537944.png" alt="image-20240428114537944"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114711590.png" alt="image-20240428114711590"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114751638.png" alt="image-20240428114751638"></p><p>（优先处理批处理式的，因为对用户使用影响不大）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114902430.png" alt="image-20240428114902430"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429153752166.png" alt="image-20240429153752166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429153924658.png" alt="image-20240429153924658"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429155629486.png" alt="image-20240429155629486"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161049771.png" alt="image-20240429161049771"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161153683.png" alt="image-20240429161153683"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161508184.png" alt="image-20240429161508184"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161825328.png" alt="image-20240429161825328"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162053249.png" alt="image-20240429162053249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162102537.png" alt="image-20240429162102537"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162249346.png" alt="image-20240429162249346"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162330274.png" alt="image-20240429162330274"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162410033.png" alt="image-20240429162410033"></p><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163400898.png" alt="image-20240429163400898"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163436757.png" alt="image-20240429163436757"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163535716.png" alt="image-20240429163535716"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163803860.png" alt="image-20240429163803860"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163827524.png" alt="image-20240429163827524"></p><h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164418713.png" alt="image-20240429164418713"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164455670.png" alt="image-20240429164455670"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164544862.png" alt="image-20240429164544862"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164612141.png" alt="image-20240429164612141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164806355.png" alt="image-20240429164806355"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429165155247.png" alt="image-20240429165155247"></p><p>（PCB用于对换出内存的管理，所以不能移除）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429165311501.png" alt="image-20240429165311501"></p><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170107455.png" alt="image-20240429170107455"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170230003.png" alt="image-20240429170230003"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170337227.png" alt="image-20240429170337227"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170427693.png" alt="image-20240429170427693"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170534520.png" alt="image-20240429170534520"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170605691.png" alt="image-20240429170605691"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170629349.png" alt="image-20240429170629349"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429171248308.png" alt="image-20240429171248308"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429171640000.png" alt="image-20240429171640000"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429172307867.png" alt="image-20240429172307867"></p><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429183640521.png" alt="image-20240429183640521"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184107179.png" alt="image-20240429184107179"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184308438.png" alt="image-20240429184308438"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184401089.png" alt="image-20240429184401089"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184847313.png" alt="image-20240429184847313"></p><p>综合而看，四种算法中，首次适应算法的效果反而更好</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184926780.png" alt="image-20240429184926780"></p><h2 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429185044850.png" alt="image-20240429185044850"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192021793.png" alt="image-20240429192021793"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192254015.png" alt="image-20240429192254015"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192445398.png" alt="image-20240429192445398"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193030243.png" alt="image-20240429193030243"></p><p>由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要3*(n+1)B</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193529864.png" alt="image-20240429193529864"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193852356.png" alt="image-20240429193852356"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194001277.png" alt="image-20240429194001277"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194313689.png" alt="image-20240429194313689"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194524418.png" alt="image-20240429194524418"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194533049.png" alt="image-20240429194533049"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194608934.png" alt="image-20240429194608934"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194709962.png" alt="image-20240429194709962"></p><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430132639778.png" alt="image-20240430132639778"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133036680.png" alt="image-20240430133036680"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430132854505.png" alt="image-20240430132854505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133322637.png" alt="image-20240430133322637"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133721750.png" alt="image-20240430133721750"></p><p>进程页表通常是装在连续的内存块中的</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133924940.png" alt="image-20240430133924940"></p><h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214406783.png" alt="image-20240430214406783"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214543586.png" alt="image-20240430214543586"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214820134.png" alt="image-20240430214820134"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215034699.png" alt="image-20240430215034699"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215057205.png" alt="image-20240430215057205"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215201466.png" alt="image-20240430215201466"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215219805.png" alt="image-20240430215219805"></p><h2 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215240895.png" alt="image-20240430215240895"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215333566.png" alt="image-20240430215333566"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215352627.png" alt="image-20240430215352627"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215447088.png" alt="image-20240430215447088"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215536826.png" alt="image-20240430215536826"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215622471.png" alt="image-20240430215622471"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430221904881.png" alt="image-20240430221904881"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430221945125.png" alt="image-20240430221945125"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222104397.png" alt="image-20240430222104397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222157336.png" alt="image-20240430222157336"></p><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222216947.png" alt="image-20240430222216947"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222313015.png" alt="image-20240430222313015"></p><p><strong>编译程序会将段名转换为段号</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222448571.png" alt="image-20240430222448571"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222607184.png" alt="image-20240430222607184"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222632255.png" alt="image-20240430222632255"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222837702.png" alt="image-20240430222837702"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222939786.png" alt="image-20240430222939786"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223029812.png" alt="image-20240430223029812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223111412.png" alt="image-20240430223111412"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223204169.png" alt="image-20240430223204169"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223230391.png" alt="image-20240430223230391"></p><h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223311760.png" alt="image-20240430223311760"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223410358.png" alt="image-20240430223410358"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223432847.png" alt="image-20240430223432847"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223516924.png" alt="image-20240430223516924"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223606180.png" alt="image-20240430223606180"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223748610.png" alt="image-20240430223748610"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223846996.png" alt="image-20240430223846996"></p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184705338.png" alt="image-20240502184705338"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184712905.png" alt="image-20240502184712905"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184811774.png" alt="image-20240502184811774"></p><p>可以用虚拟存储技术来解决以上问题</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185030315.png" alt="image-20240502185030315"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185138135.png" alt="image-20240502185138135"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185227489.png" alt="image-20240502185227489"></p><p>请求分页管理方式</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185306672.png" alt="image-20240502185306672"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185559242.png" alt="image-20240502185559242"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185728367.png" alt="image-20240502185728367"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194240033.png" alt="image-20240502194240033"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194301875.png" alt="image-20240502194301875"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194349367.png" alt="image-20240502194349367"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194456246.png" alt="image-20240502194456246"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194504439.png" alt="image-20240502194504439"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194613253.png" alt="image-20240502194613253"></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194654282.png" alt="image-20240502194654282"></p><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194907990.png" alt="image-20240502194907990"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194923756.png" alt="image-20240502194923756"></p><h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195010397.png" alt="image-20240502195010397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195104391.png" alt="image-20240502195104391"></p><h3 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195219347.png" alt="image-20240502195219347"></p><h3 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195451628.png" alt="image-20240502195451628"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195834848.png" alt="image-20240502195834848"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195846554.png" alt="image-20240502195846554"></p><h2 id="页面分配策略、抖动、工作集"><a href="#页面分配策略、抖动、工作集" class="headerlink" title="页面分配策略、抖动、工作集"></a>页面分配策略、抖动、工作集</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195917853.png" alt="image-20240502195917853"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200328455.png" alt="image-20240502200328455"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200616114.png" alt="image-20240502200616114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200510409.png" alt="image-20240502200510409"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200724251.png" alt="image-20240502200724251"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200857234.png" alt="image-20240502200857234"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201108775.png" alt="image-20240502201108775"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201216358.png" alt="image-20240502201216358"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201416165.png" alt="image-20240502201416165"></p><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201435872.png" alt="image-20240502201435872"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201452957.png" alt="image-20240502201452957"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201604556.png" alt="image-20240502201604556"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201730094.png" alt="image-20240502201730094"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201805732.png" alt="image-20240502201805732"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201827918.png" alt="image-20240502201827918"></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171030309.png" alt="image-20240504171030309"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171100048.png" alt="image-20240504171100048"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171158309.png" alt="image-20240504171158309"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171509565.png" alt="image-20240504171509565"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171545533.png" alt="image-20240504171545533"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172200165.png" alt="image-20240504172200165"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172305676.png" alt="image-20240504172305676"></p><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172432897.png" alt="image-20240504172432897"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172450107.png" alt="image-20240504172450107"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172613166.png" alt="image-20240504172613166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172700370.png" alt="image-20240504172700370"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173323289.png" alt="image-20240504173323289"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173336639.png" alt="image-20240504173336639"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173521971.png" alt="image-20240504173521971"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173624407.png" alt="image-20240504173624407"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173700930.png" alt="image-20240504173700930"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173729770.png" alt="image-20240504173729770"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173749799.png" alt="image-20240504173749799"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173854083.png" alt="image-20240504173854083"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504195911089.png" alt="image-20240504195911089"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504200009100.png" alt="image-20240504200009100"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504200404511.png" alt="image-20240504200404511"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215231835.png" alt="image-20240504215231835"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215306445.png" alt="image-20240504215306445"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215331400.png" alt="image-20240504215331400"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215952889.png" alt="image-20240504215952889"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220119936.png" alt="image-20240504220119936"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220155365.png" alt="image-20240504220155365"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220241393.png" alt="image-20240504220241393"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220544857.png" alt="image-20240504220544857"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220615588.png" alt="image-20240504220615588"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220655481.png" alt="image-20240504220655481"></p><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220740852.png" alt="image-20240504220740852"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220752447.png" alt="image-20240504220752447"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220855137.png" alt="image-20240504220855137"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221018691.png" alt="image-20240504221018691"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221121523.png" alt="image-20240504221121523"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221145678.png" alt="image-20240504221145678"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221221006.png" alt="image-20240504221221006"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221235714.png" alt="image-20240504221235714"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221253950.png" alt="image-20240504221253950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221338623.png" alt="image-20240504221338623"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221406153.png" alt="image-20240504221406153"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221527276.png" alt="image-20240504221527276"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221639911.png" alt="image-20240504221639911"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221722289.png" alt="image-20240504221722289"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221847769.png" alt="image-20240504221847769"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222029236.png" alt="image-20240504222029236"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222113093.png" alt="image-20240504222113093"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222245426.png" alt="image-20240504222245426"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222435451.png" alt="image-20240504222435451"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222441484.png" alt="image-20240504222441484"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222610746.png" alt="image-20240504222610746"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222649601.png" alt="image-20240504222649601"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222734502.png" alt="image-20240504222734502"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222829167.png" alt="image-20240504222829167"></p><h2 id="逻辑结构vs物理结构"><a href="#逻辑结构vs物理结构" class="headerlink" title="逻辑结构vs物理结构"></a>逻辑结构vs物理结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504223801107.png" alt="image-20240504223801107"></p><p>用户用逻辑地址访问文件</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504224101208.png" alt="image-20240504224101208"></p><p>链接分配：逻辑上相邻的块在物理上用链接指针表示先后关系</p><p>索引分配：操作系统为每个文件维护一张索引表，其中记录了逻辑块号-&gt;物理块号的映射关系</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225231869.png" alt="image-20240504225231869"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225343412.png" alt="image-20240504225343412"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225423299.png" alt="image-20240504225423299"></p><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504230904031.png" alt="image-20240504230904031"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231052685.png" alt="image-20240504231052685"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231222045.png" alt="image-20240504231222045"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231330897.png" alt="image-20240504231330897"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231405631.png" alt="image-20240504231405631"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231501014.png" alt="image-20240504231501014"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231702988.png" alt="image-20240504231702988"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231734142.png" alt="image-20240504231734142"></p><p><strong>连续分配和离散分配都适用</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231829147.png" alt="image-20240504231829147"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231940539.png" alt="image-20240504231940539"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232055144.png" alt="image-20240504232055144"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232136941.png" alt="image-20240504232136941"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232227928.png" alt="image-20240504232227928"></p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232311717.png" alt="image-20240504232311717"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232402356.png" alt="image-20240504232402356"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232515051.png" alt="image-20240504232515051"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232622767.png" alt="image-20240504232622767"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232720671.png" alt="image-20240504232720671"></p><p>读写指针记录了该进程对文件的读&#x2F;写操作进行到的位置</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232851782.png" alt="image-20240504232851782"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232947726.png" alt="image-20240504232947726"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233116280.png" alt="image-20240504233116280"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233232205.png" alt="image-20240504233232205"></p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233249597.png" alt="image-20240504233249597"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233306020.png" alt="image-20240504233306020"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233405003.png" alt="image-20240504233405003"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233441070.png" alt="image-20240504233441070"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233519512.png" alt="image-20240504233519512"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233615226.png" alt="image-20240504233615226"></p><p>用软链接访问比硬链接访问更慢</p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233710763.png" alt="image-20240504233710763"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233744538.png" alt="image-20240504233744538"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233836916.png" alt="image-20240504233836916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233849257.png" alt="image-20240504233849257"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233944363.png" alt="image-20240504233944363"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504234020658.png" alt="image-20240504234020658"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504234249589.png" alt="image-20240504234249589"></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004126460.png" alt="image-20240505004126460"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004321745.png" alt="image-20240505004321745"></p><h2 id="全局结构（布局）"><a href="#全局结构（布局）" class="headerlink" title="全局结构（布局）"></a>全局结构（布局）</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004424894.png" alt="image-20240505004424894"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004553268.png" alt="image-20240505004553268"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004659347.png" alt="image-20240505004659347"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004823504.png" alt="image-20240505004823504"></p><h2 id="虚拟文件系统-文件系统挂载（安装）"><a href="#虚拟文件系统-文件系统挂载（安装）" class="headerlink" title="虚拟文件系统&amp;文件系统挂载（安装）"></a>虚拟文件系统&amp;文件系统挂载（安装）</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010711222.png" alt="image-20240505010711222"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010719404.png" alt="image-20240505010719404"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010808536.png" alt="image-20240505010808536"></p><p>不同的文件系统，文件数据结构各不相同</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010952068.png" alt="image-20240505010952068"></p><p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505011216050.png" alt="image-20240505011216050"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505011428925.png" alt="image-20240505011428925"></p><h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="IO设备的概念和分类"><a href="#IO设备的概念和分类" class="headerlink" title="IO设备的概念和分类"></a>IO设备的概念和分类</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225718206.png" alt="image-20240505225718206"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225746149.png" alt="image-20240505225746149"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225827445.png" alt="image-20240505225827445"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225846591.png" alt="image-20240505225846591"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225911811.png" alt="image-20240505225911811"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225942693.png" alt="image-20240505225942693"></p><h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230011862.png" alt="image-20240505230011862"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230024418.png" alt="image-20240505230024418"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230220253.png" alt="image-20240505230220253"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230449678.png" alt="image-20240505230449678"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230525811.png" alt="image-20240505230525811"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230650922.png" alt="image-20240505230650922"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230850587.png" alt="image-20240505230850587"></p><h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231017333.png" alt="image-20240505231017333"></p><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231202758.png" alt="image-20240505231202758"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231400321.png" alt="image-20240505231400321"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231500903.png" alt="image-20240505231500903"></p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231626441.png" alt="image-20240505231626441"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231808551.png" alt="image-20240505231808551"></p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231926063.png" alt="image-20240505231926063"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232123731.png" alt="image-20240505232123731"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232248661.png" alt="image-20240505232248661"></p><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232345060.png" alt="image-20240505232345060"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232427047.png" alt="image-20240505232427047"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232459847.png" alt="image-20240505232459847"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232537544.png" alt="image-20240505232537544"></p><h2 id="IO软件层次结构"><a href="#IO软件层次结构" class="headerlink" title="IO软件层次结构"></a>IO软件层次结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232703178.png" alt="image-20240505232703178"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232753417.png" alt="image-20240505232753417"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233318743.png" alt="image-20240505233318743"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233149021.png" alt="image-20240505233149021"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233457047.png" alt="image-20240505233457047"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233617288.png" alt="image-20240505233617288"></p><p><strong>设备驱动程序和中断处理程序是直接跟硬件打交道的</strong></p><h2 id="输入输出应用程序接口-设备驱动程序接口"><a href="#输入输出应用程序接口-设备驱动程序接口" class="headerlink" title="输入输出应用程序接口&amp;设备驱动程序接口"></a>输入输出应用程序接口&amp;设备驱动程序接口</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233805618.png" alt="image-20240505233805618"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234639307.png" alt="image-20240505234639307"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234410497.png" alt="image-20240505234410497"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234728857.png" alt="image-20240505234728857"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234818521.png" alt="image-20240505234818521"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234903607.png" alt="image-20240505234903607"></p><h1 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515185912720.png" alt="image-20240515185912720"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190016114.png" alt="image-20240515190016114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190051769.png" alt="image-20240515190051769"></p><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190141105.png" alt="image-20240515190141105"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190246973.png" alt="image-20240515190246973"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190306405.png" alt="image-20240515190306405"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190348462.png" alt="image-20240515190348462"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190414097.png" alt="image-20240515190414097"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190512805.png" alt="image-20240515190512805"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190629310.png" alt="image-20240515190629310"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190740808.png" alt="image-20240515190740808"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190807314.png" alt="image-20240515190807314"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190833819.png" alt="image-20240515190833819"></p><h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190904141.png" alt="image-20240515190904141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190947631.png" alt="image-20240515190947631"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515191148963.png" alt="image-20240515191148963"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515191324566.png" alt="image-20240515191324566"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515193830101.png" alt="image-20240515193830101"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515193931812.png" alt="image-20240515193931812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194021285.png" alt="image-20240515194021285"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194050812.png" alt="image-20240515194050812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194117090.png" alt="image-20240515194117090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194219582.png" alt="image-20240515194219582"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194338774.png" alt="image-20240515194338774"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194431060.png" alt="image-20240515194431060"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194458390.png" alt="image-20240515194458390"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194614688.png" alt="image-20240515194614688"></p><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194823232.png" alt="image-20240515194823232"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194900675.png" alt="image-20240515194900675"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195003159.png" alt="image-20240515195003159"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195218929.png" alt="image-20240515195218929"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195312946.png" alt="image-20240515195312946"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195413937.png" alt="image-20240515195413937"></p><p><strong>结论：采用单缓冲策略，处理一块数据平均耗时Max(C，T)+M</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195613001.png" alt="image-20240515195613001"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515200142640.png" alt="image-20240515200142640"></p><p><strong>结论：采用双缓冲策略，先处理一个数据快的平均时间为Max(T,C+M)</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202408963.png" alt="image-20240515202408963"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202425470.png" alt="image-20240515202425470"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202511574.png" alt="image-20240515202511574"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202711480.png" alt="image-20240515202711480"></p><p>第一个是收容输入，第二个是提取输入，第三个是收容输出，第四个是提取输出。</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202850685.png" alt="image-20240515202850685"></p><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215343934.png" alt="image-20240516215343934"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215441480.png" alt="image-20240516215441480"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215519553.png" alt="image-20240516215519553"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215636134.png" alt="image-20240516215636134"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215658355.png" alt="image-20240516215658355"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215710532.png" alt="image-20240516215710532"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215735020.png" alt="image-20240516215735020"></p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215845127.png" alt="image-20240516215845127"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222616024.png" alt="image-20240516222616024"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222649827.png" alt="image-20240516222649827"></p><p>通过软件无法改变延迟时间和传输时间，但是操作系统的磁盘调度算法会直接影响寻道时间。</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222841882.png" alt="image-20240516222841882"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223106937.png" alt="image-20240516223106937"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223224545.png" alt="image-20240516223224545"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223313155.png" alt="image-20240516223313155"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223420104.png" alt="image-20240516223420104"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223452110.png" alt="image-20240516223452110"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223528949.png" alt="image-20240516223528949"></p><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223637792.png" alt="image-20240516223637792"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223731203.png" alt="image-20240516223731203"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223858397.png" alt="image-20240516223858397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224116789.png" alt="image-20240516224116789"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224130200.png" alt="image-20240516224130200"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224232260.png" alt="image-20240516224232260"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224319135.png" alt="image-20240516224319135"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224337508.png" alt="image-20240516224337508"></p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224403877.png" alt="image-20240516224403877"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224616726.png" alt="image-20240516224616726"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224714791.png" alt="image-20240516224714791"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224847796.png" alt="image-20240516224847796"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225039778.png" alt="image-20240516225039778"></p><p>（对操作系统透明即为操作系统不可知，不透明即为操作系统可知）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225117627.png" alt="image-20240516225117627"></p><h2 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225206249.png" alt="image-20240516225206249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225250497.png" alt="image-20240516225250497"></p><p>SSD中黑色的块就是一个个闪存芯片</p><p>固态硬盘的读写单位是页，页相当于磁盘中的块&#x2F;扇区，固态硬盘的块相当于磁盘的磁道</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225511475.png" alt="image-20240516225511475"></p><p>固态硬盘读的速度通常很快，但是写的速度会慢的多（由于写的动作可能会引起擦除的动作以及数据迁移的动作）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516230425181.png" alt="image-20240516230425181"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本指令</title>
      <link href="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="显示—ls"><a href="#显示—ls" class="headerlink" title="显示—ls"></a>显示—ls</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213158767.png" alt="image-20240324213042128"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213250705.png" alt="image-20240324213250705"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213332270.png" alt="image-20240324213332270"></p><h1 id="切换工作目录—cd"><a href="#切换工作目录—cd" class="headerlink" title="切换工作目录—cd"></a>切换工作目录—cd</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213353859.png" alt="image-20240324213353859"></p><h1 id="查看工作目录—pwd"><a href="#查看工作目录—pwd" class="headerlink" title="查看工作目录—pwd"></a>查看工作目录—pwd</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213420156.png" alt="image-20240324213420156"></p><h1 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213511589.png" alt="image-20240324213511589"></p><h1 id="创建目录—mkdir"><a href="#创建目录—mkdir" class="headerlink" title="创建目录—mkdir"></a>创建目录—mkdir</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213536359.png" alt="image-20240324213536359"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213601946.png" alt="image-20240324213601946"></p><h1 id="创建文件—touch"><a href="#创建文件—touch" class="headerlink" title="创建文件—touch"></a>创建文件—touch</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213622899.png" alt="image-20240324213622899"></p><h1 id="查看文件内容—cat"><a href="#查看文件内容—cat" class="headerlink" title="查看文件内容—cat"></a>查看文件内容—cat</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213638906.png" alt="image-20240324213638906"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213704783-17112874254251.png" alt="image-20240324213704783"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213723718.png" alt="image-20240324213723718"></p><h1 id="复制—cp，移动—mv，删除—rm"><a href="#复制—cp，移动—mv，删除—rm" class="headerlink" title="复制—cp，移动—mv，删除—rm"></a>复制—cp，移动—mv，删除—rm</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213752631.png" alt="image-20240324213752631"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213820095.png" alt="image-20240324213820095"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213832997.png" alt="image-20240324213832997"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213854257.png" alt="image-20240324213854257"></p><h1 id="查找—which-find"><a href="#查找—which-find" class="headerlink" title="查找—which&#x2F;find"></a>查找—which&#x2F;find</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213917733.png" alt="image-20240324213917733"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213942043.png" alt="image-20240324213942043"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213953644.png" alt="image-20240324213953644"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214013971.png" alt="image-20240324214013971"></p><h1 id="过滤—grep"><a href="#过滤—grep" class="headerlink" title="过滤—grep"></a>过滤—grep</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214104661.png" alt="image-20240324214104661"></p><h1 id="数量统计—wc"><a href="#数量统计—wc" class="headerlink" title="数量统计—wc"></a>数量统计—wc</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213058155.png" alt="image-20240324213058155"></p><h1 id="管道符—“-”"><a href="#管道符—“-”" class="headerlink" title="管道符—“|”"></a>管道符—“|”</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213122982.png" alt="image-20240324213122982"></p><h1 id="输出指定内容—echo"><a href="#输出指定内容—echo" class="headerlink" title="输出指定内容—echo"></a>输出指定内容—echo</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214203237.png" alt="image-20240324214203237"></p><h1 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214246163.png" alt="image-20240324214246163"></p><h1 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214333538.png" alt="image-20240324214333538"></p><h1 id="查看尾部内容—tail"><a href="#查看尾部内容—tail" class="headerlink" title="查看尾部内容—tail"></a>查看尾部内容—tail</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214425502.png" alt="image-20240324214425502"></p><p>持续跟踪指再通过&gt;&gt;对文件追加内容时，会同时显示出来。</p><p>可以通过CTRL+C结束命令运行。</p><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220144155.png" alt="image-20240324220144155"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220300768.png" alt="image-20240324220300768"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220219685.png" alt="image-20240324220219685"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221017284.png" alt="image-20240324221017284"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221155625.png" alt="image-20240324221155625"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221443763.png" alt="image-20240324221443763"></p><h1 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235721324.png" alt="image-20240326235721324"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235743426.png" alt="image-20240326235743426"></p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235855782.png" alt="image-20240326235855782"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235940645.png" alt="image-20240326235940645"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000647083.png" alt="image-20240327000647083"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000716131.png" alt="image-20240327000716131"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000755732.png" alt="image-20240327000755732"></p><h1 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001138163.png" alt="image-20240327001138163"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001153182.png" alt="image-20240327001153182"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001314477.png" alt="image-20240327001314477"></p><h1 id="修改权限—chmod"><a href="#修改权限—chmod" class="headerlink" title="修改权限—chmod"></a>修改权限—chmod</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001806438.png" alt="image-20240327001806438"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327002348443.png" alt="image-20240327002348443"></p><h1 id="修改用户、用户组—chown"><a href="#修改用户、用户组—chown" class="headerlink" title="修改用户、用户组—chown"></a>修改用户、用户组—chown</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327002709372.png" alt="image-20240327002709372"></p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327225812236.png" alt="image-20240327225812236"></p><h1 id="安装软件—apt-yum"><a href="#安装软件—apt-yum" class="headerlink" title="安装软件—apt&#x2F;yum"></a>安装软件—apt&#x2F;yum</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327230014265.png" alt="image-20240327230014265"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平台正在搭建中</title>
      <link href="/2024/05/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/05/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>将会持续更新操作系统、计网、计组、算法、后端等相关知识，敬请期待~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/23/hello-world/"/>
      <url>/2024/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>个人介绍</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class="note red icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p><strong>欢迎光临珈豪の学习仓库！！！</strong></p></div><p>本人就读于南京大学软件学院，该博客中将会持续发布面试必需的重点专业课知识以及面向就业的必备能力，希望大家能够收藏并且持续关注……</p><p>此网站一方面是为了记录自己的成长之路，另一方面也是鼓励大家坚持做自己所热爱的东西，让我们携手前行，遇见更好的自己！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
