<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务经典面试题</title>
      <link href="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务经典面试题"><a href="#微服务经典面试题" class="headerlink" title="微服务经典面试题"></a>微服务经典面试题</h1><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105303531.png" alt="image-20250316105303531"></p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="常见组件有哪些"><a href="#常见组件有哪些" class="headerlink" title="常见组件有哪些"></a>常见组件有哪些</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105506529.png" alt="image-20250316105506529"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105528515.png" alt="image-20250316105528515"></p><h3 id="注册中心eureka、nacos"><a href="#注册中心eureka、nacos" class="headerlink" title="注册中心eureka、nacos"></a>注册中心eureka、nacos</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105614434.png" alt="image-20250316105614434"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105818495.png" alt="image-20250316105818495"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105905690.png" alt="image-20250316105905690"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316105921661.png" alt="image-20250316105921661"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316110049741.png" alt="image-20250316110049741"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316110232221.png" alt="image-20250316110232221"></p><p><em>AP模式：高可用模式；CP模式：强一致模式</em></p><h3 id="Ribbon负载均衡，负载均衡策略，自定义负载均衡"><a href="#Ribbon负载均衡，负载均衡策略，自定义负载均衡" class="headerlink" title="Ribbon负载均衡，负载均衡策略，自定义负载均衡"></a>Ribbon负载均衡，负载均衡策略，自定义负载均衡</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316110427652.png" alt="image-20250316110427652"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316110542021.png" alt="image-20250316110542021"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316110847256.png" alt="image-20250316110847256"></p><p>Ribbon的默认负载均衡策略是最后一个——区域敏感策略。如果没有区域的概念，那就默认是轮询。</p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316111048381.png" alt="image-20250316111048381"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316111246278.png" alt="image-20250316111246278"></p><h3 id="服务雪崩、熔断降级"><a href="#服务雪崩、熔断降级" class="headerlink" title="服务雪崩、熔断降级"></a>服务雪崩、熔断降级</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316114338143.png" alt="image-20250316114338143"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316114452972.png" alt="image-20250316114452972"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316114645732.png" alt="image-20250316114645732"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316114818116.png" alt="image-20250316114818116"></p><p>服务降级针对的是某个接口，是部分服务；服务熔断针对的是整个服务。</p><h3 id="微服务的监控—skywalking"><a href="#微服务的监控—skywalking" class="headerlink" title="微服务的监控—skywalking"></a>微服务的监控—skywalking</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316115332879.png" alt="image-20250316115332879"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316115828442.png" alt="image-20250316115828442"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316115907630.png" alt="image-20250316115907630"></p><h2 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h2><h3 id="微服务限流（漏桶算法、令牌桶算法）"><a href="#微服务限流（漏桶算法、令牌桶算法）" class="headerlink" title="微服务限流（漏桶算法、令牌桶算法）"></a>微服务限流（漏桶算法、令牌桶算法）</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316162355485.png" alt="image-20250316162355485"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316162612222.png" alt="image-20250316162612222"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316162713192.png" alt="image-20250316162713192"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163010192.png" alt="image-20250316163010192"></p><p>令牌桶需要使用Redis，所以需要在对应文件配置redis。</p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163148725.png" alt="image-20250316163148725"></p><p>令牌桶和漏桶，区别在于漏桶是以固定速率漏出请求，而令牌桶给出令牌的速率不固定，根据有多少请求申请令牌决定。</p><h3 id="分布式系统理论—CAP和BASE"><a href="#分布式系统理论—CAP和BASE" class="headerlink" title="分布式系统理论—CAP和BASE"></a>分布式系统理论—CAP和BASE</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163349889.png" alt="image-20250316163349889"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163416467.png" alt="image-20250316163416467"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163458662.png" alt="image-20250316163458662"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163523720.png" alt="image-20250316163523720"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316163709035.png" alt="image-20250316163709035"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316164228900.png" alt="image-20250316164228900"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316164310170.png" alt="image-20250316164310170"></p><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316165541361.png" alt="image-20250316165541361"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316170212082.png" alt="image-20250316170212082"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316170734684.png" alt="image-20250316170734684"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316171606306.png" alt="image-20250316171606306"></p><p>AT模式推荐且常用。</p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316172818753.png" alt="image-20250316172818753"></p><p>TCC中的Try、 Confirm、cancel三步需要手动代码实现，代码耦合度高。而XA和AT是依赖框架自动完成的。代码耦合度低。</p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316174630144.png" alt="image-20250316174630144"></p><p>MQ是异步的，性能较高，但需要手动解决，实时性较差。</p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316175936551.png" alt="image-20250316175936551"></p><p>银行业务需要强一致性；互联网业务需要高可用性。</p><h3 id="分布式服务的接口幂等性如何设计"><a href="#分布式服务的接口幂等性如何设计" class="headerlink" title="分布式服务的接口幂等性如何设计"></a>分布式服务的接口幂等性如何设计</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316181816307.png" alt="image-20250316181816307"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316181944806.png" alt="image-20250316181944806"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182124351.png" alt="image-20250316182124351"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182159634.png" alt="image-20250316182159634"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182321589.png" alt="image-20250316182321589"></p><h3 id="你们项目中使用了什么分布式任务调度—xxl-job"><a href="#你们项目中使用了什么分布式任务调度—xxl-job" class="headerlink" title="你们项目中使用了什么分布式任务调度—xxl-job"></a>你们项目中使用了什么分布式任务调度—xxl-job</h3><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182500286.png" alt="image-20250316182500286"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182621399.png" alt="image-20250316182621399"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182715668.png" alt="image-20250316182715668"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316182946883.png" alt="image-20250316182946883"></p><p><img src="/2025/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250316183044011.png" alt="image-20250316183044011"></p>]]></content>
      
      
      <categories>
          
          <category> 后端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端框架经典面试题</title>
      <link href="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315103731399.png" alt="image-20250315103731399"></p><h1 id="后端框架经典面试题"><a href="#后端框架经典面试题" class="headerlink" title="后端框架经典面试题"></a>后端框架经典面试题</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="单例bean是线程安全的吗"><a href="#单例bean是线程安全的吗" class="headerlink" title="单例bean是线程安全的吗"></a>单例bean是线程安全的吗</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315104052693.png" alt="image-20250315104052693"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315104255315.png" alt="image-20250315104255315"></p><p>无状态的对象，即不可被修改的对象，是线程安全的</p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315104330761.png" alt="image-20250315104330761"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315104343147.png" alt="image-20250315104343147"></p><h3 id="AOP相关面试题"><a href="#AOP相关面试题" class="headerlink" title="AOP相关面试题"></a>AOP相关面试题</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315144532175.png" alt="image-20250315144532175"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315144851234.png" alt="image-20250315144851234"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315145002677.png" alt="image-20250315145002677"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315145104427.png" alt="image-20250315145104427"></p><h3 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315145139277.png" alt="image-20250315145139277"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315145355172.png" alt="image-20250315145355172"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315154134531.png" alt="image-20250315154134531"></p><p>Spring事务只会对RuntimeError异常进行回滚</p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315154236893.png" alt="image-20250315154236893"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315154342642.png" alt="image-20250315154342642"></p><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315154435738.png" alt="image-20250315154435738"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315154843372.png" alt="image-20250315154843372"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315155043907.png" alt="image-20250315155043907"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315155540822.png" alt="image-20250315155540822"></p><h3 id="bean的循环依赖（循环引用）"><a href="#bean的循环依赖（循环引用）" class="headerlink" title="bean的循环依赖（循环引用）"></a>bean的循环依赖（循环引用）</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315160931508.png" alt="image-20250315160931508"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315161025551.png" alt="image-20250315161025551"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315161129254.png" alt="image-20250315161129254"></p><p>一级缓存作用：限制bean在beanFactory中只存一份，即实现singleton scope，解决不了循环依赖。</p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315161315162.png" alt="image-20250315161315162"></p><p>一级和二级缓存可以解决一般的循环依赖，如果一个对象被增强，即代理对象，那么就需要三级缓存。</p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315161608202.png" alt="image-20250315161608202"></p><p>三级缓存中的对象工厂可以帮助产生代理对象或者原始对象。</p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315170658992.png" alt="image-20250315170658992"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315170835376.png" alt="image-20250315170835376"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315170856790.png" alt="image-20250315170856790"></p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315170944127.png" alt="image-20250315170944127"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315171350999.png" alt="image-20250315171350999"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315171422964.png" alt="image-20250315171422964"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315171810409.png" alt="image-20250315171810409"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315171837338.png" alt="image-20250315171837338"></p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315171930325.png" alt="image-20250315171930325"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172131287.png" alt="image-20250315172131287"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172221802.png" alt="image-20250315172221802"></p><h2 id="Spring框架中常见的注解"><a href="#Spring框架中常见的注解" class="headerlink" title="Spring框架中常见的注解"></a>Spring框架中常见的注解</h2><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172259543.png" alt="image-20250315172259543"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172355168.png" alt="image-20250315172355168"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172450015.png" alt="image-20250315172450015"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315172517946.png" alt="image-20250315172517946"></p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205009959.png" alt="image-20250315205009959"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205316968.png" alt="image-20250315205316968"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205350948.png" alt="image-20250315205350948"></p><h3 id="延迟加载使用及原理"><a href="#延迟加载使用及原理" class="headerlink" title="延迟加载使用及原理"></a>延迟加载使用及原理</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205440085.png" alt="image-20250315205440085"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205751394.png" alt="image-20250315205751394"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205858778.png" alt="image-20250315205858778"></p><h3 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h3><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315205941257.png" alt="image-20250315205941257"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315210117991.png" alt="image-20250315210117991"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315210258425.png" alt="image-20250315210258425"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315210346816.png" alt="image-20250315210346816"></p><p><img src="/2025/03/16/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250315210424008.png" alt="image-20250315210424008"></p>]]></content>
      
      
      <categories>
          
          <category> 后端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合经典面试题</title>
      <link href="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合经典面试题"><a href="#Java集合经典面试题" class="headerlink" title="Java集合经典面试题"></a>Java集合经典面试题</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Java集合框架体系"><a href="#Java集合框架体系" class="headerlink" title="Java集合框架体系"></a>Java集合框架体系</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308165857396.png" alt="image-20250308165857396"></p><h3 id="常见复杂度表示形式"><a href="#常见复杂度表示形式" class="headerlink" title="常见复杂度表示形式"></a>常见复杂度表示形式</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308170120745.png" alt="image-20250308170120745"></p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308170814615.png" alt="image-20250308170814615"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308170841010.png" alt="image-20250308170841010"></p><h2 id="List相关面试题"><a href="#List相关面试题" class="headerlink" title="List相关面试题"></a>List相关面试题</h2><h3 id="数组结构—数组"><a href="#数组结构—数组" class="headerlink" title="数组结构—数组"></a>数组结构—数组</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171339118.png" alt="image-20250308171339118"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171442534.png" alt="image-20250308171442534"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171537103.png" alt="image-20250308171537103"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171644837.png" alt="image-20250308171644837"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171656156.png" alt="image-20250308171656156"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171723069.png" alt="image-20250308171723069"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250308171805575.png" alt="image-20250308171805575"></p><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309160258200.png" alt="image-20250309160258200"></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309160409163.png" alt="image-20250309160409163"></p><h4 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309160803800.png" alt="image-20250309160803800"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309160908463.png" alt="image-20250309160908463"></p><p>第10次时，minCapacity &#x3D; elementData.length，所以不需要扩容</p><p>第11次时，minCapacity &#x3D; 11 &gt; elementData.length，会扩容1.5倍，elementData的长度变为15。</p><h3 id="ArrayList底层实现原理"><a href="#ArrayList底层实现原理" class="headerlink" title="ArrayList底层实现原理"></a>ArrayList底层实现原理</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309161409638.png" alt="image-20250309161409638"></p><h3 id="ArrayList-list-ArrayList-10-中的list扩容几次"><a href="#ArrayList-list-ArrayList-10-中的list扩容几次" class="headerlink" title="ArrayList list &#x3D; ArrayList(10)中的list扩容几次"></a>ArrayList list &#x3D; ArrayList(10)中的list扩容几次</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309161453786.png" alt="image-20250309161453786"></p><h3 id="如何实现数组和list之间的转换"><a href="#如何实现数组和list之间的转换" class="headerlink" title="如何实现数组和list之间的转换"></a>如何实现数组和list之间的转换</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309170226249.png" alt="image-20250309170226249"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309170434111.png" alt="image-20250309170434111"></p><h3 id="ArrayList和LinkedList的区别是什么"><a href="#ArrayList和LinkedList的区别是什么" class="headerlink" title="ArrayList和LinkedList的区别是什么"></a>ArrayList和LinkedList的区别是什么</h3><h4 id="相关内容——链表："><a href="#相关内容——链表：" class="headerlink" title="相关内容——链表："></a>相关内容——链表：</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309170726347.png" alt="image-20250309170726347"></p><h4 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h4><ol><li>底层数据结构</li><li>效率</li><li>空间</li><li>线程是否安全</li></ol><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309170831914.png" alt="image-20250309170831914"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309170942764.png" alt="image-20250309170942764"></p><h2 id="HashMap相关面试题"><a href="#HashMap相关面试题" class="headerlink" title="HashMap相关面试题"></a>HashMap相关面试题</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171434960.png" alt="image-20250309171434960"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171452763.png" alt="image-20250309171452763"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171507145.png" alt="image-20250309171507145"></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171550340.png" alt="image-20250309171550340"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171650559.png" alt="image-20250309171650559"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171708178.png" alt="image-20250309171708178"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171730845.png" alt="image-20250309171730845"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171802495.png" alt="image-20250309171802495"></p><p><strong>性质</strong>：</p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309171945880.png" alt="image-20250309171945880"></p><p><strong>复杂度</strong>：<br><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172033745.png" alt="image-20250309172033745"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172046399.png" alt="image-20250309172046399"></p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>在HashMap中的最重要的一个数据结构，在散列表中又使用了红黑树和链表</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172503250.png" alt="image-20250309172503250"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172527208.png" alt="image-20250309172527208"></p><h5 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172604044.png" alt="image-20250309172604044"></p><h5 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172653022.png" alt="image-20250309172653022"></p><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172719284.png" alt="image-20250309172719284"></p><h6 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172749225.png" alt="image-20250309172749225"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172834217.png" alt="image-20250309172834217"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172848571.png" alt="image-20250309172848571"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172859851.png" alt="image-20250309172859851"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309172928131.png" alt="image-20250309172928131"></p><h3 id="说一下HashMap实现原理"><a href="#说一下HashMap实现原理" class="headerlink" title="说一下HashMap实现原理"></a>说一下HashMap实现原理</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309173122070.png" alt="image-20250309173122070"></p><h3 id="HashMap的jdk1-7和jdk1-8有什么区别"><a href="#HashMap的jdk1-7和jdk1-8有什么区别" class="headerlink" title="HashMap的jdk1.7和jdk1.8有什么区别"></a>HashMap的jdk1.7和jdk1.8有什么区别</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309173303688.png" alt="image-20250309173303688"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309173332129.png" alt="image-20250309173332129"></p><h3 id="HashMap的put方法的具体流程"><a href="#HashMap的put方法的具体流程" class="headerlink" title="HashMap的put方法的具体流程"></a>HashMap的put方法的具体流程</h3><h4 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><h5 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309173556472.png" alt="image-20250309173556472"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309173712859.png" alt="image-20250309173712859"></p><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309175053425.png" alt="image-20250309175053425"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309175157896.png" alt="image-20250309175157896"></p><h3 id="讲一讲HashMap的扩容机制"><a href="#讲一讲HashMap的扩容机制" class="headerlink" title="讲一讲HashMap的扩容机制"></a>讲一讲HashMap的扩容机制</h3><h4 id="HashMap源码分析-1"><a href="#HashMap源码分析-1" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h4><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309195404495.png" alt="image-20250309195404495"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309195808913.png" alt="image-20250309195808913"></p><p><em>计算方式的原因</em>：</p><ul><li>e.hash &amp; (newCap - 1)：相当于用当前数的哈希值对新的容量取模，比如哈希值为17，新的容量为16，则相当于将17与二进制1111进行与运算，拿到低位的值，即取模后的值</li><li>e.hash &amp; oldCap：如上面的例子，将17和10000进行与运算，不为0则说明这个哈希值比16大，则需要后移增加容量的大小，如17将会移到17的位置（17%32&#x3D;17）</li></ul><h3 id="HashMap的寻址方法"><a href="#HashMap的寻址方法" class="headerlink" title="HashMap的寻址方法"></a>HashMap的寻址方法</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309200731249.png" alt="image-20250309200731249"></p><p>右移16位后将高位和低位混合，提高随机性。</p><h3 id="为何HashMap的数组长度一定是2的次幂"><a href="#为何HashMap的数组长度一定是2的次幂" class="headerlink" title="为何HashMap的数组长度一定是2的次幂"></a>为何HashMap的数组长度一定是2的次幂</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309200933043.png" alt="image-20250309200933043"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309200956382.png" alt="image-20250309200956382"></p><h3 id="HashMap在1-7情况下的多线程死循环问题"><a href="#HashMap在1-7情况下的多线程死循环问题" class="headerlink" title="HashMap在1.7情况下的多线程死循环问题"></a>HashMap在1.7情况下的多线程死循环问题</h3><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309202116766.png" alt="image-20250309202116766"></p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309202140327.png" alt="image-20250309202140327"></p><p>线程2先迁移，先将A迁移过来，在用头插法将B迁移到A的前面，如下图：</p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309202408844.png" alt="image-20250309202408844"></p><p>然后线程1先将A迁移过来，e指向next指向的，即B，next指向B的后面，此时为A，然后将B迁移上去，此时e指向A，next指向A的后面，即null，如下：</p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309202853495.png" alt="image-20250309202853495"></p><p>然后将A迁移上去，e指向null，如下：</p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309202940052.png" alt="image-20250309202940052"></p><p>这样导致A和B互相指向，在访问时会产生死循环。</p><p><img src="/2025/03/09/Java%E9%9B%86%E5%90%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250309203046160.png" alt="image-20250309203046160"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis经典面试题</title>
      <link href="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis经典面试题"><a href="#Redis经典面试题" class="headerlink" title="Redis经典面试题"></a>Redis经典面试题</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302163913165.png" alt="image-20250302163913165"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164028568.png" alt="image-20250302164028568"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164404573.png" alt="image-20250302164404573"></p><p>布隆过滤器主要用于拦截不存在的数据</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164238043.png" alt="image-20250302164238043"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164326120.png" alt="image-20250302164326120"></p><p><em>通过设置误判率来减少误判</em></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164520493.png" alt="image-20250302164520493"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164530491.png" alt="image-20250302164530491"></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>热门数据过期</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164638751.png" alt="image-20250302164638751"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302164935831.png" alt="image-20250302164935831"></p><p><em>逻辑过期是在缓存中添加一个过期时间的字段，而不再给key设置过期时间</em></p><p>互斥锁：强一致、性能差</p><p>逻辑过期：高可用、性能优</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165102098.png" alt="image-20250302165102098"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165116941.png" alt="image-20250302165116941"></p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165639914.png" alt="image-20250302165639914"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165711889.png" alt="image-20250302165711889"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165722570.png" alt="image-20250302165722570"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165851168.png" alt="image-20250302165851168"></p><h4 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302165945892.png" alt="image-20250302165945892"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302171326251.png" alt="image-20250302171326251"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302171829371.png" alt="image-20250302171829371"></p><p>两种情况都可能出现脏数据的问题</p><p>第二次删除缓存就是为了防止脏数据的情况出现</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172001293.png" alt="image-20250302172001293"></p><p>延时的时间不好控制，也容易出现脏数据的风险</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172143392.png" alt="image-20250302172143392"></p><p>使用Redis一般是读多写少的情况</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172303689.png" alt="image-20250302172303689"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172312705.png" alt="image-20250302172312705"></p><p>读写锁：强一致，但是性能低</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172526400.png" alt="image-20250302172526400"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172602335.png" alt="image-20250302172602335"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172749563.png" alt="image-20250302172749563"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172759283.png" alt="image-20250302172759283"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172806342.png" alt="image-20250302172806342"></p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172843244.png" alt="image-20250302172843244"></p><h5 id="RDB："><a href="#RDB：" class="headerlink" title="RDB："></a>RDB：</h5><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302172951668.png" alt="image-20250302172951668"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173202730.png" alt="image-20250302173202730"></p><h5 id="AOF："><a href="#AOF：" class="headerlink" title="AOF："></a>AOF：</h5><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173226934.png" alt="image-20250302173226934"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173300914.png" alt="image-20250302173300914"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173404225.png" alt="image-20250302173404225"></p><h5 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h5><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173559912.png" alt="image-20250302173559912"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173607850.png" alt="image-20250302173607850"></p><h4 id="数据过期策略"><a href="#数据过期策略" class="headerlink" title="数据过期策略"></a>数据过期策略</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173726377.png" alt="image-20250302173726377"></p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173802701.png" alt="image-20250302173802701"></p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302173912054.png" alt="image-20250302173912054"></p><p><strong>Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用</strong></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174012328.png" alt="image-20250302174012328"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174018857.png" alt="image-20250302174018857"></p><h4 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174103720.png" alt="image-20250302174103720"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174236107.png" alt="image-20250302174236107"></p><p><strong>使用建议</strong>：</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174349728.png" alt="image-20250302174349728"></p><p><strong>场景题</strong>：</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174450213.png" alt="image-20250302174450213"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174512730.png" alt="image-20250302174512730"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302174523388.png" alt="image-20250302174523388"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210003368.png" alt="image-20250302210003368"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210129232.png" alt="image-20250302210129232"></p><p>但是synchronized是本地的锁，锁只在一个JVM上生效，如果是多个服务器，则还是会出现超卖的情况</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210339253.png" alt="image-20250302210339253"></p><h4 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210637492.png" alt="image-20250302210637492"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210807656.png" alt="image-20250302210807656"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302210904192.png" alt="image-20250302210904192"></p><p>lua脚本通过调用Redis命令，可以保证多条命令执行的原子性。</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211246302.png" alt="image-20250302211246302"></p><p>可重入需要判断当前加锁的是否是同一个线程</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211413513.png" alt="image-20250302211413513"></p><p>如果还没来得及同步数据，主节点宕机了，会在从节点中选择一个作为新的主节点，之前的数据没同步过来，所以新的线程也能加锁成功，就可能出现两个线程同时持有同一把锁。</p><p><strong>解决方法</strong>：</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211720489.png" alt="image-20250302211720489"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211832334.png" alt="image-20250302211832334"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211844385.png" alt="image-20250302211844385"></p><h2 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302211940044.png" alt="image-20250302211940044"></p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302212041329.png" alt="image-20250302212041329"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302212946839.png" alt="image-20250302212946839"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213108369.png" alt="image-20250302213108369"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213208307.png" alt="image-20250302213208307"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213216783.png" alt="image-20250302213216783"></p><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>作用：</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213336244.png" alt="image-20250302213336244"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213502887.png" alt="image-20250302213502887"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213621213.png" alt="image-20250302213621213"></p><p>老的master还被客户端写入新的数据，当老的master变成slave，需要同步新的master数据，导致自身的数据被覆盖丢失。</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213811643.png" alt="image-20250302213811643"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213939483.png" alt="image-20250302213939483"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302213957455.png" alt="image-20250302213957455"></p><h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><p>结构：</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214143217.png" alt="image-20250302214143217"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214246640.png" alt="image-20250302214246640"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214329224.png" alt="image-20250302214329224"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214337754.png" alt="image-20250302214337754"></p><h3 id="Redis是单线程的，但是为什么还那么快"><a href="#Redis是单线程的，但是为什么还那么快" class="headerlink" title="Redis是单线程的，但是为什么还那么快"></a>Redis是单线程的，但是为什么还那么快</h3><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214459913.png" alt="image-20250302214459913"></p><h4 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214806742.png" alt="image-20250302214806742"></p><p>主要影响性能的原因主要是等待数据和数据的来回拷贝</p><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302214955931.png" alt="image-20250302214955931"></p><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302215035696.png" alt="image-20250302215035696"></p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302215216917.png" alt="image-20250302215216917"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302215310819.png" alt="image-20250302215310819"></p><h4 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h4><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302215848063.png" alt="image-20250302215848063"></p><p>多线程的使用主要减少了网络IO对性能的影响</p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302221509735.png" alt="image-20250302221509735"></p><p><img src="/2025/03/02/Redis%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250302221516847.png" alt="image-20250302221516847"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL经典面试题</title>
      <link href="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL经典面试题"><a href="#MySQL经典面试题" class="headerlink" title="MySQL经典面试题"></a>MySQL经典面试题</h1><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="在MySQL中，如何定位慢查询？"><a href="#在MySQL中，如何定位慢查询？" class="headerlink" title="在MySQL中，如何定位慢查询？"></a>在MySQL中，如何定位慢查询？</h3><p>慢查询情况：</p><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li></ul><p>表象：页面加载过慢、接口压测响应时间过长（超过1s）</p><ul><li><p>方案一：开源工具</p><ul><li>调试工具：Arthas</li><li>运维工具：Prometheus、Skywalking</li></ul></li><li><p>方案二：MySQL自带慢日志</p><ul><li><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p></li><li><p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启MySQL慢日志查询开关</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#设置慢日志的时间为2秒，SQL语句执行时间超过2s，就会视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250228215439818.png" alt="image-20250228215439818"></p></li></ul></li></ul><p><strong>面试话术：</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250228215534050.png" alt="image-20250228215534050"></p><p><em>生产条件下不会开启慢日志，会损耗一些MySQL的性能</em></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301151148854.png" alt="image-20250301151148854"></p><h3 id="SQL语句执行计划"><a href="#SQL语句执行计划" class="headerlink" title="SQL语句执行计划"></a>SQL语句执行计划</h3><p>可以采用EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301151452282.png" alt="image-20250301151452282"></p><ul><li><p>possible_key：当前sql可能会使用到的索引</p></li><li><p>key：当前sql实际命中的索引</p></li><li><p>key_len：索引占用的大小</p><p><em>通过key和key_len两个查看是否可能会命中索引，索引本身存在是否有失效的情况</em></p></li><li><p>Extra：额外的优化建议</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301151746303.png" alt="image-20250301151746303"></p><p><em>是否出现了回表，如果出现了，可以尝试添加索引或修改返回字段来修复</em></p></li><li><p>type：这条sql的连接的类型，性能由好到差为NULL、system、const、eq_ref、ref、range、index、all</p><ul><li><p>NULL：这条sql语句执行时没有用到表</p></li><li><p>system：查询系统中的表</p></li><li><p>const：根据主键查询</p></li><li><p>eq_ref：主键索引查询或唯一索引查询，只能返回一条</p></li><li><p>ref：索引查询，可能是多条</p></li><li><p>range：范围查询</p></li><li><p>index：索引树扫描</p></li><li><p>all：全盘扫描</p><p><em>如果是index或all，就需要优化</em></p></li></ul></li></ul><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301152443378.png" alt="image-20250301152443378"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301152452368.png" alt="image-20250301152452368"></p><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库还维护着满足特定查找算法的数据结构（<strong>B+树</strong>），这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><h4 id="数据结构对比"><a href="#数据结构对比" class="headerlink" title="数据结构对比"></a>数据结构对比</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301162227435.png" alt="image-20250301162227435"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301162324100.png" alt="image-20250301162324100"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301162516876.png" alt="image-20250301162516876"></p><p>非叶子节点存储指针，效率更高，磁盘读写代价低；数据都存储在叶子节点上，查询效率稳定；且叶子节点之间存在链表，适合扫库和区间查询</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301162609034.png" alt="image-20250301162609034"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301162716307.png" alt="image-20250301162716307"></p><h3 id="什么是聚簇索引，什么是非聚簇索引（二级索引）-什么是回表查询"><a href="#什么是聚簇索引，什么是非聚簇索引（二级索引）-什么是回表查询" class="headerlink" title="什么是聚簇索引，什么是非聚簇索引（二级索引）&#x2F;什么是回表查询"></a>什么是聚簇索引，什么是非聚簇索引（二级索引）&#x2F;什么是回表查询</h3><h4 id="聚簇索引和二级索引"><a href="#聚簇索引和二级索引" class="headerlink" title="聚簇索引和二级索引"></a>聚簇索引和二级索引</h4><p>自己创建的索引一般都是二级索引</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165015054.png" alt="image-20250301165015054"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301164944588.png" alt="image-20250301164944588"></p><h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165113065.png" alt="image-20250301165113065"></p><p>回表查询：先通过二级索引拿到主键值，再根据主键值通过聚集索引拿到整行数据。</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165359176.png" alt="image-20250301165359176"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165408707.png" alt="image-20250301165408707"></p><h3 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h3><p>指查询中使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165747296.png" alt="image-20250301165747296"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165838849.png" alt="image-20250301165838849"></p><h4 id="MySQL超大分页处理"><a href="#MySQL超大分页处理" class="headerlink" title="MySQL超大分页处理"></a>MySQL超大分页处理</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301165919934.png" alt="image-20250301165919934"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170035881.png" alt="image-20250301170035881"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170112485.png" alt="image-20250301170112485"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170150771.png" alt="image-20250301170150771"></p><h3 id="索引创建原则有哪些"><a href="#索引创建原则有哪些" class="headerlink" title="索引创建原则有哪些"></a>索引创建原则有哪些</h3><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170518979.png" alt="image-20250301170518979" style="zoom: 67%;"><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170745974.png" alt="image-20250301170745974"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170826569.png" alt="image-20250301170826569"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301170833626.png" alt="image-20250301170833626"></p><h3 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h3><p>联合索引中每个索引字段存在顺序</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301171640691.png" alt="image-20250301171640691"></p><p>通过<strong>执行计划explain</strong>判断哪块索引失效</p><ul><li>违反最左前缀法则<ul><li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</li><li>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效</li><li><em>可以理解为联合索引中，从哪一个索引开始在sql语句中where后面的判断语句部分没出现，那么从它开始（包括自己）的索引都失效</em></li></ul></li><li>范围查询的右边的列，不能使用索引<ul><li><em>可以理解为联合索引中，从哪一个索引开始在sql语句中where后面的判断语句部分是通过大于小于号进行范围查询的，那么从它下一个索引开始的索引都失效（即范围查询的这个索引不失效，而是下一个开始失效）</em></li></ul></li><li>不要在索引列上进行运算操作，索引将失效<ul><li><em>比如substring</em></li></ul></li><li>字符串不加单引号，造成索引无效<ul><li>由于MySQL的查询优化器会自动的进行<strong>类型转换</strong>，造成索引无效</li></ul></li><li>以%开头的Like模糊查询，索引失效。如果仅仅是尾部模糊查询匹配，索引不会失效。如果是头部模糊匹配，索引失效。<ul><li><em>即%xxx会失效，xxx%则不会失效</em></li></ul></li></ul><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301172528795.png" alt="image-20250301172528795"></p><h3 id="SQL优化经验"><a href="#SQL优化经验" class="headerlink" title="SQL优化经验"></a>SQL优化经验</h3><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173007451.png" alt="image-20250301173007451" style="zoom: 67%;"><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173356967.png" alt="image-20250301173356967"></p><p>第四点中，<em>union all查询后两个条件查询出来的数据合并，所以会有重复的数据；而union查询后自动查重，不会有重复数据</em>。</p><p>第五点中，<img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173449584.png" alt="image-20250301173449584" style="zoom: 50%;">小循环放外面，MySQL就只需要3次的数据库连接，再在里面进行1000次的数据操作就可以了.</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173751987.png" alt="image-20250301173751987"></p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173826033.png" alt="image-20250301173826033" style="zoom: 67%;"><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301173858284.png" alt="image-20250301173858284"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h3><h4 id="事务的特性是什么"><a href="#事务的特性是什么" class="headerlink" title="事务的特性是什么"></a>事务的特性是什么</h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ul><li>原子性（<strong>A</strong>tomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（<strong>C</strong>onsistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（<strong>I</strong>solution）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（<strong>D</strong>urability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301182824237.png" alt="image-20250301182824237"></p><h4 id="并发事务带来哪些问题？怎样解决？MySQL的默认隔离级别？"><a href="#并发事务带来哪些问题？怎样解决？MySQL的默认隔离级别？" class="headerlink" title="并发事务带来哪些问题？怎样解决？MySQL的默认隔离级别？"></a>并发事务带来哪些问题？怎样解决？MySQL的默认隔离级别？</h4><ul><li>并发事务问题：脏读、不可重复读、幻读</li><li>隔离级别：读未提交、读已提交、<strong>可重复读</strong>、串行化</li></ul><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183022777.png" alt="image-20250301183022777"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183030586.png" alt="image-20250301183030586"></p><p>事务B读到的是事务A中更改的数据，但是事务A还未提交</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183132212.png" alt="image-20250301183132212"></p><p>在事务A两次读操作中间事务B进行了数据的修改，导致两次读操作读到的内容不一致</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183428881.png" alt="image-20250301183428881"></p><p><strong>在解决了不可重复读的前提下</strong>，事务A读数据库发现没有这条数据，这时事务B插入了这条数据，导致A插入时报错，A再读时还是显示数据库中没有，可是插不进去</p><p>解决方案：<strong>对事物进行隔离</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183458465.png" alt="image-20250301183458465"></p><p><em>解决了问题是×，还有这种问题是√</em></p><p><strong>注意：事务隔离级别越高，数据越安全，但是性能越低</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301183904097.png" alt="image-20250301183904097"></p><h4 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184006096.png" alt="image-20250301184006096"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184107511.png" alt="image-20250301184107511"></p><p>如果服务器出问题了，内存中修改的内容无法同步给服务器，不符合事务的持久性。</p><h5 id="redo-log："><a href="#redo-log：" class="headerlink" title="redo log："></a>redo log：</h5><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184308902.png" alt="image-20250301184308902"></p><h5 id="undo-log："><a href="#undo-log：" class="headerlink" title="undo log："></a>undo log：</h5><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184509335.png" alt="image-20250301184509335"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184554580.png" alt="image-20250301184554580"></p><h4 id="解释一下MVCC？-事务中的隔离性是如何保证的？"><a href="#解释一下MVCC？-事务中的隔离性是如何保证的？" class="headerlink" title="解释一下MVCC？&#x2F;事务中的隔离性是如何保证的？"></a>解释一下MVCC？&#x2F;事务中的隔离性是如何保证的？</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301184837073.png" alt="image-20250301184837073"></p><p>全程<strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突。</p><p>MVCC的具体实现，主要依赖于数据库记录中的<strong>隐式字段、undo log日志、readView</strong>。</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301185110726.png" alt="image-20250301185110726"></p><ul><li><p><strong>记录中的隐藏字段</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301185239862.png" alt="image-20250301185239862"></p></li><li><p><strong>undo log</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301185310446.png" alt="image-20250301185310446"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301185517209.png" alt="image-20250301185517209"></p></li><li><p><strong>readView</strong></p><p>ReadView（读视图）是<strong>快照读</strong>SQL执行时MVCC提取数据的依赖，记录并维护系统当前活跃的事务（未提交的）id。</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301185758303.png" alt="image-20250301185758303"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190011520.png" alt="image-20250301190011520"></p></li></ul><h5 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h5><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190206900.png" alt="image-20250301190206900"></p><p><em>当前未提交的事务是活跃的事务</em></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190555301.png" alt="image-20250301190555301"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190641838.png" alt="image-20250301190641838"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190813653.png" alt="image-20250301190813653"></p><p>从后往前依次根据标准判断，第一个符合的就是使用的记录</p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190912997.png" alt="image-20250301190912997"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301190942311.png" alt="image-20250301190942311"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301191058541.png" alt="image-20250301191058541"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301191119516.png" alt="image-20250301191119516"></p><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301230021758.png" alt="image-20250301230021758"></p><p>MySQL主从复制的核心就是<strong>二进制日志</strong></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301230133251.png" alt="image-20250301230133251"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301230246571.png" alt="image-20250301230246571"></p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>分担了访问压力，解决存储压力</strong></p><p>分库分表的<strong>时机</strong>：</p><ol><li>前提，项目业务数据逐渐增多，或业务发展比较迅速（单表的数据量达1000W或20G以后）</li><li>优化已解决不了性能问题（主从读写分离、查询索引……）</li><li>IO瓶颈（磁盘IO、网络IO）、CPU瓶颈（聚合查询、连接数太多）</li></ol><h4 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231055572.png" alt="image-20250301231055572"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231153515.png" alt="image-20250301231153515"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231258683.png" alt="image-20250301231258683"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231346964.png" alt="image-20250301231346964"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231437780.png" alt="image-20250301231437780"></p><h4 id="新的问题和新的技术"><a href="#新的问题和新的技术" class="headerlink" title="新的问题和新的技术"></a>新的问题和新的技术</h4><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231622762.png" alt="image-20250301231622762"></p><p><img src="/2025/03/01/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/image-20250301231814158.png" alt="image-20250301231814158"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM经典面试题</title>
      <link href="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
      <url>/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM虚拟机篇"><a href="#JVM虚拟机篇" class="headerlink" title="JVM虚拟机篇"></a>JVM虚拟机篇</h1><h2 id="JVM介绍、运行流程"><a href="#JVM介绍、运行流程" class="headerlink" title="JVM介绍、运行流程"></a>JVM介绍、运行流程</h2><h3 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h3><p>Java Virtual Machine，Java程序的<strong>运行环境</strong>（java二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li></ul><h3 id="JVM由哪些部分组成，运行流程是什么"><a href="#JVM由哪些部分组成，运行流程是什么" class="headerlink" title="JVM由哪些部分组成，运行流程是什么"></a>JVM由哪些部分组成，运行流程是什么</h3><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250210211936973.png" alt="image-20250210211936973"></p><ol><li>将java代码转换为字节码</li><li>将字节码加载到内存中</li><li>将字节码翻译为底层系统指令</li><li>调用本地方法接口（用C++或者C实现的）</li></ol><h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h3><p><strong>线程私有</strong>的（所以不存在线程安全问题），内部保存的是<strong>字节码的行号</strong>。用于记录正在执行的字节码的指令的地址。</p><h3 id="你能详细介绍下Java堆吗"><a href="#你能详细介绍下Java堆吗" class="headerlink" title="你能详细介绍下Java堆吗"></a>你能详细介绍下Java堆吗</h3><p><strong>线程共享的区域</strong>：主要用来保存<strong>对象实例，数组</strong>等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。</p><p>堆中主要包括两部分——年轻代和老年代。</p><p>年轻代被划分为三部分，Eden区和两个大小<strong>严格相同</strong>的Survivor区，根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被转移到老年代区间。</p><p>老年代主要保存生命周期长的对象，一般是一些老的对象。</p><h4 id="jdk1-7和1-8的区别"><a href="#jdk1-7和1-8的区别" class="headerlink" title="jdk1.7和1.8的区别"></a>jdk1.7和1.8的区别</h4><ul><li>1.7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</li><li>1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</li></ul><h3 id="能不能介绍一下方法区"><a href="#能不能介绍一下方法区" class="headerlink" title="能不能介绍一下方法区"></a>能不能介绍一下方法区</h3><ul><li>也叫元空间，是各个线程<strong>共享的内存区域</strong></li><li>主要存储类的信息、运行时常量池</li><li>虚拟机启动的时候创建，关闭虚拟机时释放</li><li>如果方法区中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</li></ul><h3 id="介绍一下运行时常量池"><a href="#介绍一下运行时常量池" class="headerlink" title="介绍一下运行时常量池"></a>介绍一下运行时常量池</h3><ul><li><p><strong>常量池</strong>：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p></li><li><p>常量池是*.class文件中的，当该类被加载，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong>。</p></li></ul><h3 id="听说过直接内存吗"><a href="#听说过直接内存吗" class="headerlink" title="听说过直接内存吗"></a>听说过直接内存吗</h3><p>直接内存并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存，常见于NIO操作，用于数据缓冲区，它分配回收成本较高，但读写性能高。不受JVM内存回收管理。</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250211213026815.png" alt="image-20250211213026815"></p><p>常规IO的数据拷贝需要两块缓冲区，读取时数据需要存两份（因为java代码本身访问不到系统缓冲区），效率较低。</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250211213248987.png" alt="image-20250211213248987"></p><h3 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h3><ul><li><p>每个线程运行时所需要的内存，称为虚拟机栈，先进后出</p></li><li><p>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存（参数、局部变量、返回地址）</p></li><li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p></li></ul><h3 id="垃圾回收是否涉及栈内存"><a href="#垃圾回收是否涉及栈内存" class="headerlink" title="垃圾回收是否涉及栈内存"></a>垃圾回收是否涉及栈内存</h3><p>垃圾回收主要指堆内存，当栈帧弹栈以后，内存就会释放，不涉及垃圾回收。</p><h3 id="栈内存分配越大越好吗"><a href="#栈内存分配越大越好吗" class="headerlink" title="栈内存分配越大越好吗"></a>栈内存分配越大越好吗</h3><p>未必，默认的栈内存通常为1024k。</p><p>机器总内存一定，栈帧过大会导致线程数变少。</p><p>（<em>例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半。</em>）</p><h3 id="方法内的局部变量是否线程安全"><a href="#方法内的局部变量是否线程安全" class="headerlink" title="方法内的局部变量是否线程安全"></a>方法内的局部变量是否线程安全</h3><ul><li>如果方法内局部变量没有逃离方法的作用范围，它就是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250211205432572.png" alt="image-20250211205432572" style="zoom: 67%;"><h3 id="什么情况下会导致栈内存溢出"><a href="#什么情况下会导致栈内存溢出" class="headerlink" title="什么情况下会导致栈内存溢出"></a>什么情况下会导致栈内存溢出</h3><ul><li>栈帧过多导致内存溢出，典型问题：递归调用</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="堆栈的区别是什么"><a href="#堆栈的区别是什么" class="headerlink" title="堆栈的区别是什么"></a>堆栈的区别是什么</h3><ul><li>栈内存一般用来存储局部变量和方法调用；堆内存用来存储java对象和数组的。堆会GC垃圾回收，而栈不会。</li><li>栈内存是线程私有的，而堆内存是线程共有的，需要考虑线程安全的问题。</li><li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。<ul><li>栈空间不足：java.lang.StackOverFlowError</li><li>堆空间不足：java.lang.OutOfMemoryError</li></ul></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h3><p>JVM只会运行二进制文件，类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>，从而让Java程序能够启动起来。</p><h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><ul><li>启动类加载器（BootStrap ClassLoader）：加载JAVA_HOME&#x2F;jre&#x2F;lib目录下的库，由C++编写。</li><li>扩展类加载器（ExtClassLoader）：主要加载JAVA__HOME&#x2F;jre&#x2F;lib&#x2F;ext目录中的类。</li><li>应用类加载器（AppClassLoader）：用于加载classPath下的类，加载开发者自己编写的Java类。</li><li>自定义类加载器（CustomizeClassLoader）：自定义类继承ClassLoader，实现自定义类加载规则。</li></ul><h3 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h3><p>加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。</p><h3 id="JVM为什么采用双亲委派机制"><a href="#JVM为什么采用双亲委派机制" class="headerlink" title="JVM为什么采用双亲委派机制"></a>JVM为什么采用双亲委派机制</h3><ol><li><p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</p></li><li><p>为了安全，保证类库API不会被修改。</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250213204633494.png" alt="image-20250213204633494"></p></li></ol><h3 id="说一下类装载的执行过程"><a href="#说一下类装载的执行过程" class="headerlink" title="说一下类装载的执行过程"></a>说一下类装载的执行过程</h3><p>类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备、解析这三个部分统称为连接（linking）</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250213212051881.png" alt="image-20250213212051881"></p><ul><li><p>加载：查找和导入class文件</p><ul><li>通过类的全名，获取类的二进制数据流</li><li>将类的二进制数据流解析为方法区内的数据结构（Java类模型）</li><li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250213210130132.png" alt="image-20250213210130132"></p></li><li><p>验证：验证类是否符合JVM规范，安全性检查</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证——前三项是格式检查，如：文件格式是否错误、语法是否错误、字节码是否合规</li><li>符号引用验证——Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法，检查它们是否存在</li></ul></li><li><p>准备：为类变量分配内存并设置类变量初始值</p><ul><li>static变量：分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li><li>static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成</li><li>static变量是final的引用类型，那么赋值也会在初始化阶段完成</li></ul></li><li><p>解析：把类中的符号引用转换为直接引用</p><ul><li>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法</li></ul></li><li><p>初始化：对类的静态变量、静态代码块执行初始化操作</p><ul><li>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行</li><li>子类访问父类静态变量时，只触发父类初始化</li></ul></li><li><p>使用：JVM开始从入口方法开始执行用户的程序代码</p><ul><li>调用静态类成员信息（比如：静态字段、静态方法）</li><li>使用new关键字为其创建对象实例</li></ul></li><li><p>卸载：用户程序代码执行完毕后，JVM销毁创建的class对象</p></li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="对象什么时候可以被垃圾器回收"><a href="#对象什么时候可以被垃圾器回收" class="headerlink" title="对象什么时候可以被垃圾器回收"></a>对象什么时候可以被垃圾器回收</h3><p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p><p>如果要定位什么是垃圾，有两种方法来确定，第一个是<strong>引用计数法</strong>，第二个是<strong>可达性分析算法</strong>。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。</p><p><em>当对象间出现了循环引用的话，则引用计数法就会失效。</em></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213019744.png" alt="image-20250217213019744"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><strong>现在的虚拟机</strong>采用的都是通过可达性分析算法来确定哪些内容是垃圾。</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213130128.png" alt="image-20250217213130128"></p><h5 id="哪些对象可以作为GC-Root？"><a href="#哪些对象可以作为GC-Root？" class="headerlink" title="哪些对象可以作为GC Root？"></a>哪些对象可以作为GC Root？</h5><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213407762.png" alt="image-20250217213407762"></p></li><li><p>方法区中类静态属性引用的对象</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213426195.png" alt="image-20250217213426195"></p></li><li><p>方法区中常量引用的对象</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213521467.png" alt="image-20250217213521467"></p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li></ul><h3 id="JVM垃圾回收算法有哪些"><a href="#JVM垃圾回收算法有哪些" class="headerlink" title="JVM垃圾回收算法有哪些"></a>JVM垃圾回收算法有哪些</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>是将垃圾回收分为两个阶段，分别是<strong>标记和清除</strong></p><ol><li>根据可达性分析算法得出的垃圾进行标记</li><li>对这些标记为可回收的内容进行垃圾分类</li></ol><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213938828.png" alt="image-20250217213938828" style="zoom: 67%;"><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217213958971.png" alt="image-20250217213958971" style="zoom:67%;"><p><strong>优点</strong>：标记和清除速度较快</p><p><strong>缺点</strong>：磁盘碎片化较为严重，内存不连贯</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217214044871.png" alt="image-20250217214044871" style="zoom:67%;"><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217214051577.png" alt="image-20250217214051577" style="zoom:67%;"><p>优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记整理算法多了一步——对象移动内存位置的步骤，其效率也有一定的影响。</p><p><em>一般老年代回收器使用标记整理算法</em></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将原有的内存一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。</p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217214235817.png" alt="image-20250217214235817" style="zoom:67%;"><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217214243198.png" alt="image-20250217214243198" style="zoom:50%;"><p><strong>优点</strong>：</p><ul><li><p>在垃圾对象多的情况下，效率较高</p></li><li><p>清理后，内存无碎片</p></li></ul><p><strong>缺点</strong>：</p><ul><li>分配的两块内存空间，在同一时刻，只能使用一半，内存使用率较低</li></ul><h3 id="说一下JVM中的分代回收"><a href="#说一下JVM中的分代回收" class="headerlink" title="说一下JVM中的分代回收"></a>说一下JVM中的分代回收</h3><h4 id="堆的区域划分"><a href="#堆的区域划分" class="headerlink" title="堆的区域划分"></a>堆的区域划分</h4><p>在java8中，堆被分为两份：<strong>新生代和老年代（1：2）</strong></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217220820817.png" alt="image-20250217220820817"></p><h4 id="分代回收算法的工作机制-回收策略"><a href="#分代回收算法的工作机制-回收策略" class="headerlink" title="分代回收算法的工作机制&#x2F;回收策略"></a>分代回收算法的工作机制&#x2F;回收策略</h4><ul><li>新创建的对象，都会先分配到eden区</li><li>当伊甸园内存不足，标记伊甸园与from（现阶段没有）的存活对象</li><li>将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和from内存都得到释放</li><li>经过一段时间后伊甸园的内存又出现不足，标记eden区域和to区存活的对象，将存活的对象复制到from区</li><li>当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ul><h4 id="MinorGC、Mixed-GC、FullGC的区别是什么"><a href="#MinorGC、Mixed-GC、FullGC的区别是什么" class="headerlink" title="MinorGC、Mixed GC、FullGC的区别是什么"></a>MinorGC、Mixed GC、FullGC的区别是什么</h4><ul><li>MinorGC（young GC）：发生在新生代的垃圾回收，暂停时间短（STW）</li><li>Mixed GC：新生代+老年代部分区域的垃圾回收，G1收集器特有</li><li>FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免，一般发生在新生代和老年代内存严重不足时</li></ul><p><strong>名称解释</strong>：<strong>STW</strong>（Stop-The-World）：暂停所有应用程序线程，等待垃圾回收的完成。</p><h3 id="说一下JVM有哪些垃圾回收器"><a href="#说一下JVM有哪些垃圾回收器" class="headerlink" title="说一下JVM有哪些垃圾回收器"></a>说一下JVM有哪些垃圾回收器</h3><p>在jvm中，实现了多种垃圾收集器，包括：</p><ul><li><p>串行垃圾收集器</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217222218640.png" alt="image-20250217222218640"></p></li><li><p>并行垃圾收集器</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217222316550.png" alt="image-20250217222316550"></p></li><li><p>CMS（并发）垃圾收集器</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217222516085.png" alt="image-20250217222516085"></p><p>初始标记与GC Root相连的，并发标记其他间接连接的，重新标记发生变化的。优点：时间短、效率高。</p></li><li><p>G1垃圾收集器：作用在新生代和老年代</p></li></ul><h3 id="详细聊一下G1垃圾回收器"><a href="#详细聊一下G1垃圾回收器" class="headerlink" title="详细聊一下G1垃圾回收器"></a>详细聊一下G1垃圾回收器</h3><ul><li><p>应用于新生代和老年代，<strong>在JDK9之后默认使用G1</strong></p></li><li><p>划分成多个区域，每个区域都可以充当eden、survivor、old、humongous（巨型对象区），其中humongous专为大对象准备</p></li><li><p>采用复制算法</p></li><li><p>响应时间与吞吐量兼顾</p></li><li><p>分为三个阶段：新生代回收、并发标记、混合收集</p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217224126790.png" alt="image-20250217224126790" style="zoom:50%;"></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发Full GC</p></li></ul><h4 id="Young-Collection（年轻代垃圾回收）"><a href="#Young-Collection（年轻代垃圾回收）" class="headerlink" title="Young Collection（年轻代垃圾回收）"></a>Young Collection（年轻代垃圾回收）</h4><ul><li>初始时，所有区域都处于空闲状态</li><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，<strong>需要暂停用户线程</strong></li><li>随着时间流逝，伊甸园的内存又有不足</li><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ul><h4 id="Young-Collection-Concurrent-Mark（年轻代垃圾回收-并发标记）"><a href="#Young-Collection-Concurrent-Mark（年轻代垃圾回收-并发标记）" class="headerlink" title="Young Collection + Concurrent Mark（年轻代垃圾回收 + 并发标记）"></a>Young Collection + Concurrent Mark（年轻代垃圾回收 + 并发标记）</h4><ul><li>当老年代占用内存超过阈值（默认是45%）后，触发<strong>并发标记</strong>，这时<strong>无需暂停用户进程</strong>（并发标记之后的重新标记需要STW）</li><li>并发标记之后，会有<strong>重新标记</strong>阶段解决漏标问题，此时<strong>需要暂停用户线程</strong></li><li>这些都完成后就知道了老年代有哪些存活的对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是Gabage First名称的由来）</li></ul><h4 id="Mixed-Collection（混合垃圾回收）"><a href="#Mixed-Collection（混合垃圾回收）" class="headerlink" title="Mixed Collection（混合垃圾回收）"></a>Mixed Collection（混合垃圾回收）</h4><ul><li>混合收集阶段中，参与复制的有eden、survivor、old</li><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>如果一个对象太大了，一个区域装不下，会存储到一个巨型对象中，一个区域不够的话，会分配一个连续的区域去存储巨型对象。</p><h3 id="强引用、软引用、弱引用、虚对象"><a href="#强引用、软引用、弱引用、虚对象" class="headerlink" title="强引用、软引用、弱引用、虚对象"></a>强引用、软引用、弱引用、虚对象</h3><ul><li><p><strong>强引用</strong>：只有所有GC Roots对象都不通过<strong>强引用</strong>引用该对象，该对象才能被垃圾回收</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217230501489.png" alt="image-20250217230501489"></p></li><li><p><strong>软引用</strong>：仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收（当垃圾多次回收，内存仍然不够时回收软引用对象）</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217230627264.png" alt="image-20250217230627264"></p></li><li><p><strong>弱引用</strong>：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象（只要进行垃圾回收，就会把弱引用对象回收）</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217230810557.png" alt="image-20250217230810557"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217230857727.png" alt="image-20250217230857727"></p></li><li><p><strong>虚引用</strong>：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250217231154459.png" alt="image-20250217231154459"></p><p><em>软引用和弱引用也可以通过引用队列去释放自身的资源</em></p></li></ul><h2 id="JVM实战"><a href="#JVM实战" class="headerlink" title="JVM实战"></a>JVM实战</h2><h3 id="JVM调优的参数可以在哪里设置"><a href="#JVM调优的参数可以在哪里设置" class="headerlink" title="JVM调优的参数可以在哪里设置"></a>JVM调优的参数可以在哪里设置</h3><ul><li><p>war包部署，在tomcat中设置</p><ul><li><p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250220112341929.png" alt="image-20250220112341929"></p></li></ul></li><li><p>jar包部署，在启动参数设置</p><ul><li><p>通常在linux系统下直接加参数启动SpringBoot项目</p><ul><li>java -Xms512m -Xmx1024m -jar xxxx.jar</li></ul><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250220112445113.png" alt="image-20250220112445113"></p><p>nohup：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行</p><p>参数&amp;：让命令在后台执行，终端退出后命令仍然执行</p></li></ul></li></ul><h3 id="用的JVM调优的参数都有哪些"><a href="#用的JVM调优的参数都有哪些" class="headerlink" title="用的JVM调优的参数都有哪些"></a>用的JVM调优的参数都有哪些</h3><p>对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。</p><ul><li><strong>设置堆空间的大小</strong><ul><li>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置成相同的值</li><li>-Xms：设置堆的初始化大小</li><li>-Xmx：设置堆的最大大小</li><li><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221145608743.png" alt="image-20250221145608743"></li><li>堆空间设置多少合适？<ul><li>最大大小的默认值是物理内存的1&#x2F;4，初始大小是物理内存的1&#x2F;64</li><li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户进程</li><li>堆内存大肯定是好的，存在风险，假如发生了fullGC，它会扫描整个堆空间，暂停用户线程的时间特别长</li><li>设置参考推荐：尽量大，也要考察一下当前计算机其他程序的内存使用情况</li></ul></li></ul></li><li><strong>虚拟机栈的设置</strong><ul><li><strong>每个线程默认会开启1M的内存</strong>，用于存放栈帧、调用参数、局部变量等，但一般256k就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。</li><li>-Xss：对每个线程stack大小的调整。-Xss128k</li></ul></li><li><strong>年轻代中Eden区和两个Survivor区的大小比例</strong><ul><li>默认为8:1:1。通过增大Eden区的大小来减少YGC发生的次数，但有时虽然次数减少，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。</li><li><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221150632902.png" alt="image-20250221150632902"></li></ul></li><li><strong>年轻代晋升老年代的阈值</strong><ul><li><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221150722128.png" alt="image-20250221150722128"></li><li>默认为15</li><li>取值范围是0—15</li></ul></li><li><strong>设置垃圾回收收集器</strong><ul><li>通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。</li><li><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221150830843.png" alt="image-20250221150830843" style="zoom:67%;"></li></ul></li></ul><h3 id="说一下JVM调优的工具"><a href="#说一下JVM调优的工具" class="headerlink" title="说一下JVM调优的工具"></a>说一下JVM调优的工具</h3><ul><li><p>命令工具</p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221154235750.png" alt="image-20250221154235750" style="zoom:67%;"><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221155739277.png" alt="image-20250221155739277" style="zoom:80%;"><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221155832498.png" alt="image-20250221155832498"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221155935148.png" alt="image-20250221155935148"></p></li><li><p>可视化工具</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221154253575.png" alt="image-20250221154253575"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160053981.png" alt="image-20250221160053981" style="zoom:50%;"><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160105839.png" alt="image-20250221160105839" style="zoom:50%;"></p></li></ul><h3 id="Java内存泄漏的排查思路"><a href="#Java内存泄漏的排查思路" class="headerlink" title="Java内存泄漏的排查思路"></a>Java内存泄漏的排查思路</h3><p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况。</p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160351684.png" alt="image-20250221160351684"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160508328.png" alt="image-20250221160508328"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160648244.png" alt="image-20250221160648244"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160811185.png" alt="image-20250221160811185"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160839186.png" alt="image-20250221160839186"></p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221160852461.png" alt="image-20250221160852461" style="zoom:67%;"><h3 id="CPU飙高排查方案与思路"><a href="#CPU飙高排查方案与思路" class="headerlink" title="CPU飙高排查方案与思路"></a>CPU飙高排查方案与思路</h3><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221161214059.png" alt="image-20250221161214059"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221161222351.png" alt="image-20250221161222351"></p><p><img src="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/image-20250221161252299.png" alt="image-20250221161252299"></p><p>（<em>第三步中拿到的进程是十进制，第四步中展示的是十六进制，需要进行进制转换。</em>）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><h2 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h2><p>根据 JVM8 规范，JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1713516291293-ce6ee4e7-c5a6-4395-9ee7-4ec1c014b206.webp" alt="img"></p><p>JVM的内存结构主要分为以下几个部分：</p><ul><li><strong>元空间</strong>：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</li><li><strong>Java 虚拟机栈</strong>：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。</li><li><strong>本地方法栈</strong>：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。</li><li><strong>程序计数器</strong>：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。</li><li><strong>堆内存</strong>：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。</li><li><strong>直接内存</strong>：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input&#x2F;Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I&#x2F;O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li></ul><h2 id="JVM内存模型里的堆和栈有什么区别"><a href="#JVM内存模型里的堆和栈有什么区别" class="headerlink" title="JVM内存模型里的堆和栈有什么区别"></a>JVM内存模型里的堆和栈有什么区别</h2><ul><li><strong>用途</strong>：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括类的实例和数组）。当你使用new关键字创建一个对象时，对象的实例就会在堆上分配空间。</li><li><strong>生命周期</strong>：栈中的数据具有确定的生命周期，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。</li><li><strong>存取速度</strong>：栈的存取速度通常比堆快，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。</li><li><strong>存储空间</strong>：栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。</li><li><strong>可见性</strong>：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。</li></ul><h2 id="栈中存的到底是指针还是对象"><a href="#栈中存的到底是指针还是对象" class="headerlink" title="栈中存的到底是指针还是对象"></a>栈中存的到底是指针还是对象</h2><p>在JVM内存模型中，栈（Stack）主要用于管理线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例和数组。</p><p>当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。</p><p>这里的关键点是，栈中存储的<strong>不是</strong>对象，而是<strong>对象的引用</strong>。也就是说，当你在方法中声明一个对象，比如MyObject obj &#x3D; new MyObject();，这里的obj实际上是一个存储在栈上的引用，指向堆中实际的对象实例。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。</p><h2 id="堆分为哪几部分"><a href="#堆分为哪几部分" class="headerlink" title="堆分为哪几部分"></a>堆分为哪几部分</h2><p>Java堆（Heap）是Java虚拟机（JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt="img"></p><ul><li><strong>新生代（Young Generation）</strong>:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</li><li><strong>老年代（Old Generation&#x2F;Tenured Generation）</strong>:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。</li><li><strong>元空间（Metaspace）</strong>:从Java 8开始，永久代（Permanent Generation）被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。</li><li><strong>大对象区（Large Object Space &#x2F; Humongous Objects）</strong>:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。</li></ul><h2 id="程序计数器的作用，为什么是私有的"><a href="#程序计数器的作用，为什么是私有的" class="headerlink" title="程序计数器的作用，为什么是私有的"></a>程序计数器的作用，为什么是私有的</h2><p>Java程序是支持多线程一起运行的，多个线程一起运行的时候cpu会有一个调动器组件给它们分配时间片，比如：先给线程1一个时间片，它在时间片内如果代码没有执行完，它就会把线程1的状态执行一个暂存，切换到线程2去，执行线程2的代码，等线程2的代码执行到了一定程度，线程2的时间片用完了，再切换回来，再继续执行线程1剩余部分的代码。</p><p>由于在线程切换的过程中，需要知道下一条指令执行到哪里了，所以还会用到程序计数器，因为它们各自执行的代码的指令地址是不一样的，所以每个线程都有自己的程序计数器。</p><h2 id="方法区中的方法的执行过程"><a href="#方法区中的方法的执行过程" class="headerlink" title="方法区中的方法的执行过程"></a>方法区中的方法的执行过程</h2><p>当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：</p><ul><li><strong>解析方法调用</strong>：JVM会根据方法的符号引用找到实际的方法地址（如果之前没有解析过的话）。</li><li><strong>栈帧创建</strong>：在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li><strong>执行方法</strong>：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。</li><li><strong>返回处理</strong>：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。</li></ul><h2 id="方法区中还有哪些东西"><a href="#方法区中还有哪些东西" class="headerlink" title="方法区中还有哪些东西"></a>方法区中还有哪些东西</h2><p>它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><ul><li>类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。</li><li>常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。</li><li>静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。</li><li>方法字节码：存储类的方法字节码，即编译后的代码。</li><li>符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。</li><li>运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。</li><li>常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。</li></ul><h2 id="String保存在哪里"><a href="#String保存在哪里" class="headerlink" title="String保存在哪里"></a>String保存在哪里</h2><p>String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享。</p><h2 id="String-s-new-String（“abc”）执行过程中分别对应哪些内存区域"><a href="#String-s-new-String（“abc”）执行过程中分别对应哪些内存区域" class="headerlink" title="String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域"></a>String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域</h2><p>首先，<strong>new</strong>指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在<strong>运行期</strong>才能确定的，创建的字符串对象是在<strong>堆内存上</strong>。</p><p>其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量”abc”去字符串常量池试图获取其对应String对象的引用。于是在堆中创建了一个”abc”的String对象，并将其引用保存到字符串常量池中，然后返回。</p><p>所以，<strong>如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及new String这个实例对象。如果abc这字符串常量存在，则只会创建一个对象</strong>。</p><h2 id="引用类型有哪些，有什么区别"><a href="#引用类型有哪些，有什么区别" class="headerlink" title="引用类型有哪些，有什么区别"></a>引用类型有哪些，有什么区别</h2><p>引用类型主要分为强软弱虚四种：</p><ul><li>强引用指的就是代码中普遍存在的赋值方式，比如A a &#x3D; new A()这种。强引用关联的对象，永远不会被GC回收。</li><li>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</li><li>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</li><li>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</li></ul><h2 id="什么是弱引用，举例说明哪里可以用"><a href="#什么是弱引用，举例说明哪里可以用" class="headerlink" title="什么是弱引用，举例说明哪里可以用"></a>什么是弱引用，举例说明哪里可以用</h2><p>Java中的弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。</p><p>在Java中，弱引用是通过java.lang.ref.WeakReference类实现的。弱引用的一个主要用途是创建非强制性的对象引用，这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。</p><p>弱引用的使用场景：</p><ul><li><strong>缓存系统</strong>：弱引用常用于实现缓存，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。</li><li><strong>对象池</strong>：在对象池中，弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。</li><li><strong>避免内存泄露</strong>：当一个对象不应该被长期引用时，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。</li></ul><p>示例代码：</p><p>假设我们有一个缓存系统，我们使用弱引用来维护缓存中的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;MyHeavyObject&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyHeavyObject <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;MyHeavyObject&gt; ref = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ref.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MyHeavyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeavyObject</span>();</span><br><span class="line">            cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设MyHeavyObject是一个占用大量内存的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHeavyObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] largeData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10MB data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用WeakReference来存储MyHeavyObject实例，当内存压力增大时，垃圾回收器可以自由地回收这些对象，而不会影响缓存的正常运行。</p><p>如果一个对象被垃圾回收，下次尝试从缓存中获取时，get()方法会返回null，这时我们可以重新创建对象并将其放入缓存中。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为null，因此在使用前通常需要检查这一点。</p><h2 id="内存泄漏和内存溢出的理解"><a href="#内存泄漏和内存溢出的理解" class="headerlink" title="内存泄漏和内存溢出的理解"></a>内存泄漏和内存溢出的理解</h2><p><strong>内存泄露</strong>：内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。</p><p>内存泄露常见原因：</p><ul><li><strong>静态集合</strong>：使用静态数据结构（如HashMap或ArrayList）存储对象，且未清理。</li><li><strong>事件监听</strong>：未取消对事件源的监听，导致对象持续被引用。</li><li><strong>线程</strong>：未停止的线程可能持有对象引用，无法被回收。</li></ul><p><strong>内存溢出</strong>：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发OutOfMemoryError。这通常发生在堆内存不足以存放新创建的对象时。</p><p>内存溢出常见原因：</p><ul><li><strong>大量对象创建</strong>：程序中不断创建大量对象，超出JVM堆的限制。</li><li><strong>持久引用</strong>：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。</li><li><strong>递归调用</strong>：深度递归导致栈溢出。</li></ul><h2 id="JVM内存结构有哪几种内存溢出的情况"><a href="#JVM内存结构有哪几种内存溢出的情况" class="headerlink" title="JVM内存结构有哪几种内存溢出的情况"></a>JVM内存结构有哪几种内存溢出的情况</h2><ul><li><strong>堆内存溢出</strong>：当出现java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是代码中可能存在大对象分配，或者发生了内存泄露，导致在多次GC（Garbage Collection，垃圾收集）之后，还是无法找到一块足够大的内存容纳当前对象。</li><li><strong>栈溢出</strong>：如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</li><li><strong>元空间溢出</strong>：元空间的溢出，系统会抛出java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。</li><li><strong>直接内存内存溢出</strong>：在使用ByteBuffer中的allocateDirect()的时候会用到，很多javaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出java.lang.OutOfMemoryError: Direct buffer memory异常。</li></ul><h2 id="有具体的内存泄漏和内存溢出的例子么请举例及解决方案"><a href="#有具体的内存泄漏和内存溢出的例子么请举例及解决方案" class="headerlink" title="有具体的内存泄漏和内存溢出的例子么请举例及解决方案"></a>有具体的内存泄漏和内存溢出的例子么请举例及解决方案</h2><h3 id="静态属性导致内存泄露"><a href="#静态属性导致内存泄露" class="headerlink" title="静态属性导致内存泄露"></a>静态属性导致内存泄露</h3><p>会导致内存泄露的一种情况就是大量使用static静态变量。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240820112907539.png" alt="image-20240820112907539"></p><p>但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化。VisualVM监控信息如下图：</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240820112851893.png" alt="image-20240820112851893"></p><p>对比两个图可以看出，程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。</p><p>那么如何优化呢？第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。</p><h3 id="未关闭的资源"><a href="#未关闭的资源" class="headerlink" title="未关闭的资源"></a>未关闭的资源</h3><p>无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。</p><p>忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。</p><p>如果进行处理呢？第一，始终记得在finally中进行资源的关闭；第二，关闭连接的自身代码不能发生异常；第三，Java7以上版本可使用try-with-resources代码方式进行资源关闭。</p><h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><p>ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定，从而实现线程安全的特性。</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240820112835783.png" alt="image-20240820112835783"></p><p>ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。</p><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p><p>如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><h3 id="如何解决此问题"><a href="#如何解决此问题" class="headerlink" title="如何解决此问题"></a>如何解决此问题</h3><ul><li>使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除；</li><li>不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是查找与当前线程关联的Map并将键值对分别设置为当前线程和null。</li><li>最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类初始化和类加载"><a href="#类初始化和类加载" class="headerlink" title="类初始化和类加载"></a>类初始化和类加载</h1><h2 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h2><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp" alt="img">在Java中创建对象的过程包括以下几个步骤：</p><ol><li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li><li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li><li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</li></ol><h2 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h2><p>对象的生命周期包括创建、使用和销毁三个阶段：</p><ul><li>创建：对象通过关键字new在堆内存中被实例化，构造函数被调用，对象的内存空间被分配。</li><li>使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。</li><li>销毁：当对象不再被引用时，通过垃圾回收机制自动回收对象所占用的内存空间。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。</li></ul><h2 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h2><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt="img"></p><ul><li><strong>启动类加载器（Bootstrap Class Loader）</strong>：这是最顶层的类加载器，负责加载Java的核心库（如位于jre&#x2F;lib&#x2F;rt.jar中的类），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。</li><li><strong>扩展类加载器（Extension Class Loader）</strong>：它是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录（jre&#x2F;lib&#x2F;ext或由系统变量java.ext.dirs指定的目录）下的jar包和类库。扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。</li><li><strong>系统类加载器（System Class Loader）&#x2F; 应用程序类加载器（Application Class Loader）</strong>：这也是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。</li><li><strong>自定义类加载器（Custom Class Loader）</strong>：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。</li></ul><p>这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</p><p>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><h2 id="双亲委派模型的作用"><a href="#双亲委派模型的作用" class="headerlink" title="双亲委派模型的作用"></a>双亲委派模型的作用</h2><ul><li><strong>保证类的唯一性</strong>：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。</li><li><strong>保证安全性</strong>：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。</li><li><strong>支持隔离和层次划分</strong>：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。</li><li><strong>简化了加载流程</strong>：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。</li></ul><h2 id="讲一下类加载过程"><a href="#讲一下类加载过程" class="headerlink" title="讲一下类加载过程"></a>讲一下类加载过程</h2><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp" alt="img"></p><ul><li><strong>加载</strong>：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li><strong>连接</strong>：验证、准备、解析 3 个阶段统称为连接。<ul><li><strong>验证</strong>：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证</li><li><strong>准备</strong>：为类中的静态字段分配内存，并设置默认的初始值，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了</li><li><strong>解析</strong>：解析阶段是虚拟机将常量池的「符号引用」直接替换为「直接引用」的过程。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</li></ul></li><li><strong>初始化</strong>：初始化是整个类加载过程的最后一个阶段，初始化阶段简单来说就是执行类的构造器方法（() ），要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。</li><li><strong>使用</strong>：使用类或者创建对象</li><li><strong>卸载</strong>：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="讲一下类的加载和双亲委派原则"><a href="#讲一下类的加载和双亲委派原则" class="headerlink" title="讲一下类的加载和双亲委派原则"></a>讲一下类的加载和双亲委派原则</h2><p>我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化。</p><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ul><li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li><li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li><li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。</li></ul><p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="什么是Java里的垃圾回收，如何触发垃圾回收"><a href="#什么是Java里的垃圾回收，如何触发垃圾回收" class="headerlink" title="什么是Java里的垃圾回收，如何触发垃圾回收"></a>什么是Java里的垃圾回收，如何触发垃圾回收</h2><p>垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：</p><ul><li><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。</li><li><strong>手动请求</strong>：虽然垃圾回收是自动的，开发者可以通过调用 System.gc() 或 Runtime.getRuntime().gc() 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。</li><li><strong>JVM参数</strong>：启动 Java 应用时可以通过 JVM 参数来调整垃圾回收的行为，比如：-Xmx（最大堆大小）、-Xms（初始堆大小）等。</li><li><strong>对象数量或内存使用达到阈值</strong>：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。</li></ul><h2 id="判断垃圾的方法有哪些"><a href="#判断垃圾的方法有哪些" class="headerlink" title="判断垃圾的方法有哪些"></a>判断垃圾的方法有哪些</h2><p>在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：<strong>引用计数法和可达性分析算法</strong>。</p><h3 id="引用计数法（Reference-Counting）"><a href="#引用计数法（Reference-Counting）" class="headerlink" title="引用计数法（Reference Counting）"></a>引用计数法（Reference Counting）</h3><ul><li><strong>原理</strong>：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。</li><li><strong>缺点</strong>：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</li></ul><h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png" alt="img"></p><p>Java虚拟机主要采用此算法来判断对象是否为垃圾。</p><ul><li><strong>原理</strong>：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。GC Roots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等。</li></ul><h2 id="垃圾回收算法是什么，是为了解决了什么问题"><a href="#垃圾回收算法是什么，是为了解决了什么问题" class="headerlink" title="垃圾回收算法是什么，是为了解决了什么问题"></a>垃圾回收算法是什么，是为了解决了什么问题</h2><p>JVM有垃圾回收机制的原因是为了解决内存管理的问题。在传统的编程语言中，开发人员需要手动分配和释放内存，这可能导致内存泄漏、内存溢出等问题。而Java作为一种高级语言，旨在提供更简单、更安全的编程环境，因此引入了垃圾回收机制来自动管理内存。</p><p>垃圾回收机制的主要目标是<strong>自动检测</strong>和<strong>回收</strong>不再使用的对象，从而释放它们所占用的内存空间。这样可以避免内存泄漏（一些对象被分配了内存却无法被释放，导致内存资源的浪费）。同时，垃圾回收机制还可以防止内存溢出（即程序需要的内存超过了可用内存的情况）。</p><p>通过垃圾回收机制，JVM可以在程序运行时自动识别和清理不再使用的对象，使得开发人员无需手动管理内存。这样可以提高开发效率、减少错误，并且使程序更加可靠和稳定。</p><h2 id="垃圾回收算法有哪些"><a href="#垃圾回收算法有哪些" class="headerlink" title="垃圾回收算法有哪些"></a>垃圾回收算法有哪些</h2><ul><li><strong>标记-清除算法</strong>：标记-清除算法分为“标记”和“清除”两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。</li><li><strong>复制算法</strong>：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。</li><li><strong>标记-整理算法</strong>：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。</li><li><strong>分代回收算法</strong>：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。</li></ul><h2 id="垃圾回收器有哪些"><a href="#垃圾回收器有哪些" class="headerlink" title="垃圾回收器有哪些"></a>垃圾回收器有哪些</h2><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png" alt="img"></p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代</li></ul><h2 id="标记清除算法的缺点是什么"><a href="#标记清除算法的缺点是什么" class="headerlink" title="标记清除算法的缺点是什么"></a>标记清除算法的缺点是什么</h2><p>主要缺点有两个：</p><ul><li>一个是效率问题，标记和清除过程的效率都不高；</li><li>另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="垃圾回收算法哪些阶段会stop-the-world"><a href="#垃圾回收算法哪些阶段会stop-the-world" class="headerlink" title="垃圾回收算法哪些阶段会stop the world"></a>垃圾回收算法哪些阶段会stop the world</h2><p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p><ul><li>标记阶段，即从GC Roots集合开始，标记活跃对象；</li><li>转移阶段，即把活跃对象复制到新的内存地址上；</li><li>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</li></ul><p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：</p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1718783586342-9da40db7-1dac-42ec-8148-81c10d8bfc04.png" alt="img"></p><p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p><p><strong>标记阶段停顿分析</strong></p><ul><li>初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</li><li>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</li><li>再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</li></ul><p><strong>清理阶段停顿分析</strong></p><ul><li>清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</li></ul><p><strong>复制阶段停顿分析</strong></p><ul><li>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</li></ul><p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。</p><p>因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。</p><h2 id="minor-GC、major-GC、full-GC的区别，什么场景触发full-GC"><a href="#minor-GC、major-GC、full-GC的区别，什么场景触发full-GC" class="headerlink" title="minor GC、major GC、full GC的区别，什么场景触发full GC"></a>minor GC、major GC、full GC的区别，什么场景触发full GC</h2><p>在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：</p><h3 id="Minor-GC-Young-GC"><a href="#Minor-GC-Young-GC" class="headerlink" title="Minor GC (Young GC)"></a>Minor GC (Young GC)</h3><ul><li><strong>作用范围</strong>：只针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。</li><li><strong>触发条件</strong>：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。</li><li><strong>特点</strong>：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。</li></ul><h3 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h3><ul><li><strong>作用范围</strong>：主要针对老年代进行回收，但不一定只回收老年代。</li><li><strong>触发条件</strong>：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。</li><li><strong>特点</strong>：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。</li></ul><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><ul><li><strong>作用范围</strong>：对整个堆内存（包括年轻代、老年代以及永久代&#x2F;元空间）进行回收。</li><li><strong>触发条件</strong>：<ul><li>直接调用System.gc()或Runtime.getRuntime().gc()方法时，虽然不能保证立即执行，但JVM会尝试执行Full GC。</li><li>Minor GC（新生代垃圾回收）时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。</li><li>当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。</li></ul></li><li><strong>特点</strong>：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。</li></ul><h2 id="垃圾回收器-CMS-和-G1的区别"><a href="#垃圾回收器-CMS-和-G1的区别" class="headerlink" title="垃圾回收器 CMS 和 G1的区别"></a>垃圾回收器 CMS 和 G1的区别</h2><p><strong>区别一：使用的范围不一样：</strong></p><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用</li><li>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</li></ul><p><strong>区别二：STW的时间：</strong></p><ul><li>CMS收集器以最小的停顿时间为目标的收集器。</li><li>G1收集器可预测垃圾回收 (opens new window)的停顿时间（建立可预测的停顿时间模型）</li></ul><p><strong>区别三： 垃圾碎片</strong></p><ul><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，没有内存空间碎片。</li></ul><p><strong>区别四： 垃圾回收的过程不一样</strong></p><p><img src="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png" alt="img"></p><p>注意这两个收集器第四阶段得不同</p><p><strong>区别五: CMS会产生浮动垃圾</strong></p><ul><li>CMS产生浮动垃圾过多时会退化为serial old，效率低，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾</li><li>而G1没有浮动垃圾，G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。</li></ul><h2 id="什么情况下使用CMS，什么情况下使用G1"><a href="#什么情况下使用CMS，什么情况下使用G1" class="headerlink" title="什么情况下使用CMS，什么情况下使用G1"></a>什么情况下使用CMS，什么情况下使用G1</h2><h3 id="CMS适用场景："><a href="#CMS适用场景：" class="headerlink" title="CMS适用场景："></a>CMS适用场景：</h3><ul><li><strong>低延迟需求</strong>：适用于对停顿时间要求敏感的应用程序。</li><li><strong>老生代收集</strong>：主要针对老年代的垃圾回收。</li><li><strong>碎片化管理</strong>：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。</li></ul><h3 id="G1适用场景："><a href="#G1适用场景：" class="headerlink" title="G1适用场景："></a>G1适用场景：</h3><ul><li><strong>大堆内存</strong>：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。</li><li><strong>对内存碎片敏感</strong>：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。</li><li><strong>比较平衡的性能</strong>：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。</li></ul><h2 id="G1回收器的特色是什么"><a href="#G1回收器的特色是什么" class="headerlink" title="G1回收器的特色是什么"></a>G1回收器的特色是什么</h2><p><strong>G1 的特点：</strong></p><ul><li>G1最大的特点是引入分区的思路，弱化了分代的概念。</li><li>合理利用垃圾收集各个周期的资源，解决了其他收集器、甚至 CMS 的众多缺陷</li></ul><p><strong>G1 相比较 CMS 的改进：</strong></p><ul><li><strong>算法</strong>： G1 基于标记–整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。</li><li><strong>停顿时间可控</strong>： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li><li><strong>并行与并发</strong>：G1 能更充分的利用 CPU 多核环境下的硬件优势，来缩短 stop the world 的停顿时间。</li></ul><h2 id="GC只会对堆进行GC吗"><a href="#GC只会对堆进行GC吗" class="headerlink" title="GC只会对堆进行GC吗"></a>GC只会对堆进行GC吗</h2><p>JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。</p><ul><li><p><strong>堆（Heap）：</strong> 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。</p></li><li><p><strong>方法区（Method Area）：</strong> 方法区是用于存储类信息、常量、静态变量等数据的区域。虽然方法区中的垃圾回收与堆有所不同，但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发</title>
      <link href="/2024/11/04/web%E5%BC%80%E5%8F%91/"/>
      <url>/2024/11/04/web%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h1><h2 id="前端的代码如何转换成网页"><a href="#前端的代码如何转换成网页" class="headerlink" title="前端的代码如何转换成网页"></a>前端的代码如何转换成网页</h2><p>通过浏览器的<strong>内核</strong>转化（解析和渲染）成用户看到的网页</p><h2 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h2><ul><li>也叫网页标准，又一系列标准组成，大部分由W3C（World Wide Web Consortium，万维网联盟）负责制定。</li><li>三个组成部分：<ul><li>HTML：负责网页的<strong>结构</strong>（页面元素和内容）</li><li>CSS：负责网页的<strong>表现</strong>（页面元素的外观、位置等页面样式，如：颜色、大小等）</li><li>JavaScript：负责网页的<strong>行为</strong>（交互效果，如：轮播图）</li></ul></li></ul><h2 id="HTML、CSS"><a href="#HTML、CSS" class="headerlink" title="HTML、CSS"></a>HTML、CSS</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>HTML（HyperText Markup Language）：超文本标记语言</p><ul><li>超文本：超越了文本的限制，处理文字信息，还可以定义图片、音频、视频等内容</li><li>标记语言：由标签构成的语言<ul><li>HTML语言都是<strong>预定义</strong>好的，如：使用&lt;a&gt;展示超链接，&lt;img&gt;展示图片，&lt;video&gt;展示视频</li><li>HTML代码直接在浏览器中运行，HTML标签由浏览器解析</li></ul></li></ul></li><li><p>CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式（表现）。</p></li></ul><h3 id="HTML的结构标签示例"><a href="#HTML的结构标签示例" class="headerlink" title="HTML的结构标签示例"></a>HTML的结构标签示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello HTML<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML的一些语法特点"><a href="#HTML的一些语法特点" class="headerlink" title="HTML的一些语法特点"></a>HTML的一些语法特点</h3><ul><li>标签不区分大小写</li><li>标签的属性既可以使用双引号，也可以使用单引号</li><li>语法结构松散（语法不严格）</li></ul><h3 id="CSS引入方式"><a href="#CSS引入方式" class="headerlink" title="CSS引入方式"></a>CSS引入方式</h3><ul><li><p>行内样式（不推荐）：写在标签的style属性中</p><ul><li><p>只针对当前一个标签</p></li><li><p>格式：属性名：属性值；</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> style=&quot;xxx: xxx; xxx: xxx;&quot;&gt;标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定在head标签中）</p><ul><li>对于当前HTML文件的所有该标签都生效</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        xxx: xxx;</span></span><br><span class="line"><span class="language-css">        xxx :xxx;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外联样式：写在一个单独的.css文件中（通过link标签从网页中引入）(link写在&lt;head&gt;中)</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    xxx: xxx;</span><br><span class="line">    xxx: xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/news.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>用来选取需要设置样式的元素（标签）</p><ul><li>元素选择器：如上</li><li>id选择器：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#hid</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;hid&quot;</span>&gt;</span>CSS id Selector<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>类选择器</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cls</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>CSS class Selector<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优先级：id选择器 &gt; 类选择器 &gt; 元素选择器</strong></p><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p><strong>盒子</strong>：页面中所有的元素（标签），都可以看成一个盒子，由盒子将页面的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局。</p><p><strong>组成</strong>：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）</p><p>与&lt;div&gt;和&lt;span&gt;一起使用</p><h3 id="HTML实现"><a href="#HTML实现" class="headerlink" title="HTML实现"></a>HTML实现</h3><h4 id="图片标签："><a href="#图片标签：" class="headerlink" title="图片标签：&lt;img&gt;"></a>图片标签：&lt;img&gt;</h4><p>格式：&lt;img src&#x3D;”…” width&#x3D;”…” height&#x3D;”…”&gt;</p><ul><li><p>src：图片资源路径</p><ul><li>绝对路径<ul><li>绝对磁盘路径</li><li>绝对网络路径</li></ul></li><li>相对路径（推荐）：.&#x2F; ：当前目录（即HTML文件所在目录）（可省略）；..&#x2F; ：上一级目录</li></ul></li><li><p>width：宽度（px，像素；%，相对于父元素的百分比）</p></li><li><p>height：高度（一般高度和宽度只写一个，就可以等比例缩放）</p></li></ul><h4 id="标题标签："><a href="#标题标签：" class="headerlink" title="标题标签：&lt;h1&gt;"></a>标题标签：&lt;h1&gt;</h4><p><em>只有&lt;h1&gt; 到 &lt;h6&gt;</em></p><p>格式：&lt;h1&gt;……&lt;&#x2F;h1&gt;</p><h4 id="水平线标签："><a href="#水平线标签：" class="headerlink" title="水平线标签：&lt;hr&gt;"></a>水平线标签：&lt;hr&gt;</h4><p>格式：&lt;hr&gt;</p><p><em>只需写一个&lt;hr&gt;就可以</em></p><h4 id="无意义标签："><a href="#无意义标签：" class="headerlink" title="无意义标签：&lt;div&gt; &#x2F; &lt;span&gt;"></a>无意义标签：&lt;div&gt; &#x2F; &lt;span&gt;</h4><p>没有语义的布局标签，用于将不是任何标签的文字进行格式的修改</p><p>特点：</p><ul><li>&lt;div&gt;：一行只显示一个（独占一行）；宽度默认时父元素的宽度，高度默认由内容撑开；可以设置宽高</li><li>&lt;span&gt;：一行可以显示多个（组合行内元素）；宽度和高度默认由内容撑开；不可以设置宽高</li></ul><h4 id="超链接："><a href="#超链接：" class="headerlink" title="超链接：&lt;a&gt;"></a>超链接：&lt;a&gt;</h4><p>格式：&lt;a href&#x3D;”…” target&#x3D;”…”&gt;央视网&lt;&#x2F;a&gt;</p><p>属性：href：资源访问的url；target：在何处打开（_self：默认值，在当前页面；_blank：在空白页面打开）</p><p><em>超链接默认蓝色加下划线，如果想修改需要用text-decoration来修改</em></p><h4 id="视频标签："><a href="#视频标签：" class="headerlink" title="视频标签：&lt;video&gt;"></a>视频标签：&lt;video&gt;</h4><p>src：视频的url</p><p>controls：显示播放控件</p><p>width：宽度</p><p>height：高度</p><h4 id="音频标签："><a href="#音频标签：" class="headerlink" title="音频标签：&lt;audio&gt;"></a>音频标签：&lt;audio&gt;</h4><p>src：音频的url</p><p>controls：显示播放控件</p><h4 id="段落标签："><a href="#段落标签：" class="headerlink" title="段落标签：&lt;p&gt;"></a>段落标签：&lt;p&gt;</h4><h4 id="文本加粗标签："><a href="#文本加粗标签：" class="headerlink" title="文本加粗标签：&lt;b&gt; &#x2F; &lt;strong&gt;"></a>文本加粗标签：&lt;b&gt; &#x2F; &lt;strong&gt;</h4><h4 id="换行标签："><a href="#换行标签：" class="headerlink" title="换行标签：&lt;br&gt;"></a>换行标签：&lt;br&gt;</h4><h4 id="表格标签："><a href="#表格标签：" class="headerlink" title="表格标签：&lt;table&gt; &#x2F; &lt;tr&gt; &#x2F; &lt;td&gt;"></a>表格标签：&lt;table&gt; &#x2F; &lt;tr&gt; &#x2F; &lt;td&gt;</h4><ul><li>&lt;table&gt;：定义表格整体，包含多个&lt;tr&gt;。border：表格边框宽度；width：表格宽度；cellspacing：单元之间的空间</li><li>&lt;tr&gt;：表格的行，包含多个&lt;td&gt;</li><li>&lt;td&gt;：表格单元格（普通），如果是表头单元格，可以替换为&lt;th&gt;（自带居中和加粗）</li></ul><h4 id="表单标签："><a href="#表单标签：" class="headerlink" title="表单标签：&lt;form&gt;"></a>表单标签：&lt;form&gt;</h4><p>负责数据的采集，如：注册、登陆等数据的采集</p><p><strong>表单项</strong>：不同类型的input元素、下拉列表、文本域等</p><ul><li><p>&lt;input&gt;：定义表单项，通过type属性控制输入形式（text（默认）、password（密码字段）、radio（单选按钮）、checkbox（复选框）、file（文件上传）、date&#x2F;time&#x2F;datetime-local（日期&#x2F;时间&#x2F;日期时间）、number（数字输入框）、email（邮箱输入框）、hidden（隐藏框）、submit&#x2F;reset&#x2F;button（提交。重置&#x2F;可点击按钮））（单选框和复选框中每个input均需要用&lt;label&gt;&lt;&#x2F;label&gt;包含，尤其是单选框，表示不可多选）</p></li><li><p>&lt;select&gt;：定义下拉列表，&lt;option&gt;定义列表项</p></li><li><p>&lt;textarea&gt;：定义文本域</p></li></ul><p><strong>注意：表单项必须有name属性才可以提交</strong></p><p>表单项中<strong>value</strong>属性可以控制传入的值</p><p><strong>属性</strong>：</p><ul><li>action：规定当提交表单时向何处发送表单数据—URL（不指定就默认提交到当前页面）</li><li>method：规定用于发送表单数据的方式—POST&#x2F;GET（默认为GET）<ul><li>GET：表单数据拼接在url后面（？username&#x3D;java），大小有限制</li><li>POST：表单数据在请求体中携带，大小没有限制</li></ul></li></ul><h3 id="CSS实现"><a href="#CSS实现" class="headerlink" title="CSS实现"></a>CSS实现</h3><h4 id="颜色：color"><a href="#颜色：color" class="headerlink" title="颜色：color"></a>颜色：color</h4><p>格式：color: red;</p><p><strong>颜色表示形式</strong></p><ul><li>关键字：red、blue</li><li>rgb表示法：rgb(0,0,255)  <em>（红绿蓝三原色）</em></li><li>十六进制表示法：#ff0000   <em>（每两位代表rgb的一位）（可以简写成#f00，即在每个rgb的两位相同时写一个即可）</em></li></ul><h4 id="字体：font-size"><a href="#字体：font-size" class="headerlink" title="字体：font-size"></a>字体：font-size</h4><p><em>记得后面加上px</em></p><h4 id="文本装饰：text-decoration"><a href="#文本装饰：text-decoration" class="headerlink" title="文本装饰：text-decoration"></a>文本装饰：text-decoration</h4><p>none：默认，标准文本</p><p>underline：下划线</p><p>overline：上划线</p><p>line-through：穿过文本的一条线</p><h4 id="首行缩进：text-indent"><a href="#首行缩进：text-indent" class="headerlink" title="首行缩进：text-indent"></a>首行缩进：text-indent</h4><p>常与&lt;p&gt;一起使用</p><h4 id="设置行高：line-height"><a href="#设置行高：line-height" class="headerlink" title="设置行高：line-height"></a>设置行高：line-height</h4><p>常与&lt;p&gt;一起使用</p><h4 id="对齐方式：text-align"><a href="#对齐方式：text-align" class="headerlink" title="对齐方式：text-align"></a>对齐方式：text-align</h4><p>包括center、left、right</p><h4 id="盒子模型相关："><a href="#盒子模型相关：" class="headerlink" title="盒子模型相关："></a>盒子模型相关：</h4><p>width</p><p>height</p><p>box-sizing：指定宽高指的是哪个部分的（eg. border-box）</p><p>background-color</p><p>padding：内边距（上 右 下 左）（一致时可以只写一个）（写三个时分别为上 左右 下；两个时分别为上下 左右）（可以写auto，代表浏览器自动计算）</p><p>border：边框（宽度 线条类型 颜色）</p><p>margin：外边框（上 右 下 左）</p><p>（如果只设置某一个方位的边框、内边距、外边距，可以在属性名后加上-位置，如：padding-top\padding-left…）</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>跨平台、面向对象的脚本语言（不需要编译）。用来控制网页行为，能使网页可交互</li><li>JS与Java是完全不同的语言，无论是概念还是设计，但是基础语法类似</li></ul><h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><ul><li><strong>内部脚本</strong>：将JS代码定义在HTML页面中<ul><li>JS代码必须位于&lt;script&gt;&lt;&#x2F;script&gt;标签之间</li><li>在HTML文档中，可以在任意地方放置任意数量的&lt;script&gt;</li><li>一般会把脚本置于&lt;body&gt;元素的底部，可以改善显示速度</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;Hello JS&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>外部脚本</strong>：将JS代码定义在外部JS文件中，然后引入到HTML页面中<ul><li>外部JS文件中，只包含JS代码，不包含&lt;script&gt;标签</li><li>&lt;script&gt;标签不能自闭合<em>（自闭合：本来要用一个配对的结束符号来关闭，然而它却自己关闭了，如：&lt;script src&#x3D;”js&#x2F;demo.js”&gt;）</em></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>demo.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello JS&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul><li>区分大小写</li><li>每行结尾分号可写可不写</li></ul><h4 id="输出语句："><a href="#输出语句：" class="headerlink" title="输出语句："></a>输出语句：</h4><ul><li>弹出警告框：window.alert()</li><li>在浏览器中展示：document.write()</li><li>写入浏览器控制台：console.log()</li></ul><h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><ul><li>用var关键字（variable）来声明变量</li><li>JS是一门弱类型语言，变量可以存放不同类型的值</li><li>变量名需要遵循以下规则：<ul><li>组成字符可以是任何字母、数字、下划线或美元符号$</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li></ul><p><strong>特点</strong>：</p><ul><li>作用域大，全局变量</li><li>可以重复定义</li></ul><p><strong>新增</strong>：</p><ul><li><strong>let关键字</strong>：与var类似，但是是局部变量，而且不能重复定义</li><li><strong>const关键字</strong>：声明只读的常量</li></ul><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><ul><li>原始类型：number、string、boolean、null、undefined</li><li>引用类型—object</li></ul><p>（使用typeof运算符可以获取数据类型）</p><h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><ul><li>算术运算符</li><li>赋值运算符</li><li>比较运算符：（多一个&#x3D;&#x3D;&#x3D;）</li><li>逻辑运算符</li><li>三元运算符</li></ul><p><em>=&#x3D;与=&#x3D;&#x3D;的区别：=&#x3D;会进行类型转换，===不会进行类型转换，=&#x3D;=会同时比较数据类型和数据</em></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义：用function关键字</p><p>方式：</p><ul><li><p>方式一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>形参不需要指明类型</li><li>返回值不需要指明类型</li><li>函数调用可以传递任意多个的参数，函数只会取前几个作为参数</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p><strong>定义</strong>：</p><ul><li><p>var 变量名 &#x3D; new Array(元素列表);</p></li><li><p>var 变量名 &#x3D; [元素列表];</p></li></ul><p><strong>访问</strong>：</p><p>arr[索引] &#x3D; 值;</p><p>特点：长度可变，类型可变（可以存储任意类型的数据）</p><p><strong>属性</strong>：</p><ul><li>length：返回数组元素数量</li></ul><p><strong>方法</strong>：</p><ul><li>forEach ()：遍历数组中<strong>有值</strong>的元素，并调用一次传入的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="params"><span class="keyword">function</span>(e)</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用function，并将获得的值存入e</p><p>可简写为<strong>箭头函数</strong>：(…) &#x3D;&gt; {…} （小括号中放形参列表）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>push()：在末尾添加新元素，并返回新长度</li><li>splice()：删除元素（传两个参：从哪个索引开始，删几个）</li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>创建方式</strong>：</p><ul><li>var 变量名 &#x3D; new String(“…”)；</li><li>var 变量名 &#x3D; “…”；</li></ul><p><strong>属性</strong>：</p><ul><li>length</li></ul><p><strong>方法</strong>：</p><ul><li>charAt()</li><li>indexOf()：检索字符串位置</li><li>trim()：去除字符串两边的空格</li><li>substring()</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p><strong>JS自定义对象</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">属性名<span class="number">1</span>: 属性值<span class="number">1</span>,</span><br><span class="line">属性名<span class="number">2</span>: 属性值<span class="number">2</span>,</span><br><span class="line">    函数名称: <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>函数可省略为: 函数名称 () {}</em></p><p><strong>概念</strong>：JavaScript Object Notation，JS对象标记法</p><ul><li>JSON是通过JS对象标记法书写的文本、</li><li>由于语法简单，层次结构鲜明，现多用于<strong>作为数据载体</strong>，在网络中进行数据传输</li></ul><p><strong>定义</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&#x27;&#123;&quot;key1&quot;: value1, &quot;key2&quot;: value2&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>value的数据类型：</p><ul><li>数字：直接写整数或浮点数</li><li>字符串：放在双引号中</li><li>逻辑值：直接写</li><li>数组：放在方括号中</li><li>对象：放在花括号中</li><li>null</li></ul><p><strong>JSON字符串转换为JS对象</strong>：</p><p>var jsObject &#x3D; JSON.parse(jsonStr);</p><p><em>（转换为对象后就可以通过.属性拿到内部某个属性值）</em></p><p><strong>JS对象转换为JSON字符串</strong></p><p>var jsonStr &#x3D; JSON.stringify(jsObject);</p><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><p><strong>概念</strong>：Browser Object Model，浏览器对象模型，允许JS与浏览器对话，JS将浏览器的各个组成部分封装为对象</p><p><strong>组成</strong>：</p><ul><li>Window：浏览器窗口对象<ul><li>获取：<ul><li>直接使用window，其中window.可以省略。（比如window.alert(“Hello”)等价于alert(“Hello”)）</li></ul></li><li>属性<ul><li>history</li><li>location</li><li>navigation</li></ul></li><li>方法<ul><li>alert()：显示带有一段消息和一个确认按钮的警告框</li><li>confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框（返回布尔值）</li><li>setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式（执行多次）</li><li>setTimeout()：在指定的毫秒数后调用函数或计算表达式（执行一次）</li></ul></li></ul></li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象<ul><li>介绍：地址栏对象</li><li>获取：使用windows.location获取，其中windows.可以省略</li><li>属性：<ul><li>href：设置或返回完整的URL</li></ul></li></ul></li></ul><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p><strong>概念</strong>：Document Object Model，文档对象模型</p><p><strong>分类</strong>：将标记语言的各个组成部分封装为对应的对象</p><ul><li>Document：整个文档对象</li><li>Element：元素对象（每一个标签）</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p><strong>作用</strong>：</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式（CSS）</li><li>对HTML DOM事件作出反应</li><li>添加和删除HTML元素</li></ul><p><strong>组成</strong>：</p><ul><li>Core DOM - 所有文档类型的标准模型<ul><li>Document：整个文档对象</li><li>Element：元素对象（每一个标签）</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li><li>XML DOM - XML文档的标准模型</li><li>HTML DOM - HTML文档的标准模型<ul><li>Image：&lt;img&gt;</li><li>Button：&lt;input type&#x3D;’button’&gt;</li><li>……</li></ul></li></ul><p><strong>获取方式</strong>：</p><ul><li>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的</li><li>Document对象中提供了以下获得Element元素对象的函数：<ul><li>根据id属性值，返回当Element对象：var h1 &#x3D; document.getElementById(‘h1’);</li><li>根据标签名，返回数组：getElementsByTagName</li><li>根据name属性值，返回数组：getElementsByName</li><li>根据class属性值，返回数组：getElementsByClassName</li></ul></li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h4><p>HTML事件是发生在HTML元素上的”事情“。比如：点击按钮、按下键盘……</p><h4 id="事件监听："><a href="#事件监听：" class="headerlink" title="事件监听："></a>事件监听：</h4><p>JS可以在事件被侦测到时<strong>执行代码</strong></p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ul><li>方式一：通过HTML标签中的事件属性进行绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;我被点击了&#x27;</span>)；</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方式二：通过DOM元素属性进行绑定</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮2&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;我被点击了&#x27;</span>)；</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h4><ul><li>onclick：点击</li><li>onblur：失去焦点</li><li>onfocus：获得焦点</li><li>onload：页面或图像完全加载</li><li>onsubmit：表单提交</li><li>onkeydown：按下键盘上某个键</li><li>onmouseover：鼠标移到某元素之上</li><li>onmouseout：鼠标从某元素移开</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>是一套<strong>前端框架</strong>，免除原生JS中的DOM操作，简化书写。</p><p>基于<strong>MVVM</strong>（Model-View-ViewModer）思想，实现数据的*双向绑定**，将编程的关注点放在数据上。</p><p><strong>格式</strong>：</p><ul><li>新建HTML页面，引入Vue.js文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在JS代码区域，创建Vue核心对象，定义数据类型</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">new Vue&#123;&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">message: “Hello Vue&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handle: functiono()&#123;</span><br><span class="line">                alert(&quot;点击&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写视图</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>插值表达式</strong>：</p><ul><li>形式：</li><li>内容可以是：变量、三元运算符、函数调用、算术运算</li></ul><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>v-bind：动态绑定属性值，如：href、css样式等</li><li>v-model：为表单元素创建双向数据绑定（可简写为@）</li><li>v-on：为html标签添加事件</li><li>v-if：为true时渲染某元素，否则不渲染（就是没有了）</li><li>v-else-if：跟if组合用</li><li>v-else：跟if组合用</li><li>v-show：展示某元素（区别：切换的是display属性的值，true则展示，否则隐藏，而不是没有）</li><li>v-for：列表渲染，变量容器的元素或对象的属性</li></ul><p>注意：</p><ul><li>通过v-bind或者v-model绑定的变量，必须在数据模型中声明</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>概念</strong>：指一个对象从创建到销毁的整个过程</p><p><strong>八个阶段</strong>：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted：挂载完成——Vue初始化成功，HTML页面渲染成功。（发送请求到服务端，加载数据）</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>以.vue结尾</p><p><strong>组成部分</strong>：</p><ul><li>&lt;template&gt;：模板部分，由它生成HTML代码</li><li>&lt;script&gt;：控制模板的数据来源和行为，相当于js文件</li><li>&lt;style&gt;：css样式部分</li></ul><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul><li>创建页面，完成页面的整体布局规划</li><li>布局中各个部分的组件实现</li><li>列表数据的异步加载，并渲染展示</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><strong>前端路由</strong>：URL中的hash（#号）与组件之间的对应关系</p><p><strong>Vue Router</strong>：</p><p>组成：</p><ul><li>VueRouter：路由器类，根据路由请求在路由视图中动态渲染选中的组件</li><li>&lt;router-link&gt;：请求链接组件，浏览器会解析为&lt;a&gt;<ul><li>eg. &lt;router-link to&#x3D;”&#x2F;dept”&gt;部门&lt;&#x2F;router-link&gt;</li></ul></li><li>&lt;router-view&gt;：动态视图组件，用来渲染展示与路由路径对应的组件<ul><li>eg. 写在APP.vue的&lt;template&gt;中：&lt;router-view&gt;&lt;&#x2F;router-view&gt;</li></ul></li></ul><h1 id="web后端"><a href="#web后端" class="headerlink" title="web后端"></a>web后端</h1><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>是一款管理和构建java项目的工具</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题</li><li><strong>统一项目结构</strong>：提供标准、统一的项目结构</li><li><strong>项目构建</strong>：标准跨平台的自动化项目构建方式</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><strong>groupId</strong>：项目隶属组织名称（通常是域名反写）</li><li><strong>artifactId</strong>：项目名称</li><li><strong>version</strong>：项目版本号</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li><p>依赖具有<strong>传递性</strong>：分为直接依赖和间接依赖</p><ul><li>为了主动断开依赖的资源，需要<strong>排除依赖</strong>——&lt;exclusions&gt;（被排除的资源无需指定版本）</li></ul></li><li><p><strong>依赖范围</strong>：用&lt;scope&gt;…&lt;&#x2F;scope&gt;设置其作用范围</p><ul><li>包括主程序有效、测试程序有效、参与打包运行三种范围</li></ul></li><li><p><strong>生命周期</strong>：为了所有的maven项目构建过程进行抽象和统一，包括以下三套生命周期：</p><ul><li>clean：清理工作<ul><li>clean：移除上一次构建生成的文件</li></ul></li><li>default：核心工作<ul><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架进行测试（junit）</li><li>package：将编译后的文件打包</li><li>install：安装项目到本地仓库</li></ul></li><li>site：生成报告、发布站点等</li></ul><p>注意：在同一套<strong>生命周期</strong>中当运行后面的阶段时，前面的阶段都会运行。</p></li></ul><h4 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h4><p>简化依赖配置，引入起步依赖就相当于引入了这一块业务开发所需要的全部依赖。原理是Maven的依赖传递。</p><ul><li><p>spring-boot-starter-web：包含了web应用开发所需的常见依赖</p></li><li><p>spring-boot-starter-test：包含了单元测试所需的常见依赖</p></li></ul><p><em>起步依赖的版本无须声明，在父工程中进行了统一管理</em></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>基于TCP协议：面向连接，安全</li><li>基于请求-响应模型：一次请求对应一次响应</li><li>无状态：对于事务处理没有记忆能力。每次请求-响应都是独立的。<ul><li>缺点：多次请求间不能共享数据</li><li>优点：速度快</li></ul></li></ul><h3 id="请求数据格式："><a href="#请求数据格式：" class="headerlink" title="请求数据格式："></a>请求数据格式：</h3><ul><li><p>请求行：请求数据第一行（请求方式、资源路径、协议）</p></li><li><p>请求头：第二行开始，格式key：value</p><ul><li>Host：请求的主机名</li><li>User-Agent：浏览器版本</li><li>Accept：浏览器能接收的资源类型</li><li>Accept-Language：浏览器偏好的语言，服务器可以据此返回不同语言的网页</li><li>Accept-Encoding：浏览器可以支持的压缩类型</li><li>Content-Type：请求主体的数据类型</li><li>Content-Length：请求主体的大小（单位：字节）</li></ul></li><li><p>请求体：Post请求，存放请求参数</p></li></ul><p><strong>请求方式-GET</strong>：请求参数在请求行中，没有请求体，如：&#x2F;brand&#x2F;findAll？name&#x3D;OPPO&amp;status&#x3D;1。GET请求大小是有限制的。</p><p><strong>请求方式-POST</strong>：请求参数在请求体中，POST请求大小是没有限制的。</p><h3 id="响应格式："><a href="#响应格式：" class="headerlink" title="响应格式："></a>响应格式：</h3><ul><li>响应行：响应数据第一行（协议、状态码、描述）<ul><li>200：客户端请求成功</li><li>404：请求资源不存在，一般是URL输入错误，或者网站资源被删除了</li><li>500：服务器发生不可预期的错误</li></ul></li><li>响应头：第二行开始，格式key：value<ul><li>Content-Type：响应内容的类型</li><li>Content-Length：响应内容的长度（字节数）</li><li>Content-Encoding：响应压缩算法</li><li>Cache-Control：客户端应该如何缓存</li><li>Set-Cookie：告诉浏览器为当前页面所在的域设置cookie</li></ul></li><li>响应体：存放响应数据</li></ul><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务“。</p><ul><li>对HTTP协议的操作进行封装，简化web程序开发</li><li>部署web项目，对外提供网上信息浏览服务</li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><ul><li>一个轻量级的web容器，支持servlet、jsp等少量javaEE规范</li><li>也称为web容器、servlet容器（servlet程序需要依赖于Tomcat才能运行）</li></ul><p><em>（HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时将不需要输入端口号）</em></p><p>基于SpringBoot开发的web应用程序，内置了tomcat服务器，当启动类运行时，会自动启动内嵌的tomcat服务器。</p><h2 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>请求响应：</p><ul><li>请求（HttpServletRequest）：获取请求数据</li><li>响应（HttpServletResponse）：设置响应数据</li><li>BS架构：Browser&#x2F;Server，浏览器&#x2F;服务器架构模式，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。（优点：维护方便；缺点：体验一般）</li><li>CS架构：Client&#x2F;Server，客户端&#x2F;服务器架构模式。（优点：体验好；缺点：开发、维护麻烦）</li></ul><h3 id="简单参数"><a href="#简单参数" class="headerlink" title="简单参数"></a>简单参数</h3><h4 id="原始方式："><a href="#原始方式：" class="headerlink" title="原始方式："></a>原始方式：</h4><ul><li>Controller方法形参中声明HttpServletRequest对象</li><li>调用对象的getParameter（参数名）</li></ul><h4 id="SpringBoot中接收简单参数"><a href="#SpringBoot中接收简单参数" class="headerlink" title="SpringBoot中接收简单参数"></a>SpringBoot中接收简单参数</h4><ul><li>请求参数名与方法形参变量名相同</li><li>会自动进行类型转换</li></ul><h4 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h4><ul><li>方法形参名称与请求参数名称不匹配，通过该注解完成映射</li><li>该注解的required属性默认为true，代表请求参数必须传递</li></ul><h3 id="实体参数"><a href="#实体参数" class="headerlink" title="实体参数"></a>实体参数</h3><p><strong>简单实体参数</strong>：请求参数名与形参对象属性名相同即可</p><p><strong>复杂实体对象</strong>：请求参数名与形参对象属性名相同，按照对象层次结构关系即可</p><h3 id="数组集合参数"><a href="#数组集合参数" class="headerlink" title="数组集合参数"></a>数组集合参数</h3><p><strong>数组</strong>：请求参数名与形参中数组变量名相同，可以直接使用数组封装</p><p><strong>集合</strong>：请求参数名与形参中集合变量名相同，通过@RequestParam绑定参数关系（因为默认是用数组传递的）</p><h3 id="日期参数"><a href="#日期参数" class="headerlink" title="日期参数"></a>日期参数</h3><p>使用@DateTimeFormat注解完成日期参数格式转换</p><p>eg.(@DateTimeFormat(pattern &#x3D; “yyyy-MM-dd HH:mm:ss”) LocalDateTime updateTime)</p><h3 id="JSON参数"><a href="#JSON参数" class="headerlink" title="JSON参数"></a>JSON参数</h3><p>JSON数据键名与形参对象属性名相同，需要使用@RequestBody标识</p><h3 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h3><p>通过请求URL直接传递参数，使用{…}来标识路径参数，需要使用**@PathVariable**获取路径参数</p><p><strong>一个方法中可以有多个路径参数，每个路径参数前均需要注解</strong></p><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p><strong>@ResponseBody</strong></p><ul><li>类型：方法注解、类注解</li><li>位置：Controller方法&#x2F;类上</li><li>作用：将方法返回值直接响应，如果返回值类型是实体对象&#x2F;集合，将会转换成JSON格式响应</li><li>说明：@RestController&#x3D;@Controller+@ResponseBody（所以一般写@RestController）</li></ul><p><strong>统一响应结果</strong></p><p>Result(code, msg, data)</p><h2 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h2><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><p>为了单一职责原则，一个类或一个方法只做一件事，所以web开发有了<strong>三层架构</strong>：</p><ul><li>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据</li><li>service：业务逻辑层，处理具体的业务逻辑</li><li>dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增删改查</li></ul><p><strong>好处</strong>：复用性强、便于维护、利于扩展</p><h4 id="分层解耦-1"><a href="#分层解耦-1" class="headerlink" title="分层解耦"></a>分层解耦</h4><ul><li><strong>内聚</strong>：软件中各个功能模块内部的功能联系</li><li><strong>耦合</strong>：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度</li><li>软件设计原则：<strong>高内聚低耦合</strong></li></ul><p><strong>控制反转</strong>：Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器）</p><p><strong>依赖注入</strong>：Dependency Injection，简称DI。容器为应用程序提供运行时所依赖的资源。</p><p><strong>Bean对象</strong>：IOC容器创建、管理的对象</p><h4 id="IOC和DI："><a href="#IOC和DI：" class="headerlink" title="IOC和DI："></a>IOC和DI：</h4><ul><li>Service层和Dao层的实现类，交给IOC容器管理<ul><li>在类前加上@Component</li></ul></li><li>为Controller和Service注入运行依赖的对象<ul><li>在成员变量前加上@Autowired</li></ul></li></ul><p><strong>Bean的声明</strong>：</p><p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一</p><ul><li>@Component：声明Bean的基础注解。以下三个都是它的衍生注解。不属于以下三类时使用。</li><li>@Controller：标注在控制器类上。</li><li>@Service：标注在业务类上。</li><li>@Repository：标注在数据访问类上。</li></ul><p>注意：</p><ul><li>声明bean时，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li><li>使用以上四个注解都可以声明bean，但在springboot集成web开发中，声明控制器bean只能用@Controller</li></ul><p><strong>Bean组件扫描</strong>：</p><ul><li>前面声明的bean四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描</li><li>@ComponentScan注解虽然没有显示配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication中，默认扫描的范围是启动类所在包及其子包</li></ul><p><strong>Bean注入</strong>：</p><ul><li>@Autowired注解，默认是按照<strong>类型</strong>进行，如果存在多个相同类型的bean，将会报错</li><li>解决方案：<ul><li>@Primary：在@Service前加。</li><li>@Qualifier：在@Autowired后加。eg.@Qualifier(“empServiceA”)</li><li>@Resource：代替@Autowired的位置。eg.@Resource(name&#x3D;”empServiceB”)</li></ul></li></ul><p><strong>@Resource和@Autowired的区别</strong></p><ul><li>后者是spring框架提供的注解，而前者是JDK提供的注解</li><li>后者默认是按照类型注入，而前者默认是按照名称注入</li></ul><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><h2 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h2><p>REST（REpresentation State Transfer），表述性状态转换，是一种软件架构风格。</p><ul><li>URL定位资源</li><li>HTTP动词描述操作</li><li>前后端交互统一响应结果Result（包括code响应码、msg响应信息、data返回数据）</li></ul><p><strong>注意</strong>：</p><ol><li>REST是风格，是约定方式，不是规定，可以打破</li><li>描述模块的功能通常使用复数来表示此类资源，而非单个资源</li></ol><h2 id="日志小技巧"><a href="#日志小技巧" class="headerlink" title="日志小技巧"></a>日志小技巧</h2><ol><li>添加注解@Slf4j</li><li>添加Log.info()</li></ol><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/depts&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        Log.info(<span class="string">&quot;查询全部部门数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>一个完整的请求路径，应该是类上的@RequestMapping的value属性+方法上的@RequestMapping的value属性。</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>设置请求参数默认值：</p><p>@RequestParam(defaultValue&#x3D;”1”)</p><h2 id="PageHelper分页插件"><a href="#PageHelper分页插件" class="headerlink" title="PageHelper分页插件"></a>PageHelper分页插件</h2><ul><li><p>引入依赖：pagehelper-spring-boot-starter</p></li><li><p>使用：</p><ul><li>EmpServiceImpl：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;Emp&gt; list = empMapper.list();</span><br><span class="line">Page&lt;Emp&gt; page = (Page&lt;Emp&gt;)list;</span><br></pre></td></tr></table></figure><ul><li>EmpMapper：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程</li><li>文件上传在项目中应用非常广泛，eg. 发微博、发朋友圈</li></ul><h2 id="前端页面三要素"><a href="#前端页面三要素" class="headerlink" title="前端页面三要素"></a>前端页面三要素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctyoe</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>表单提交方式 method&#x3D;”post”</li><li>表单属性 enctyoe&#x3D;”multipart&#x2F;form-data”：表单提交时作为多个数据提交</li><li>表单项 type&#x3D;”file”</li></ul><h2 id="服务端接收文件"><a href="#服务端接收文件" class="headerlink" title="服务端接收文件"></a>服务端接收文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过MultipartFile这个API接收上传的文件，上传上来临时文件，当请求响应结束后，临时文件会自动删除</li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>将上传的文件存储到本地服务器磁盘中</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(String username, Integer age, MultipartFile image)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//获得文件后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">        <span class="comment">//构造唯一的文件名（不重复） - uuid（通用唯一识别码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">        <span class="comment">//将文件存储在服务器磁盘目录中</span></span><br><span class="line">        image.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\images\\&quot;</span> + newFileName));</span><br><span class="line"><span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改最大允许上传文件"><a href="#修改最大允许上传文件" class="headerlink" title="修改最大允许上传文件"></a>修改最大允许上传文件</h3><p>在SpringBoot中，文件上传，默认单个文件允许最大为1M</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置单个文件最大上传大小</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-file-size</span>=<span class="string">10MB</span></span><br><span class="line"><span class="comment">#配置单个请求最大上传大小（一次请求可以上传多个文件）</span></span><br><span class="line"><span class="attr">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br></pre></td></tr></table></figure><p><strong>缺点：前端无法直接访问、磁盘空间限制、磁盘损坏</strong></p><h2 id="第三方服务—阿里云"><a href="#第三方服务—阿里云" class="headerlink" title="第三方服务—阿里云"></a>第三方服务—阿里云</h2><h3 id="通用思路"><a href="#通用思路" class="headerlink" title="通用思路"></a>通用思路</h3><ul><li>准备工作<ul><li>注册阿里云（实名认证）</li><li>充值</li><li>开通对象存储服务（OSS)</li><li>创建<strong>bucket</strong>—存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间</li><li>获取AccessKey（密钥）</li></ul></li><li>参考官方SDK编写入门程序</li><li>集成使用</li></ul><p><strong>SDK：Software Development Kit的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等</strong></p><h3 id="集成步骤："><a href="#集成步骤：" class="headerlink" title="集成步骤："></a>集成步骤：</h3><ul><li>引入阿里云OSS上传文件工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取上传文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> file.getInputStream();</span><br><span class="line">        <span class="comment">//获取原始文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> image.getOriginalFilename();</span><br><span class="line">        <span class="comment">//获得文件后缀</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">extname</span> <span class="operator">=</span> originalFilename.substring(index);</span><br><span class="line">        <span class="comment">//构造唯一的文件名（不重复） - uuid（通用唯一识别码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extname;</span><br><span class="line">        <span class="comment">//上传文件到OSS</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">        ossClient.putObject(bucketName, fileName, inputStream);</span><br><span class="line">        <span class="comment">//文件访问路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;//&quot;</span> + bucketName + <span class="string">&quot;.&quot;</span> + endpoint.split(<span class="string">&quot;//&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + newFileName;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上传图片接口开发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AliOSSUtils aliOSSUtils;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line"><span class="keyword">return</span> Result.success(url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置文件（application-properties"><a href="#配置文件（application-properties" class="headerlink" title="配置文件（application.properties)"></a>配置文件（application.properties)</h1><h2 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h2><p>将技术或服务所使用的参数直接配置在配置文件中，交给配置文件进行统一的管理和维护。</p><p>java代码中使用**@Value**注解通常用于外部配置的属性注入，具体用法：@Value(“${配置文件中的key}”)</p><h2 id="yml格式文件"><a href="#yml格式文件" class="headerlink" title="yml格式文件"></a>yml格式文件</h2><h3 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h3><ul><li>XML：臃肿</li><li>properties：层次结构不清晰</li><li>yml&#x2F;yaml：简洁，数据为中心（推荐）</li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li>大小写敏感</li><li>数值前必须有空格，作为分隔符</li><li>使用缩进来表示层级关系，缩进时，不允许使用Tab键，只能用空格（但是idea里可以将Tab自动识别为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><h3 id="数据格式："><a href="#数据格式：" class="headerlink" title="数据格式："></a>数据格式：</h3><ul><li>对象&#x2F;Map集合：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>数组&#x2F;List&#x2F;Set集合：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><h3 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h3><p>在utils文件夹中添加AliOSSProperties：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;aliyun.oss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先的AliOSSUtils改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOSSUtils</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AliOSSProperties aliOSSProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> aliOSSProperties.getEndpoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> aliOSSProperties.getAccessKeyId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> aliOSSProperties.getAccessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> aliOSSProperties.getBucketName;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConfigurationProperties与-Value"><a href="#ConfigurationProperties与-Value" class="headerlink" title="@ConfigurationProperties与@Value"></a>@ConfigurationProperties与@Value</h3><h4 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h4><ul><li>都是用来注入外部配置的属性的</li></ul><h4 id="不同："><a href="#不同：" class="headerlink" title="不同："></a>不同：</h4><ul><li>@Value注解只能一个一个的进行外部属性的注入</li><li>@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中</li></ul><h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一个浏览器，以便在同一次会话的多次请求间共享数据。</li><li>会话跟踪方案：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul></li></ul><p><strong>Cookie</strong>：</p><ul><li>优点：HTTP协议支持的技术</li><li>缺点：<ul><li>移动端APP无法使用</li><li>不安全，用户可以自己禁用</li><li>不能跨域（跨域的三个维度：协议、IP&#x2F;域名、端口）</li></ul></li></ul><p><strong>Session</strong>：</p><ul><li>优点：存储在服务端，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>Cookie的缺点</li></ul></li></ul><p><strong>令牌技术</strong>：（主流）</p><ul><li>优点：<ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器端存储压力（不需要服务器端存储任何的数据）</li></ul></li><li>缺点：需要自己实现</li></ul><h3 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h3><p>JSON Web Token，定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><p><strong>组成</strong>：</p><ol><li>Head（头），记录令牌类型，签名算法。通过Base64编码获得。</li><li>Payload（有效载荷），携带一些自定义信息、默认信息。通过Base64编码获得。</li><li>Signaure（签名），防止Token被篡改，确保安全性。将header、payload加入指定密钥，通过指定签名算法计算而来。</li></ol><p><em>Base64：基于64个可打印字符（A-Z，a-z，0-9，+，&#x2F;）来进行二进制数据的编码方式</em></p><p><strong>场景</strong>：登录认证</p><ol><li>令牌生成：登录成功后，生成令牌，并返回给前端</li><li>令牌校验：再请求到达服务端后，对令牌进行统一拦截、校验。后续每个请求，都需要携带JWT令牌，系统在每次请求处理之前，先校验令牌，通过后再处理</li></ol><p><strong>生成</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    claims.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        .setClaims(claims)  <span class="comment">//自定义内容（载荷）</span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256,<span class="string">&quot;itheima&quot;</span>)  <span class="comment">//签名算法 </span></span><br><span class="line">        .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">12</span>*<span class="number">3600</span>*<span class="number">1000</span>))  <span class="comment">//有效期</span></span><br><span class="line">        .compact();</span><br><span class="line">    System.out.println(jwt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseJwt</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(<span class="string">&quot;itheima&quot;</span>)  <span class="comment">//指定签名密钥</span></span><br><span class="line">        .parseClaimsJws(<span class="string">&quot;……&quot;</span>)  <span class="comment">//解析令牌</span></span><br><span class="line">        .getBody();</span><br><span class="line">    System.out.println(claims);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>JWT校验时使用的签名密钥，必须和生成JWT令牌时使用的密钥是配套的</li><li>如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法</li></ul><h3 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>Filter过滤器，JavaWeb三大组件（Servlet、Filter、Listener）之一</li><li>过滤器可以把资源的请求拦截下来，从而实现一些特殊的功能</li><li>过滤器一般完成一些通用的操作，如：登录校验、统一编码处理、敏感字符处理等</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>定义Filter：定义一个类，实现Filter接口，并重写其所有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123; <span class="comment">//初始化方法，Web服务器启动，创建Filter时调用，只调用一次</span></span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>&#123; <span class="comment">//拦截到请求时，调用该方法，可调用多次</span></span><br><span class="line">        System.out.println(<span class="string">&quot;拦截到了请求&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123; <span class="comment">//销毁方法，服务器关闭时调用，只调用一次</span></span><br><span class="line">        Filter.<span class="built_in">super</span>.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置Filter：Filter类加上@WebFilter注解，配置拦截资源的路径，引导类上加@ServletComponentScan开启Servlet组件（Java Web）支持（加在@SpringBootApplication之前）</li></ul><h4 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h4><ul><li>具体路径：&#x2F;login</li><li>目录拦截：&#x2F;emps&#x2F;*</li><li>拦截所有：&#x2F;*</li></ul><h4 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h4><ul><li>一个web应用中，可以配置多个过滤器，多个过滤器形成一个过滤器链</li><li>顺序：优先级按照过滤器类名（字符串）的自然排序</li></ul><h4 id="登录校验过滤器"><a href="#登录校验过滤器" class="headerlink" title="登录校验过滤器"></a>登录校验过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestYRL().toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，若包含，说明时登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.判断令牌是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象-&gt;json （阿里巴巴fastJSON）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.解析token</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        JWTUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.errOr(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul><li>概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，用来动态拦截控制器方法的执行。</li><li>作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>定义拦截器，实现HandlerInterceptor接口，并重写其所有方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行前执行，返回true则放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler, Exception ex)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册拦截器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;</span><br><span class="line">registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*这里的&#x2F;*<em>表示拦截所有</em></p><h4 id="拦截路径-1"><a href="#拦截路径-1" class="headerlink" title="拦截路径"></a>拦截路径</h4><ul><li>addPathPatterns：需要拦截的资源</li><li>excludePathPatterns：不需要拦截的资源</li></ul><p>拦截路径：</p><ul><li>&#x2F;*：一级路径（包括&#x2F;depts，不包括&#x2F;depts&#x2F;1）</li><li>&#x2F;**：任意级路径</li></ul><h4 id="过滤器于拦截器同时存在"><a href="#过滤器于拦截器同时存在" class="headerlink" title="过滤器于拦截器同时存在"></a>过滤器于拦截器同时存在</h4><p>先执行过滤器，过滤器放行后执行拦截器</p><h4 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//目标资源方法执行前执行，返回true则放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestYRL().toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.判断请求url中是否包含login，若包含，说明时登录操作，放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取请求头中的令牌（token）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.判断令牌是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt))&#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动转换 对象-&gt;json （阿里巴巴fastJSON）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.解析token</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        JWTUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.errOr(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="Filter与Interceptor"><a href="#Filter与Interceptor" class="headerlink" title="Filter与Interceptor"></a>Filter与Interceptor</h3><ul><li>接口规范不同：前者需要实现Filter接口，后者需要实现HandlerInterceptor接口</li><li>拦截范围不同：前者拦截所有资源，后者之后拦截Spring环境中的资源</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>在Controller的方法中进行try…catch处理（代码臃肿，不推荐）</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>全局异常处理器（简单，推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span>&#123; </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">//捕获所有的异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</em></p><h1 id="事务管理-AOP"><a href="#事务管理-AOP" class="headerlink" title="事务管理&amp;AOP"></a>事务管理&amp;AOP</h1><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin；</li><li>提交事务（这组操作全部成功后，提交事务）：commit；</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback；</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>注解：@Transactional</li><li>位置：业务（service）层的方法上、类上、接口上</li><li>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</li></ul><h2 id="事务属性—回滚"><a href="#事务属性—回滚" class="headerlink" title="事务属性—回滚"></a>事务属性—回滚</h2><h3 id="rollbackFor"><a href="#rollbackFor" class="headerlink" title="rollbackFor"></a>rollbackFor</h3><ul><li>默认情况下，只有出现RuntimeException才回滚异常。rollbackFor属性用于控制出现何种的异常类型才会回滚事务。</li><li>@Transactional(rollbackFor &#x3D; Exception.class)  代表所有的异常都会回滚。</li></ul><h2 id="事务属性—传播行为"><a href="#事务属性—传播行为" class="headerlink" title="事务属性—传播行为"></a>事务属性—传播行为</h2><h3 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h3><ul><li>事务传播行为：指当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。<ul><li>REQUIRED：（默认值）需要事务，有则加入，无则创建新事务。</li><li>REQUIRES_NEW：需要新事务，无论有无，总是创建新事务。</li></ul></li></ul><p>eg. @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)  代表会创建一个新的事务。</p><p><em>当被调用的事务方法和原先的事务方法在一个事务中时，一旦出现问题就会全部回滚，所以用REQUIRES_NEW可以事务之间不影响，比如下订单前需要记录日志，无论订单保存成功与否都需要保证日志记录能够记录成功</em></p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><ul><li>AOP：Aspect Oriented Programming（面向切片编程、面向方面编程），就是面向特定方法编程。</li><li>实现：动态代理是面向切面编程最主流的实现，而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定方法进行编程。</li><li>场景：记录操作日志，权限控制，事务管理……</li><li>优势：代码无侵入，减少重复代码，提高开发效率，维护方便</li></ul><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>场景：统计每一个业务方法的执行耗时</p><ul><li>导入依赖</li><li>编写AOP程序：针对于特定方法根据业务需要进行编程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//AOP类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span> <span class="comment">// 切入点表达式，这里表示业务层的所有方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1.记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//2.调用原始方法运行</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="comment">//3.记录结束时间，计算方法执行耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        log.info(joinPoint.getSignature() + <span class="string">&quot;方法执行耗时： &#123;&#125;ms&quot;</span>, end - begin);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</li><li>通知：Advice，指重复的逻辑，也就是共性功能（最终体现为一个方法）</li><li>切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时会被应用</li><li>切面：Aspect，描述通知与切入点的对应关系（通知+切入点）</li><li>目标对象：Target，通知所应用的对象</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><strong>一旦进行AOP程序的开发，最终运行的就不再是原始的目标对象，而是基于目标对象所生成的代理对象。</strong></p><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><ul><li>@Aroud：环绕通知，标注的通知方法在目标方法前后都被执行</li><li>@Before：前置通知，标注的通知方法在目标方法前被执行</li><li>@After：后置通知（最终通知），标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li><li>@AfterReturning：返回后通知，标注的通知方法在目标方法后被执行，有异常不会执行</li><li>@AfterThrowing：异常后通知，标注的通知方法发生异常后执行</li></ul><p><strong>注意</strong>：</p><ul><li>@Around环绕通知需要自己调用ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行</li><li>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值</li></ul><h4 id="PointCut"><a href="#PointCut" class="headerlink" title="@PointCut"></a>@PointCut</h4><p>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.service.impl.DeptServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">recordTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>private：仅能在当前切面类中引用</p><p>public：在其他外部的切面类中也能引用</p><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h3><p>当有多个切面的切入点都匹配了目标方法时，多个通知方法都会被执行。</p><ul><li>不同切面类中，默认按照切面类的类名字母顺序<ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul></li><li>用@Order(数字)加在切面类上来控制顺序<ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="execution-…-：根据方法的签名来匹配"><a href="#execution-…-：根据方法的签名来匹配" class="headerlink" title="execution(…)：根据方法的签名来匹配"></a>execution(…)：根据方法的签名来匹配</h4><p>主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配</p><p>语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)</p><p>其中?表示可省略：</p><ul><li>访问修饰符：比如pulic，protected</li><li>包名.类名.：不建议省略</li><li>throws 异常：是方法上声明抛出的异常，不是实际抛出的异常</li></ul><p>通配符：</p><ul><li>*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名，任意类型的一个参数，也可以通配包、类、方法名的一部分</li><li>..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ul><p>注意：根据业务需要，可以使用&amp;&amp;、||、！来组合比较复杂的切入点表达式</p><p>书写建议：</p><ul><li>所有业务方法名在命名时尽量规范。方便切入点表达式快速匹配（如：查询类方法均以find开头等）</li><li>描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性</li><li>在满足业务需要前提下，尽量缩小切入点的匹配范围（如：包名匹配尽量不使用..，使用*匹配单个包）</li></ul><h4 id="annotation-…-：根据注解匹配"><a href="#annotation-…-：根据注解匹配" class="headerlink" title="@annotation(…)：根据注解匹配"></a>@annotation(…)：根据注解匹配</h4><p>用于匹配标识有特定注解的方法</p><p>eg. @annotation(com.itheima.aop.MyLog)可以匹配所有有@MyLog注解的方法</p><p>需要在com.itheima.aop目录下新建一个命名为MyLog的Annotation：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//运行时有效</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">//在Method上生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint</li><li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li></ul><p>示例：</p><ul><li>joinPoint.getTarget().getClass().getName() &#x2F;&#x2F; 获取目标类名</li><li>joinPoint.getSignature() &#x2F;&#x2F; 获取目标方法签名</li><li>joinPoint.getSignature().getName() &#x2F;&#x2F; 获取目标方法名</li><li>joinPoint.getArgs() &#x2F;&#x2F; 获取目标方法运行参数</li></ul><h3 id="获取当前用户"><a href="#获取当前用户" class="headerlink" title="获取当前用户"></a>获取当前用户</h3><p>获取request对象，从请求头中获取到jwt令牌，解析令牌获取出当前用户的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">……&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">operateUser</span> <span class="operator">=</span> (Integer)claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>properties &gt; yml &gt; yaml</p><p><strong>虽然SpringBoot支持多种格式配置文件，但是在项目开发时，推荐使用统一的一种配置（yml是主流）</strong></p><h2 id="Bean管理"><a href="#Bean管理" class="headerlink" title="Bean管理"></a>Bean管理</h2><h3 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h3><ul><li>默认在Spring项目启动后，会把bean都创建好放在IOC容器中（主要针对于默认的单例非延迟加载的bean，正常情况下还会受到作用域和延迟初始化影响），如果想要主动获得这些bean，方式如下：<ul><li>根据name获取bean：Object getBean(String name)</li><li>根据类型获取bean：&lt;T&gt; T getBean(Class&lt;T&gt; requiredType)</li><li>根据name获取bean(带类型转换)：&lt;T&gt; T getBean(Stirng name, Class&lt;T&gt; requiredType)</li></ul></li></ul><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><ul><li>singleton：容器中同名称的bean只有一个实例（单例）（默认）</li><li>prototype：每次使用该bean时会创建新的实例（非单例）</li></ul><p>通过@Scope注解来配置作用域</p><p>eg. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Lazy</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line">RequestMapping(<span class="string">&quot;/depts&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）</li><li>实际开发大部分的bean是单例的，一般不需要配置Scope属性</li></ul><h3 id="第三方bean"><a href="#第三方bean" class="headerlink" title="第三方bean"></a>第三方bean</h3><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解声明bean的，就需要用到@Bean注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span>&#123;</span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">//将方法返回值交给IOC容器管理，成为IOC容器的bean对象</span></span><br><span class="line">    <span class="keyword">public</span> SAXReander <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要管理第三方bean对象，建议进行集中分类配置，可以通过@Configuration注解声明一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SAXReader <span class="title function_">saxReader</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>通过@Bean注解的name&#x2F;value属性指定bean名称，如果未指定，默认是方法名</li><li>如果第三方bean需要依赖其他的bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配</li></ul><h3 id="Component及衍生注解与-Bean注解的使用场景"><a href="#Component及衍生注解与-Bean注解的使用场景" class="headerlink" title="@Component及衍生注解与@Bean注解的使用场景"></a>@Component及衍生注解与@Bean注解的使用场景</h3><ul><li>项目中自定义的使用@Component及衍生注解</li><li>项目中引入第三方的使用@Bean注解</li></ul><h2 id="SpringBoot原理"><a href="#SpringBoot原理" class="headerlink" title="SpringBoot原理"></a>SpringBoot原理</h2><h3 id="起步依赖-1"><a href="#起步依赖-1" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>maven的依赖传递</p><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><h4 id="自动配置方案"><a href="#自动配置方案" class="headerlink" title="自动配置方案"></a>自动配置方案</h4><ul><li>方案一：@ComponentScan组件扫描</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&#123;&quot;com.example&quot;,&quot;com.itheima&quot;&#125;)</span>  <span class="comment">// 还需要包括原先的目录，因为是声明后是覆盖关系</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用繁琐，性能低</p><ul><li>方案二：@Import导入。使用@Import导入的类会被Spring加载到IOC容器中，导入形式主要包括：<ul><li>导入普通类</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li><li>@EnableXxx注解，封装@Import注解（推荐）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Impor(&#123;TokenParser.class,HeaderConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><p>@SpringBootApplication</p><p>该注解标识在SpringBoot工程引导类上，是SpringBoot中最重要的注解，由三部分组成：</p><ul><li>@SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解</li></ul><p><strong>注意</strong>：SpringBoot会根据@Conditional注解条件装配，而不是全部注册为IOC容器的bean。</p><h5 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h5><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中</li><li>位置：方法、类</li><li>@Conditional本身是一个父注解，派生出大量的子注解：<ul><li>@ConditionalOnClass：判断环境中是否有对应字节码文件（name &#x3D; “…”)，有才注册bean到IOC容器</li><li>@ConditionalOnMissingBean：判断环境中是否有对应的bean（可以根据类型value属性或名称name属性来判断是否存在），没有才注册bean到IOC容器。通常用来设置一个默认的bean对象。</li><li>@ConditionalOnProperty：判断配置文件中是否有对应属性和值（name &#x3D; “…”, havingValue &#x3D; “…”)，有才注册bean到IOC容器</li></ul></li></ul><h3 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h3><p>在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter。</p><p><em>起步依赖分类：</em></p><ul><li>SpringBoot官方：spring-boot-starter-xxx</li><li>其他技术提供：xxx-spring-boot-starter</li></ul><p>eg.</p><p><strong>需求</strong>：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置</p><p><strong>目标</strong>：引入起步依赖之后，要使用阿里云OSS，注入AliyunOSSUtils直接使用即可</p><p><strong>步骤</strong>：</p><ul><li>创建aliyun-oss-spring-boot-starter模块（依赖管理功能）</li><li>创建aliyun-oss-spring-boot-autoconfigure模块（自动配置功能），在starter中引入该模块</li><li>在aliyun-oss-spring-boot-autoconfigure模块中定义自动配置功能，并定义自动配置文件META-INF&#x2F;spring&#x2F;xxx.imports</li></ul><h1 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h1><h2 id="分模块设计与开发"><a href="#分模块设计与开发" class="headerlink" title="分模块设计与开发"></a>分模块设计与开发</h2><p>分模块设计：将项目按照功能拆分成若干个子模块</p><p>原因：方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享</p><p><strong>注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。</strong></p><h2 id="继承与聚合"><a href="#继承与聚合" class="headerlink" title="继承与聚合"></a>继承与聚合</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</p><p>作用：简化依赖配置、统一管理依赖</p><p>实现：&lt;parent&gt;…&lt;&#x2F;parent&gt;</p><ul><li>创建maven模块tlias-parent，该工程为父工程，设置打包方式为pom（默认jar）<ul><li>&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</li></ul></li><li>在子工程的pom.xml文件中，配置继承关系<ul><li>&lt;relativePath&gt;..&#x2F;tlias-parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;</li></ul></li><li>在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）</li></ul><p><em>打包方式</em>：</p><ul><li>jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）</li><li>war：普通web程序打包，需要部署在外部的tomcat服务器中运行</li><li>pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理</li></ul><h3 id="版本锁定"><a href="#版本锁定" class="headerlink" title="版本锁定"></a>版本锁定</h3><p>在maven中，可以在父工程的pom文件中通过&lt;dependencyManagement&gt;来统一管理依赖版本</p><p><strong>注意</strong>：子工程引入依赖时，无需指定&lt;version&gt;版本号，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</p><p>自定义属性&#x2F;引用属性：放在&lt;properties&gt;…&lt;&#x2F;properties&gt;中</p><h4 id="与的区别："><a href="#与的区别：" class="headerlink" title="&lt;dependencyManagement&gt;与&lt;dependencies&gt;的区别："></a>&lt;dependencyManagement&gt;与&lt;dependencies&gt;的区别：</h4><ul><li>后者是直接依赖，在父工程配置了依赖，子工程会直接继承下来</li><li>前者是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖（无需指定版本）</li></ul><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合：将多个模块组织成一个整体，同时进行项目的构建</p><p>聚合工程：一个不具有业务功能的”空“工程（有且仅有一个pom文件）（所以使用父工程作为聚合工程）</p><p>作用：快速构建项目（无需根据依赖关系手动创建，直接在聚合工程上构建即可）</p><p>写法：maven中可以通过&lt;modules&gt;设置当前聚合工程所包含的子模块名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-utils<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../tlias-web-management<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：聚合工程所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。</p><h3 id="继承与聚合："><a href="#继承与聚合：" class="headerlink" title="继承与聚合："></a>继承与聚合：</h3><ul><li>作用<ul><li>聚合用于快速构建项目</li><li>继承用于简化依赖配置、统一管理依赖</li></ul></li><li>相同点：<ul><li>pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>均属于设计类模块，并无实际的模块内容</li></ul></li><li>不同点：<ul><li>聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>私服是一种特殊的远程仓库，架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。</p><p><strong>依赖查找顺序</strong>：</p><ul><li>本地仓库</li><li>私服</li><li>中央仓库</li></ul><p><strong>注意</strong>：私服在企业项目开发中，一个项目&#x2F;公司，只需要一台即可。</p><h3 id="资源上传与下载"><a href="#资源上传与下载" class="headerlink" title="资源上传与下载"></a>资源上传与下载</h3><ul><li>设置私服的访问用户名&#x2F;密码（settings.xml中的servers中配置）</li><li>IDEA的maven工程的pom文件中配置上传（发布）地址</li><li>设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）</li><li>执行deploy</li></ul><p><strong>项目版本</strong>：</p><ul><li>RELEASE（发行版本）：功能趋于稳定，当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中</li><li>SNAOSHOT（快照版本）：功能不稳定、尚处于开发中的版本，存储在私服中的SNAOSHOT仓库中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/11/01/MySQL/"/>
      <url>/2024/11/01/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>数据库</strong>：DataBase（DB），是存储和管理数据的仓库</p><p><strong>数据库管理系统</strong>：DataBase Management System（DBMS），操纵和管理数据库的大型软件</p><p><strong>SQL</strong>：Structured Query Language，操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</p><p><strong>关系型数据库</strong>：（RDBMS），建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p><p>特点：</p><ul><li>使用表存储数据，格式统一，便于维护</li><li>使用SQL语言操作，标准统一，使用方便，可用于复杂查询</li></ul><p><strong>数据模型</strong>：在一个数据库服务器中可以创建多个数据库，而且多个数据库相互独立；在一个数据库中可以创建多张表，一张表中可以存储多条的数据。</p><h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p><strong>SQL</strong>：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。</p><p><strong>通用语法</strong>：</p><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性，不影响效果</li><li>MySQL数据库的SQL语句不区分大小写</li><li>注释：<ul><li>单行：– 注释内容 &#x2F; # 注释内容（MySQL特有）</li><li>多行：&#x2F;* 注释内容 *&#x2F;</li></ul></li></ul><p><strong>分类</strong>：</p><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML（Data Manipulation Language）：数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL（Data Query Language）：数据查询语言，用来查询数据库中表的记录</li><li>DCL（Data Control Language）：数据控制语言，用来创建数据库用户、控制数据库的访问权限</li></ul><h1 id="数据库设计—DDL"><a href="#数据库设计—DDL" class="headerlink" title="数据库设计—DDL"></a>数据库设计—DDL</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li>查询所有数据库：show databases;</li><li>查询当前数据库：select database();</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>使用数据库：use 数据库名;</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>创建数据库：create database [if not exists] 数据库名;</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>删除数据库：drop database [if exists] 数据库名;</li></ul><p><strong>注意</strong>：上述语法中的database也可替换成schema</p><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">字段<span class="number">1</span> 字段类型 [约束] [comment 字段<span class="number">1</span>注释],</span><br><span class="line">字段<span class="number">2</span> 字段类型 [约束] [comment 字段<span class="number">2</span>注释]</span><br><span class="line">&#125;[comment 表注释];</span><br></pre></td></tr></table></figure><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul><li><p>概念：作用于表中字段上的规则，用于限制存储在表中的数据</p></li><li><p>目的：保证数据库中数据的正确性、有效性和完整性</p></li><li><p>包括：</p><ul><li>非空约束：not null</li><li>唯一约束：unique</li><li>主键约束：primary key（非空且唯一）<strong>（auto_increment：自动增长）</strong></li><li>默认约束：default（后接默认值，表示若未指定字段值，则采用默认值）</li><li>外键约束：foreign key（让两张表的数据建立连接，保证数据的一致性和完整性）</li></ul></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>数值类型<ul><li><strong>tinyint</strong>：1byte，小整数值</li><li>smallint：2byte，中整数值</li><li>mediumint：3byte，大整数值</li><li><strong>int</strong>：4byte，大整数值</li><li><strong>bigint</strong>：8byte，极大整数值</li><li>float：4byte，单精度浮点数</li><li><strong>double</strong>：8byte，双精度浮点数，eg.double(5,2)，5为整个数字长度，2为小数位个数</li><li>decimal：小数值（精度更高）（用字符串存储，精准）</li></ul></li><li>字符串类型<ul><li><strong>char</strong>：定长字符串，性能高，但是浪费空间</li><li><strong>varchar</strong>：变长字符串，节省空间，但是性能低</li></ul></li><li>日期时间类型<ul><li><strong>date</strong>：日期值，YYYY-MM-DD</li><li>time：时间值或持续时间，HH:MM:SS</li><li>year：年份值</li><li><strong>datetime</strong>：混合日期和时间值</li></ul></li></ul><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p>页面原型+需求 &#x3D;&gt; 原型字段（类型、约束）+ 基础字段（id、create_time、update_time）</p><p><em>create_time记录当前数据的插入时间，update_time记录当前数据最后的更新时间</em></p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><ul><li>查询当前数据库所有表：show tables;</li><li>查询表结构：desc 表名;</li><li>查询建表语句：show create table 表名;</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>添加字段：alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];</li><li>修改字段类型：alter table 表名 modify 字段名 新数据类型(长度);</li><li>修改字段名和字段类型：alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];</li><li>删除字段：alter table 表名 drop column 字段名;</li><li>修改表名：rename table 表名 to 新表名;</li></ul><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li>删除表：drop table [if exists] 表名;</li></ul><p><em>在删除表时，表中的数据也都会被删除</em></p><h1 id="数据库操作—DML"><a href="#数据库操作—DML" class="headerlink" title="数据库操作—DML"></a>数据库操作—DML</h1><h2 id="添加数据-INSERT"><a href="#添加数据-INSERT" class="headerlink" title="添加数据(INSERT)"></a>添加数据(INSERT)</h2><ul><li>指定字段添加数据：insert into 表名(字段名1, 字段名2) values (值1, 值2);</li><li>全部字段添加数据：insert into 表名 values (值1, 值2, …);</li><li>批量添加数据(指定字段)：insert into 表名(字段名1, 字段名2) values (值1, 值2), (值1, 值2);</li><li>批量添加数据(全部字段)：insert into 表名 values (值1, 值2, …), (值1, 值2, …);</li></ul><p><strong>注意</strong>：</p><ol><li>插入数据时，指定的字段顺序需要与值的顺序一一对应</li><li>字符串和日期型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li><li>插入数据时别忘了create_time和update_time值为now()</li></ol><h2 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据(UPDATE)"></a>修改数据(UPDATE)</h2><ul><li>update 表名 set 字段名1 &#x3D; 值1, 字段名2 &#x3D; 值2, … [where 条件];</li></ul><p><strong>注意</strong>：</p><ol><li>修改语句的条件没有时，则会修改整张表的所有数据</li><li>修改时别忘了修改update_time为now()</li></ol><h2 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据(DELETE)"></a>删除数据(DELETE)</h2><ul><li>delete from 表名 [where 条件];</li></ul><p><strong>注意</strong>：</p><ol><li>删除语句的条件没有时，则会删除整张表的所有数据</li><li>不能删除某一个字段的值（需要使用UPDATE，将该字段的值置为NULL）</li></ol><h1 id="数据库操作—DQL"><a href="#数据库操作—DQL" class="headerlink" title="数据库操作—DQL"></a>数据库操作—DQL</h1><p>格式：select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后条件列表 order by 排序字段列表 limit 分页参数</p><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><ul><li>查询多个字段：select 字段1，字段2，字段3 from 表名；</li><li>查询所有字段（通配符）：select * from 表名；（不推荐：不直观、性能低）</li><li>设置别名：select 字段1 [as 别名1]，字段2 [as 别名2] from 表名；</li><li>去除重复记录：select distinct 字段列表 from 表名；</li></ul><h2 id="条件查询（where）"><a href="#条件查询（where）" class="headerlink" title="条件查询（where）"></a>条件查询（where）</h2><ul><li>select 字段列表 from 表名 where 条件列表；</li></ul><p><strong>比较运算符</strong>：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;、&lt;&gt;或!&#x3D;、between…and…<em>（含最大最小值）</em>、in(…)<em>（在括号内列表中的值，多选一）</em>、like 占位符（模糊匹配：_匹配一个字符、%匹配任意个字符（<em>可以为0个</em>））、is null、is not null</p><p><strong>逻辑运算符</strong>：and或&amp;&amp;、or或||、not或！</p><h2 id="分组查询（group-by）"><a href="#分组查询（group-by）" class="headerlink" title="分组查询（group by）"></a>分组查询（group by）</h2><ul><li>select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]；</li></ul><p><strong>where和having的区别</strong>：</p><ol><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ol><p><strong>注意</strong>：</p><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li><li>执行顺序：where &gt; 分组操作+聚合函数 &gt; having</li></ul><p><strong>聚合函数</strong>：将一列数据作为一个整体，进行纵向运算。</p><p>select 聚合函数(字段列表) from 表名；</p><p>聚合函数包括：</p><ul><li>count：统计数量</li><li>max</li><li>min</li><li>avg：平均值</li><li>sum</li></ul><p><strong>注意</strong>：</p><ol><li>null值不参与所有聚合函数的运算</li><li>统计数量可以用count(*)、count(字段)、count(常量)，推荐使用count(*)</li></ol><h2 id="排序查询（order-by）"><a href="#排序查询（order-by）" class="headerlink" title="排序查询（order by）"></a>排序查询（order by）</h2><ul><li>select 字段列表 from 表名 [where 条件列表] [group by 分组字段]  order by 字段1 排序方式1，字段2 排序方式2，…；</li></ul><p><strong>排序方式</strong>：</p><ul><li>ASC：升序（默认值）</li><li>DESC：降序</li></ul><p><strong>注意</strong>：如果是多个字段排序，只有当第一个字段值相同时，才会根据第二个字段进行排序。</p><h2 id="分页查询（limit）"><a href="#分页查询（limit）" class="headerlink" title="分页查询（limit）"></a>分页查询（limit）</h2><ul><li>select 字段列表 from 表名 limit 起始索引, 查询记录数;</li></ul><p><strong>注意</strong>：</p><ol><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 查询记录数</li></ol><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><ul><li>if(表达式, true_value, false_value)</li><li>case expr when value1 then result1 [when value2 then result2…] [else result] end</li></ul><h1 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，分为：</p><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>一的一方叫父表，多的叫子表。</p><p><strong>实现</strong>：在数据库表中多的一方添加字段，来关联一的一方的主键。</p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p><strong>语法</strong>：</p><ul><li><p>创建表时指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">字段名 数据类型，</span><br><span class="line">…</span><br><span class="line">[<span class="keyword">constraint</span>][外键名称] <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(字段名)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>建完表后添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key (外键字段名) <span class="keyword">references</span> 主表(字段名)</span><br></pre></td></tr></table></figure></li></ul><h4 id="物理外键"><a href="#物理外键" class="headerlink" title="物理外键"></a>物理外键</h4><p><strong>概念</strong>：使用foreign key 定义外键关联另外一张表</p><p><strong>缺点</strong>：</p><ul><li>影响增、删、改的效率（需要检查外键关系）</li><li>仅用于单节点数据库，不适用与分布式、集群场景</li><li>容易引发数据库的死锁问题，消耗性能</li></ul><h4 id="逻辑外键（推荐）"><a href="#逻辑外键（推荐）" class="headerlink" title="逻辑外键（推荐）"></a>逻辑外键（推荐）</h4><p><strong>概念</strong>：在业务层逻辑中，解决外键关联</p><p><em>通过逻辑外键可以解决上述问题</em></p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率</p><p><strong>实现</strong>：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p><strong>实现</strong>：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><ol><li>阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系</li><li>阅读页面原型及需求文档，分析各个表结构中具体的字段及约束</li></ol><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>多表查询：指从多张表中查询数据</p><p><strong>笛卡尔积</strong>：在数学中，两个集合的所有组合情况。（在多表查询中，需要消除无效的笛卡尔积）</p><p><strong>分类</strong>：</p><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据（包括两张表交集部分数据）</li><li>右外连接：查询右表所有数据（包括两张表交集部分数据）</li></ul></li></ul></li><li>子查询</li></ul><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><strong>语法</strong>：</p><ul><li>隐式内连接：select 字段列表 from 表1，表2 where 条件…；</li><li>显示内连接：select 字段列表 from 表1 [inner] join 表2 on 连接条件…；</li></ul><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p><strong>语法</strong>：</p><ul><li>左外连接：select 字段列表 from 表1 left [outer] join 表2 on 连接条件…；</li><li>右外连接：select 字段列表 from 表1 right [outer] join 表2 on 连接条件…；</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><strong>概述</strong>：SQL语句中嵌套select语句，称为嵌套查询，也叫子查询</p><p><strong>形式</strong>：select * from t1 where column1 &#x3D; (select column1 from t2 …)；</p><p>子查询外部的语句可以是insert&#x2F;update&#x2F;delete&#x2F;select的任何一个，最常见的是select。</p><p><strong>分类</strong>：</p><ul><li>标量子查询：返回单个值</li><li>列子查询：返回一列</li><li>行子查询：返回一行</li><li>表子查询：返回多行多列</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><ul><li>返回单个值（数字、字符串、日期等），最简单的形式</li><li>常用的操作符：&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;</li></ul><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><ul><li>返回一列（可以是多行）</li><li>常用的操作符：in、not in等</li></ul><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><ul><li>返回一行（可以是多列）</li><li>常见的操作符：&#x3D;、&lt;&gt;、in、not in（左右都用括号括起来，然后左右相等即可）</li></ul><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><ul><li><p>返回多行多列，常作为临时表（放在from后面）</p></li><li><p>常见的操作符：in</p></li></ul><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><ol><li>先分析涉及到的表有哪些</li><li>然后分析表之间的关系，如何进行联查</li><li>最后考虑sql语句怎么写</li></ol><p><strong>子查询性能不高，能用连接查询时尽量用连接查询</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><strong>注意</strong>：默认MySQL的事务是自动提交的，即当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><ul><li>开启事务：start transaction; &#x2F; begin;</li><li>提交事务：commit;</li><li>回滚事务：rollback;</li></ul><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变就是永久的</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>索引（index）是帮助数据库高效获取数据的数据结构。</p><p><strong>优点</strong>：</p><ul><li>提高数据查询的效率，降低数据库的IO成本</li><li>通过索引对数据进行排序，降低数据排序的成本，降低CPU消耗</li></ul><p><strong>缺点</strong>：</p><ul><li>索引会占用存储空间</li><li>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。一般默认指B+Tree结构组织的索引。</p><p><em>若用二叉搜索树或者红黑树，会在大数据量的情况下，层级深，检索速度慢</em></p><p><strong>B+Tree（多路平衡搜索树）</strong></p><ul><li>每一个节点，可以存储多个key（有n个key，就有n个指针）</li><li>所有的数据都存储在叶子节点，非叶子节点仅用于索引数据（最终都要找到叶子节点才能拿到相应的数据）</li><li>叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><ul><li><p>创建索引：create [unique] index 索引名 on 表名(字段名…);</p></li><li><p>查看索引：show index from 表名;</p></li><li><p>删除索引：drop index 索引名 on 表名;</p></li></ul><p><strong>注意</strong>：</p><ol><li>主键字段，在建表时会自动创建主键索引（主键索引的性能是最高的）</li><li>添加唯一约束时，数据库实际上会添加唯一索引</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2024/10/30/Mybatis/"/>
      <url>/2024/10/30/Mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MyBatis是一款优秀的<strong>持久层</strong>框架，用于简化JDBC的开发。</p><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p><strong>使用Mybatis查询所有用户数据</strong></p><ul><li><p>准备工作（创建springboot工程、数据库表user、实体类User）</p></li><li><p>引入Mybatis的相关依赖，配置Mybatis（数据库连接信息）</p><ul><li><p>在application.properties中写（其中mybatis是数据库名称，需要根据具体情况进行修改）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写SQL语句（注解&#x2F;XML）</p><ul><li><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span>  <span class="comment">//在运行时，会自动生成该接口的实现类对象（代理对象），并且将该对象交给IOC容器管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部用户的信息</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单元测试</p><ul><li><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        userList.stream().forEach(user -&gt; &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>JDBC：（Java DataBase Connectivity），就是使用java语言操作关系型数据库的一套API。</p><h2 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h2><ul><li>一套操作所有关系型数据库的规范，即接口</li><li>各个数据库厂商去实现这个接口，提供数据库<strong>驱动jar包</strong></li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul><li>硬编码</li><li>繁琐</li><li>资源浪费，性能降低</li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><ul><li>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li></ul><p><strong>优势</strong>：</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul><p><strong>标准接口</strong>：</p><ul><li>DataSource是官方提供的数据库连接池接口，所有的第三方组织都必须实现此接口</li><li>功能：获取连接（Connection getConnection() throws SQLException;）</li></ul><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>是一个实用的Java类库，能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易阅读的toSring方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写equals方法和hashCode方法</td></tr><tr><td><strong>@Data</strong></td><td>提供了更综合的生成代码功能（@Getter+@Setter+@ToString+@EqualsAndHashCode）</td></tr><tr><td><strong>@NoArgsConstructor</strong></td><td>为实体类生成无参的构造器方法</td></tr><tr><td><strong>@AllArgsConstructor</strong></td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法</td></tr></tbody></table><p><strong>Lombok会在编译时，自动生成对应的java代码</strong></p><h1 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>准备数据库表emp</li><li>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</li><li>application.properties中引入数据库连接信息</li><li>创建对应的实体类Emp（实体类属性采用驼峰命名）</li><li>准备Mapper接口—EmpMapper</li></ul><h2 id="删除员工"><a href="#删除员工" class="headerlink" title="删除员工"></a>删除员工</h2><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果mapper接口方法形参只有一个普通类型的参数，#{…}里面的属性名可以随便写，如：#{id}、#{value}。</p><h4 id="预编译SQL"><a href="#预编译SQL" class="headerlink" title="预编译SQL"></a>预编译SQL</h4><p>优势：</p><ul><li><p>性能更高</p><p><img src="/2024/10/30/Mybatis/image-20241027151745180.png" alt="image-20241027151745180"></p></li><li><p>更安全（防止SQL注入）</p></li></ul><p><strong>SQL注入</strong>：通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</p><p><strong>参数占位符</strong>：</p><ul><li>#{…}<ul><li>执行SQL时，会将#{…}替换为？，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递</li></ul></li><li>${…}<ul><li>拼接SQL，直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><h2 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(username, name, gender, image, job, entrydate, dept_id,create_time, update_time) <span class="keyword">values</span>(<span class="string">&#x27;songyuanqiao&#x27;</span>, <span class="string">&#x27;宋远桥&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;1.jpg&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;2012-10-01 10:00:00&#x27;</span>, <span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; + &quot; values(#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125; ,#&#123;updateTime&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure><h3 id="主键返回"><a href="#主键返回" class="headerlink" title="主键返回"></a>主键返回</h3><p><strong>描述</strong>：在数据添加成功后，需要获取插入数据库数据的主键。如：添加套餐数据时，还需要维护套餐菜品关系表数据。</p><p><strong>实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Options(keyProperty = &quot;id&quot;, userGeneratedKeys = true)</span></span><br><span class="line"><span class="meta">@Insert</span>……</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>会自动将生成的主键值赋值给emp对象的id属性</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>与新增员工时类似</p><ul><li><p>SQL语句：update update set  …，…  where id &#x3D; 19;</p></li><li><p>接口方法：@Update(“……”)</p></li></ul><h2 id="查询（根据ID）"><a href="#查询（根据ID）" class="headerlink" title="查询（根据ID）"></a>查询（根据ID）</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>但是发现返回的部分属性值为null</strong></p><p><strong>数据封装</strong>：</p><ul><li>实体类属性名与数据库表查询返回的字段名一致，mybatis会自动封装</li><li>如果不一致，不能自动封装</li></ul><p><strong>解决方案</strong>：</p><ul><li>方案一：给字段起别名，让别名与实体类属性一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id, username, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><ul><li>方案二：通过@Results，@Result注解手动映射封装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><ul><li>方案三：在application.properties中开启驼峰命名自动映射开关（推荐）</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="查询（条件查询）"><a href="#查询（条件查询）" class="headerlink" title="查询（条件查询）"></a>查询（条件查询）</h2><ul><li>SQL语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span><span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> entrydate <span class="keyword">between</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>接口方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where name like &#x27;%$&#123;name&#125;%&#x27; and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br></pre></td></tr></table></figure><p><strong>由于预编译的?占位符不能出现在引号内，所有需要用$占位符。但是这样性能低，不安全，存在SQL注入问题。</strong></p><p><strong>改进方案</strong>：通过tomcat进行字符串拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from emp where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; order by update_time desc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><em>参数说明</em></h2><p>eg. 在String name前可加上@Param(“name”)，从而能够与注解中使用的参数一致</p><p><em>但是在springboot2.x版本内置了编译插件，可以省略这一部分。</em></p><h1 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h1><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ul><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）</li><li>XML映射文件的namespace属性为Mapper接口全限定名一致</li><li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</li></ul><p><img src="/2024/10/30/Mybatis/image-20241027162439599.png" alt="image-20241027162439599"></p><p><em>resultType：单条记录所封装的类型</em></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>使用Mybatis的注解，主要是来完成一些简单的增删改查功能；如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。</p><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态SQL：随着用户的输入或外部条件的变化而变化的SQL语句（一般用XML文件来定义）</p><h2 id><a href="#" class="headerlink" title="&lt;if&gt;"></a>&lt;if&gt;</h2><ul><li><strong>&lt;if&gt;<strong>：用于</strong>判断条件</strong>是否成立，使用test属性进行条件判断，如果为true，则拼接SQL。</li><li>**&lt;where&gt;**：只有内部包含的子元素存在true时才会插入where，并且能够自动去除子句开头的AND或OR。</li></ul><p>eg. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**&lt;set&gt;**：动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title="&lt;foreach&gt;"></a>&lt;foreach&gt;</h2><ul><li><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure></li><li><p>XML映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete from emp where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>collection：集合名称</li><li>item：集合遍历出来的元素</li><li>separator：每一次遍历使用的分隔符</li><li>open：遍历开始前拼接的片段</li><li>close：遍历结束后拼接的片段</li></ul></li></ul><h2 id="和"><a href="#和" class="headerlink" title="&lt;sql&gt;和&lt;include&gt;"></a>&lt;sql&gt;和&lt;include&gt;</h2><ul><li>**&lt;sql&gt;**：定义可重用的SQL片段</li><li>**&lt;include&gt;**：通过属性refid，指定包含的sql片段</li></ul><p><em>二者配对使用，将多次使用到的部分包装起来，减少代码量</em></p><p>eg.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line">    select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2024/10/17/Java%E9%9B%86%E5%90%88/"/>
      <url>/2024/10/17/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="数组和集合两种数据结构的区别"><a href="#数组和集合两种数据结构的区别" class="headerlink" title="数组和集合两种数据结构的区别"></a>数组和集合两种数据结构的区别</h2><p>数组：固定长度（一旦创建长度无法改变）；可以包含基本数据类型和对象；可以直接访问元素</p><p>集合：动态长度（可以根据需要动态增加或减少元素）；只能包含对象；需要迭代器或其他方法访问元素</p><p><em>（迭代器：一种设计模式，用于遍历数据结构）</em></p><p><em>（迭代器常用方法：hasNext(), next(), remove()）</em></p><h2 id="用过的一些Java集合类"><a href="#用过的一些Java集合类" class="headerlink" title="用过的一些Java集合类"></a>用过的一些Java集合类</h2><p><strong>ArrayList</strong>：动态数组，实现了List接口，支持动态增长</p><p><em>（List接口：List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引，可以根据序号存取容器中的元素）</em></p><p><strong>LinkedList</strong>：双向链表，也实现了LIst接口，支持快速的插入和删除操作</p><p><strong>HashMap</strong>：基于哈希表的Map实现，存储键值对，通过键快速查找值</p><p><strong>HashSet</strong>：基于HahsMap实现的Set集合，用于存储唯一元素</p><p><strong>TreeMap</strong>：基于红黑树实现的有序Map集合，可以按照键的顺序进行排序</p><p><strong>LinkedHashMap</strong>：基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序</p><p><strong>PriorityQueue</strong>：优先队列，可以按照比较器或元素的自然顺序进行排序</p><h2 id="Java中的集合"><a href="#Java中的集合" class="headerlink" title="Java中的集合"></a>Java中的集合</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1717481094793-b8ffe6ae-2ee6-4de5-b61b-8468e32bf269.webp" alt="img"></p><p><strong>List</strong>：有序的Collection，能精准控制元素的插入位置，能根据索引访问元素。常用的类有LinkedList，ArrayList，Vector，Stack。</p><ul><li><strong>ArrayList</strong>：容量可变的非线程安全列表，支持快速随机访问，但插入和删除速度很慢。</li><li><strong>LinkedList</strong>：本质是一个双向链表，与上面相比插入和删除速度更快，但随机访问速度更慢。</li></ul><p><strong>Set</strong>：元素不允许重复，无序。常用的实现有HashSet，LinkedHashSet，TreeSet。</p><ul><li><strong>HashSet</strong>：通过HashMap实现，使用key保证元素唯一性，但不保证有序性，线程不安全。</li><li><strong>LinkedHashSet</strong>：继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。</li><li><strong>TreeSet</strong>：通过TreeMap实现，按照比较规则插入新元素，保证插入后集合仍然有序。</li></ul><p><strong>Map</strong>：键值对集合，存储键、值和之间的映射。Key无序且唯一，value不要求有序且允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值。常用的实现有TreeMap，HashMap，HashTable，LinkedHashMap，ConcurrentHashMap。</p><ul><li><p><strong>HashMap</strong>：JDK1.8前由数组+链表组成，数组是主体，链表解决哈希冲突。之后改变了解决哈希冲突的方式，即当链表长度大于阈值时，链表转化为红黑树，减少搜索时间。</p></li><li><p><strong>LinkedHashMap</strong>：继承自HashMap，底层仍然是基于拉链式散列结构<em>（即由数组和链表或红黑树组成）</em>。另外增加了一条双向链表，使得可以保持键值对的插入顺序。同时实现了访问顺序相关逻辑。</p></li><li><p><strong>HashTable</strong>：数组+链表，数组是主体，链表解决哈希冲突。</p></li><li><p><strong>TreeMap</strong>：红黑树（自平衡的排序二叉树）</p></li><li><p><strong>ConcurrentHashMap</strong>：Node数组+链表+红黑树，线程安全。</p><p><em>（线程安全：多个线程访问同一段代码时，采用加锁机制，确保同一时刻只有一个线程在操作共享数据，避免数据不一致或污染的问题）</em></p></li></ul><h2 id="Java中线程安全的集合有哪些"><a href="#Java中线程安全的集合有哪些" class="headerlink" title="Java中线程安全的集合有哪些"></a>Java中线程安全的集合有哪些</h2><ul><li><p>java.util包：Vector、HashTable</p></li><li><p>java.util.concurrent包</p><ul><li><p>并发Map：ConcurrentHashMap、ConcurrentSkipListMap</p></li><li><p>并发Set：ConcurrentSkipListSet、CopyOnWriteArraySet</p></li><li><p>并发List：CopyOnWriteArrayList</p></li><li><p>并发Queue：ConcurrentLinkedQueue、BlockingQueue</p></li><li><p>并发Deque：LinkedBlockingDeque、ConcurrentLinkedDeque</p><p><em>（Deque：双端队列）</em></p></li></ul></li></ul><h2 id="Collections和Collection的区别"><a href="#Collections和Collection的区别" class="headerlink" title="Collections和Collection的区别"></a>Collections和Collection的区别</h2><p><strong>Collections</strong>：Java提供的一个工具类，位于java.util包中，提供了一系列静态方法，用于对集合进行操作和算法。该类中的方法包括排序、查找、替换、反转、随机化等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</p><p><strong>Collection</strong>：Java集合框架中的一个接口，是所有集合类的基础接口。定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。该接口有许多实现类，如List、Set和Queue等。</p><h2 id="集合遍历的方法有哪些"><a href="#集合遍历的方法有哪些" class="headerlink" title="集合遍历的方法有哪些"></a>集合遍历的方法有哪些</h2><ul><li>普通for循环</li><li>增强for循环（for—each循环）<ul><li>eg. for(String element : list){}</li></ul></li><li>Iterator迭代器（特别适用于需要删除元素的情况）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ListIterator列表迭代器：是迭代器的子类，可以双向访问列表并在迭代过程中修改元素</p><p><em>（与上面的区别为：ListIterator<String> listIterator &#x3D; list.listIterator();）</String></em></p></li><li><p>使用forEach方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><ul><li>Sream API：可以对集合进行函数式操作，如过滤、映射等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="List的几种实现及其不同"><a href="#List的几种实现及其不同" class="headerlink" title="List的几种实现及其不同"></a>List的几种实现及其不同</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807143695-c1058186-be42-4746-a273-6302a128e328.png" alt="image.png"></p><ul><li>Vector：线程安全的动态数组，内部使用对象数组来保存数据，可以根据需要自动增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</li><li>ArrayList：非线程安全的动态数组，性能更好，应用更加广泛，也可以根据需要调整容量。</li><li>LinkedList：双向链表，不需要像上面那样调整容量，非线程安全。</li></ul><p>综上，前两个作为动态数组，内部元素以数组形式顺序存储，适合随机访问。除了在尾部的插入和删除操作，性能相对较差<em>（比如中间插入一个元素，需要移动后续所有元素）</em>。第三个进行节点插入、删除较高效，但随机访问性能较慢。</p><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ul><li><strong>底层数据结构不同</strong>：前者使用数组实现，通过索引进行快速访问元素；后者使用链表实现，通过节点之间的指针进行元素的访问和操作。</li><li><strong>插入和删除操作的效率不同</strong>：前者在尾部操作效率较高，在中间或开头操作效率较低；后者在任意位置操作效率都较高。但是后者不支持随机访问，所以除了头结点外插入和删除的时间复杂度都是O(n)，效率不是很高。</li><li><strong>随机访问的效率不同</strong>：前者支持通过索引快速随机访问，时间复杂度为O(1)；后者需要从头或尾开始遍历链表，时间复杂度为O(n)。</li><li><strong>空间占用</strong>：前者在创建时需要分配一段连续的内存空间，会占用较大的空间；后者每个节点只需要存储元素和指针，占用空间相对较小。</li><li><strong>使用场景</strong>：前者适用于频繁随机访问和尾部的插入删除操作；后者适用于频繁的中间插入删除操作和不需要随机访问的场景。</li><li><strong>线程安全</strong>：两个集合都不是线程安全的。</li></ul><h2 id="为什么ArrayList不是线程安全的"><a href="#为什么ArrayList不是线程安全的" class="headerlink" title="为什么ArrayList不是线程安全的"></a>为什么ArrayList不是线程安全的</h2><p>在高并发添加数据下，ArrayList会暴露以下三个问题及其可能情况：</p><ul><li>部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。</li><li>索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；</li><li>size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的</li></ul><h2 id="把ArrayList变成线程安全的方式"><a href="#把ArrayList变成线程安全的方式" class="headerlink" title="把ArrayList变成线程安全的方式"></a>把ArrayList变成线程安全的方式</h2><ul><li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><ul><li>使用Vector类代替ArrayList，Vector是线程安全的List实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><h2 id="ArrayList和LinkedList的应用场景"><a href="#ArrayList和LinkedList的应用场景" class="headerlink" title="ArrayList和LinkedList的应用场景"></a>ArrayList和LinkedList的应用场景</h2><ul><li>前者适用于需要频繁访问和遍历集合元素，并且集合大小不经常改变的场景。</li><li>后者适用于频繁进行插入和删除操作，或者集合大小经常改变的场景。</li></ul><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>在添加元素时，如果当前元素个数已经达到了内部数组的容量上限就会触发扩容操作。</p><p>步骤如下：</p><ul><li>计算新的容量：一般会扩大为原容量的1.5倍，然后检查是否超过了最大容量限制。</li><li>创建新的数组：根据新容量创建更大的新数组。</li><li>复制元素：将原数组的元素逐个复制到新数组。</li><li>更新引用：将ArrayList内部指向原数组的引用指向新数组。</li><li>完成扩容：扩容完成后，可以继续添加新元素。</li></ul><p><em>（1.5倍可以充分利用移位操作，减少浮点数或者运算时间和运算次数）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新容量计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="线程安全的-List——CopyonWriteArraylist如何实现线程安全"><a href="#线程安全的-List——CopyonWriteArraylist如何实现线程安全" class="headerlink" title="线程安全的 List——CopyonWriteArraylist如何实现线程安全"></a>线程安全的 List——CopyonWriteArraylist如何实现线程安全</h2><p>CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取到当前List集合保存数据的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="comment">//将当前数组拷贝一份的同时，让其长度加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//替换引用，将数组的引用指向给新数组的地址</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到源码可以知道写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。</p><p>在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。</p><p>以下为读操作，读没有加锁，所以一直能读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><ul><li>JDK1.7之前，HashMap数据结构是数组和链表，通过哈希算法将元素的键映射到数组中的槽位。如果多个键映射到同一个槽位则会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719565480532-57a14329-c36b-4514-8e7d-2f2f1df88a82.webp" alt="img"></p><ul><li>JDK1.8进行优化，当一个链表的长度超过8时就转换数据结构，不再使用链表存储，而是红黑树，查找时使用红黑树，时间复杂度为O(log n)，可以提高查询性能，但在数量较少时(数量小于6)，会将红黑树转换回链表。</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719565481289-0c2164f4-f755-46e3-bb39-b5f28621bb6b.webp" alt="img"></p><h2 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="headerlink" title="哈希冲突解决方法"></a>哈希冲突解决方法</h2><ul><li><strong>链接法</strong>：使用链表或其他数据结构来存储冲突的键值对，将他们链接在同一个哈希桶中。</li><li><strong>开放寻址法</strong>：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。</li><li><strong>再哈希法</strong>：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</li><li><strong>哈希桶扩容</strong>：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</li></ul><h2 id="HashMap是线程安全的吗"><a href="#HashMap是线程安全的吗" class="headerlink" title="HashMap是线程安全的吗"></a>HashMap是线程安全的吗</h2><p>不是。HashMap在多线程会存在下面的问题：</p><ul><li>JDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。</li><li>JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。</li></ul><p><em>如果要保证线程安全，可以通过这些方法来保证：</em></p><ul><li><em>多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。</em></li><li><em>ConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。</em></li></ul><h2 id="HashMap的put过程"><a href="#HashMap的put过程" class="headerlink" title="HashMap的put过程"></a>HashMap的put过程</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1720684054342-1e3cb2a9-532e-40b8-b5cf-0043811391dc.png" alt="img"></p><ul><li>根据要添加的键的哈希码计算在数组中的位置（索引）</li><li>检查该位置是否为空（即没有键值对存在）<ul><li>如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数加1，以便在进行迭代时发现并发修改。</li></ul></li><li>如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同<ul><li>如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。</li></ul></li><li>如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键<ul><li>如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。<ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到链表的头部。</li></ul></li><li>如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。<ul><li>如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。</li><li>如果没有找到相同的键，则将新的键值对添加到红黑树中。</li></ul></li></ul></li><li>检查链表长度是否达到阈值（默认为8）<ul><li>如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。</li></ul></li><li>检查负载因子是否超过阈值（默认为0.75）<ul><li>如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。</li></ul></li><li>扩容操作<ul><li>创建一个新的两倍大小的数组。</li><li>将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。</li><li>更新HashMap的数组引用和阈值参数。</li></ul></li><li>完成添加操作</li></ul><p><em>（HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。）</em></p><h2 id="HashMap的put-key-val-和get-key-过程"><a href="#HashMap的put-key-val-和get-key-过程" class="headerlink" title="HashMap的put(key, val)和get(key)过程"></a>HashMap的put(key, val)和get(key)过程</h2><ul><li>存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。</li><li>获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</li></ul><h2 id="HashMap调用get方法一定安全吗"><a href="#HashMap调用get方法一定安全吗" class="headerlink" title="HashMap调用get方法一定安全吗"></a>HashMap调用get方法一定安全吗</h2><p>不一定。需注意以下两点：</p><ul><li>空指针异常：如果用null作为键调用get方法，而且HashMap没有初始化，那么会抛出空指针异常。（如果HashMap已经初始化，允许使用null为键）</li><li>线程安全：HashMap本身不是线程安全，如果需要在多线程环境使用类似HashMap的数据结构，可以考虑用ConcurrentHashMap。</li></ul><h2 id="HashMap一般用什么作为Key"><a href="#HashMap一般用什么作为Key" class="headerlink" title="HashMap一般用什么作为Key"></a>HashMap一般用什么作为Key</h2><p>用String作为Key，因为String对象不可变，一旦创建不可修改，确保了Key的稳定性。（如果Key可变，可能会导致HashCode和equals方法的不一致，进而影响HashMap的准确性。）</p><h2 id="为什么HashMap用红黑树而不是平衡二叉树"><a href="#为什么HashMap用红黑树而不是平衡二叉树" class="headerlink" title="为什么HashMap用红黑树而不是平衡二叉树"></a>为什么HashMap用红黑树而不是平衡二叉树</h2><ul><li>平衡二叉树追求”<strong>完全平衡</strong>“状态——任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</li><li>红黑树不追求这种完全平衡状态，而是追求一种 <strong>“弱平衡”</strong> 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，<strong>不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整</strong>，这也是为什么大多数情况下使用红黑树的原因。</li></ul><h2 id="HashMap的Key可以为null吗"><a href="#HashMap的Key可以为null吗" class="headerlink" title="HashMap的Key可以为null吗"></a>HashMap的Key可以为null吗</h2><p>可以。</p><ul><li>hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；</li></ul><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1720685862193-66a32b79-ddf0-46d5-87df-d2fc2b3d87cb.png" alt="img"></p><ul><li>hashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；</li><li>因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个。</li></ul><h2 id="重写HashMap的equal和hashcode方法需要注意什么"><a href="#重写HashMap的equal和hashcode方法需要注意什么" class="headerlink" title="重写HashMap的equal和hashcode方法需要注意什么"></a>重写HashMap的equal和hashcode方法需要注意什么</h2><p>HashMap使用Key对象的hashCode()和equals方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</p><p>同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p><ul><li><p>如果o1.equals(o2)，那么o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为true的。</p></li><li><p>如果o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着o1.equals(o2)会为true。</p><p><em>（可以把hashCode理解为房间号，而equals理解为身份证号，住在同一个房间，不一定是同一个人，不住在同一个房间，必然不是同一个人。）</em></p></li></ul><h2 id="重写HashMap的equal方法不当会出现什么问题"><a href="#重写HashMap的equal方法不当会出现什么问题" class="headerlink" title="重写HashMap的equal方法不当会出现什么问题"></a>重写HashMap的equal方法不当会出现什么问题</h2><p>HashMap在比较元素时，会先通过hashCode进行比较，相同的情况下再通过equals进行比较。</p><p>所以 equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）</p><p>重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false，这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。</p><h2 id="列举HashMap在多线程下可能会出现的问题"><a href="#列举HashMap在多线程下可能会出现的问题" class="headerlink" title="列举HashMap在多线程下可能会出现的问题"></a>列举HashMap在多线程下可能会出现的问题</h2><ul><li>JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li><li>多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul><h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>HashMap默认的负载因子是0.75，即如果HashMap中的元素个数超过了总容量的75%，就会触发扩容。</p><p>扩容包括以下两个步骤：</p><ul><li>对哈希表长度的扩展（2倍）</li><li>将旧哈希表中的数据放到新的哈希表中</li></ul><p>因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753772-9467a399-6b18-4a47-89d4-957adcc53cc0.webp" alt="img"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753786-cdca10bf-6eda-47f9-9bbe-0cc3beb67d76.webp" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1713514753885-d1529537-322c-49b1-beec-5d9953da5150.webp" alt="img"></p><p>这个设计既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="HashMap的大小为什么是2的n次方大小呢？"><a href="#HashMap的大小为什么是2的n次方大小呢？" class="headerlink" title="HashMap的大小为什么是2的n次方大小呢？"></a>HashMap的大小为什么是2的n次方大小呢？</h2><p>在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize &#x3D; 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</p><p>之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p><h2 id="往hashmap存20个元素，会扩容几次？"><a href="#往hashmap存20个元素，会扩容几次？" class="headerlink" title="往hashmap存20个元素，会扩容几次？"></a>往hashmap存20个元素，会扩容几次？</h2><p>当插入 20 个元素时，HashMap 的扩容过程如下：</p><p><strong>初始容量</strong>：16</p><ul><li>插入第 1 到第 12 个元素时，不需要扩容。</li><li>插入第 13 个元素时，达到负载因子限制，需要扩容。此时，HashMap 的容量从 16 扩容到 32。</li></ul><p><strong>扩容后的容量</strong>：32</p><ul><li>插入第 14 到第 24 个元素时，不需要扩容。</li></ul><p>因此，总共会进行一次扩容。</p><h2 id="说说hashmap的负载因子"><a href="#说说hashmap的负载因子" class="headerlink" title="说说hashmap的负载因子"></a>说说hashmap的负载因子</h2><p>HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。</p><p>默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。</p><p>负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。</p><h2 id="HashMap和HashTable有什么区别"><a href="#HashMap和HashTable有什么区别" class="headerlink" title="HashMap和HashTable有什么区别"></a>HashMap和HashTable有什么区别</h2><ul><li><strong>HashMap线程不安全</strong>，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li><strong>HashTable线程安全</strong>，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li></ul><h2 id="HashMap一般怎么用"><a href="#HashMap一般怎么用" class="headerlink" title="HashMap一般怎么用"></a>HashMap一般怎么用</h2><p>HashMap主要用来存储键值对，可以调用put方法向其中加入元素，调用get方法获取某个键对应的值，也可以通过containsKey方法查看某个键是否存在。</p><h2 id="ConcurrentHashMap是怎么实现的"><a href="#ConcurrentHashMap是怎么实现的" class="headerlink" title="ConcurrentHashMap是怎么实现的"></a>ConcurrentHashMap是怎么实现的</h2><p>在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807523151-41ad316a-6264-48e8-9704-5b362bc0083c.webp" alt="img"></p><p>JDK 1.7 ConcurrentHashMap 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p><p>在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表，而 JDK 1.8 则使用了数组 + 链表&#x2F;红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：</p><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1721807523128-7b1419e7-e6ba-47e6-aba0-8b29423a8ce7.webp" alt="img"></p><p>JDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 CAS 来初始化</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。<ul><li>如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul></li></ul><p>简而言之，就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。</p><p>而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。</p><h2 id="分段锁是怎么加锁的"><a href="#分段锁是怎么加锁的" class="headerlink" title="分段锁是怎么加锁的"></a>分段锁是怎么加锁的</h2><p>在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。</p><p>在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。</p><h2 id="分段锁是可重入的吗"><a href="#分段锁是可重入的吗" class="headerlink" title="分段锁是可重入的吗"></a>分段锁是可重入的吗</h2><p>JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</p><h2 id="已经用了synchronized，为什么还要用CAS呢？"><a href="#已经用了synchronized，为什么还要用CAS呢？" class="headerlink" title="已经用了synchronized，为什么还要用CAS呢？"></a>已经用了synchronized，为什么还要用CAS呢？</h2><p>ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。</p><p><em>比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。</em></p><p><em>当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。</em></p><h2 id="ConcurrentHashMap用了悲观锁还是乐观锁"><a href="#ConcurrentHashMap用了悲观锁还是乐观锁" class="headerlink" title="ConcurrentHashMap用了悲观锁还是乐观锁?"></a>ConcurrentHashMap用了悲观锁还是乐观锁?</h2><p>悲观锁和乐观锁都有用到。</p><p>添加元素时首先会判断容器是否为空：</p><ul><li>如果为空则使用 volatile 加 <strong>CAS （乐观锁）</strong> 来初始化。</li><li>如果容器不为空，则根据存储的元素计算该位置是否为空。</li><li>如果根据存储的元素计算结果为空，则利用 <strong>CAS（乐观锁）</strong> 设置该节点；</li><li>如果根据存储的元素计算结果不为空，则使用 <strong>synchronized（悲观锁）</strong> ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。</li></ul><h2 id="HashTable-底层实现原理是什么？"><a href="#HashTable-底层实现原理是什么？" class="headerlink" title="HashTable 底层实现原理是什么？"></a>HashTable 底层实现原理是什么？</h2><p><img src="/2024/10/17/Java%E9%9B%86%E5%90%88/1719982934770-8587cb0a-6e1d-4007-9a22-bc1e41276491.png" alt="img"></p><ul><li>Hashtable的底层数据结构主要是<strong>数组加上链表</strong>，数组是主体，链表是解决hash冲突存在的。</li><li>HashTable是线程安全的，实现方式是<strong>Hashtable的所有公共方法均采用synchronized关键字</strong>，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。</li></ul><h2 id="HashTable线程安全是怎么实现的？"><a href="#HashTable线程安全是怎么实现的？" class="headerlink" title="HashTable线程安全是怎么实现的？"></a>HashTable线程安全是怎么实现的？</h2><p>因为它的put，get做成了同步方法，保证了Hashtable的线程安全性，每个操作数据的方法都进行同步控制之后，由此带来的问题——任何一个时刻<strong>只能有一个线程可以操纵HashTable，所以其效率比较低</strong>。</p><p><strong>HashTable是通过使用了 synchronized 关键字来保证其线程安全</strong>。</p><p>在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p><h2 id="HashTable和ConcurrentHashMap的区别"><a href="#HashTable和ConcurrentHashMap的区别" class="headerlink" title="HashTable和ConcurrentHashMap的区别"></a>HashTable和ConcurrentHashMap的区别</h2><ul><li><p>底层数据结构：</p><ul><li>前者采用数组+链表，数组是主体，链表解决哈希冲突；</li><li>后者在JDK7之前采用分段的数组+链表，JDK8之后采用数组+链表&#x2F;红黑树。</li></ul></li><li><p>实现线程安全的方式：</p><ul><li>前者将所有的方法都加了锁，效率低下，当一个线程访问同步方法，另一个线程也访问时，就会陷入阻塞轮询状态。</li><li>后者在JDK8之前采用分段锁，对整个数组进行分段分割，多线程访问不同数据段里的数据，不存在锁竞争，提高了并发访问；JDK8之后采用数组+链表&#x2F;红黑树，并发控制使用CAS和synchronized操作，更加提高了速度。</li></ul></li></ul><h2 id="HashMap，HashTable和ConcurrentMap的区别"><a href="#HashMap，HashTable和ConcurrentMap的区别" class="headerlink" title="HashMap，HashTable和ConcurrentMap的区别"></a>HashMap，HashTable和ConcurrentMap的区别</h2><ul><li>HashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。</li><li>HashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。</li><li>ConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="Set集合的特点"><a href="#Set集合的特点" class="headerlink" title="Set集合的特点"></a>Set集合的特点</h2><p>元素唯一，不会出现重复的元素</p><h2 id="Set集合如何实现Key无重复的"><a href="#Set集合如何实现Key无重复的" class="headerlink" title="Set集合如何实现Key无重复的"></a>Set集合如何实现Key无重复的</h2><p>通过内部的数据结构（如哈希表、红黑树等）来实现Key的无重复。当向Set集合中插入元素时，会先根据以上的hashcode值来确定元素的存储位置，然后通过equals方法来判断是否已经存在相同的元素。<em>（如果存在就不会再次插入，保持了元素的唯一性。）</em></p><h2 id="有序的Set是什么"><a href="#有序的Set是什么" class="headerlink" title="有序的Set是什么"></a>有序的Set是什么</h2><p>TreeSet和LinkedHashSet。</p><p>前者基于红黑树实现，保证元素的自然顺序；后者基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序。</p><h2 id="记录插入顺序的集合是什么"><a href="#记录插入顺序的集合是什么" class="headerlink" title="记录插入顺序的集合是什么"></a>记录插入顺序的集合是什么</h2><p>通常指LinkedHashSet，不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/10/17/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/17/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><ul><li><strong>平台无关性</strong>：Java编写一次，运行无处不在。Java编译器将源代码编译成字节码，可以在任何安装了JVM的系统上运行。</li><li><strong>面向对象</strong>：Java是一门严格的面向对象的编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类、对象、继承、多态、抽象和封装。</li><li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关问题。</li></ul><h2 id="Java为什么是跨平台的"><a href="#Java为什么是跨平台的" class="headerlink" title="Java为什么是跨平台的"></a>Java为什么是跨平台的</h2><p>主要依赖于JVM。JVM也是一个软件，不同的平台有不同的版本。编写的Java源码编译后会生成一种.class文件，称为字节码文件。JVM就是负责将字节码文件翻译成特定平台下的机器码然后运行。只要在不同平台上安装对应的JVM就可以运行字节码文件，运行编写的Java程序。</p><p><em>（不同平台下编译生成的字节码是一样的，但是由 JVM编译成的机器码却不一样）</em></p><p><em>（跨平台的是 Java程序，不是 JVM。JVM是用 C&#x2F;C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM。）</em></p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713860588639-bb89fc8e-30b6-4d18-a329-f3fea52c729a.png" alt="img"></p><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p>JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p><h2 id="JVM、JDK、JRE三者的关系"><a href="#JVM、JDK、JRE三者的关系" class="headerlink" title="JVM、JDK、JRE三者的关系"></a>JVM、JDK、JRE三者的关系</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240725230247664.png" alt="image-20240725230247664"></p><ul><li>JVM是Java虚拟机，是Java程序运行的环境，负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li><li>JDK是Java开发工具包，是开发Java程序所需的工具集合。包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li><li>JRE是Java运行时的环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li></ul><h2 id="为什么Java解释和编译都有"><a href="#为什么Java解释和编译都有" class="headerlink" title="为什么Java解释和编译都有"></a>为什么Java解释和编译都有</h2><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤——编译和解释。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="img"></p><p><strong>编译性</strong>：</p><ul><li>Java源代码首先被编译成字节码，JIT会把编译过的机器码保存起来，以备下次使用。</li></ul><p><strong>解释性</strong>：</p><ul><li>JVM中有一个方法调用计数器，当累计计数大于一定值时，就使用JIT进行编译生成机器码文件，否则就使用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li></ul><p>所以Java既是编译性也是解释性语言，默认采用解释器和编译器混合的模式。</p><h2 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a><strong>编译型语言和解释型语言的区别？</strong></h2><p>编译型语言和解释型语言的区别在于：</p><ul><li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。</li><li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</li><li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li></ul><h2 id="Python和Java区别是什么？"><a href="#Python和Java区别是什么？" class="headerlink" title="Python和Java区别是什么？"></a>Python和Java区别是什么？</h2><ul><li>Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行</li><li>python是一种解释语言，翻译时会在执行程序的同时进行翻译。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><p>Java支持数据类型分为：<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><p>基本数据类型包括：</p><ul><li>数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</li><li>字符型：char</li><li>布尔型：boolean</li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p><p><strong>注意</strong>：</p><ul><li>java八种基本数据类型的字节数:1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li><li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li><li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li><li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li><li>char类型是无符号的，不能为负，所以是0开始的</li></ul><h2 id="数据类型转换方式"><a href="#数据类型转换方式" class="headerlink" title="数据类型转换方式"></a>数据类型转换方式</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240726003850183.png" alt="image-20240726003850183"></p><ul><li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。</li><li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。</li><li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。</li><li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。</li></ul><h2 id="类型互转会出现什么问题"><a href="#类型互转会出现什么问题" class="headerlink" title="类型互转会出现什么问题"></a>类型互转会出现什么问题</h2><ul><li>数据丢失：大类型转小类型，可能截断后高位丢失，如long转int</li><li>数据溢出：如double转int</li><li>精度损失：浮点数类型转换，如float转double</li><li>类型不匹配</li></ul><h2 id="为什么用bigDecimal而不用double"><a href="#为什么用bigDecimal而不用double" class="headerlink" title="为什么用bigDecimal而不用double"></a>为什么用bigDecimal而不用double</h2><p>double执行二进制浮点运算，会出现精度丢失，Decimal是精确运算，一般用于金钱的运算。</p><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p><p>eg. Integer i &#x3D; 10；&#x2F;&#x2F;装箱</p><p>​int n &#x3D; i；&#x2F;&#x2F;拆箱</p><p>自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p><p><strong>赋值时</strong>：</p><p>最常见的一种情况，Java1.5前需要手动转换，现在所有转换由编译器完成。</p><p><strong>方法调用时</strong>：</p><p>可以传入原始数据值或者对象，同样编译器会帮我们转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p><strong>自动装箱的弊端</strong>：</p><p>如果在一个循环中进行自动装箱操作，下面的例子会创建多个多余的对象，影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>sum进行自动拆箱，然后数值相加，最好自动装箱转换成Integer对象。所以循环中会创建4000个无用的Integer对象，会降低程序性能并且加重垃圾回收的工作量。所以应该正确声明变量类型，避免自动装箱引起的性能问题。</p><h2 id="Java为什么要有Integer"><a href="#Java为什么要有Integer" class="headerlink" title="Java为什么要有Integer"></a>Java为什么要有Integer</h2><ul><li><p>Integer是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性（数据）跟处理这些数据的方法结合在一起。（比如Integer中的parseInt()等方法）。</p></li><li><p>Java绝大部分方法或类都是用来处理类类型对象的。</p><ul><li><p>泛型中：只能使用引用类型，而不能使用基本类型。如果在泛型中使用int类型，就必须使用Integer包装类。（例如：Collections.sort()内部放Integer而不是int。）</p></li><li><p>转换中：基本类型和引用类型不能直接进行转换，必须使用包装类来实现。（例如，int不能直接转成String，需要先转换成Integer类型，再转成String类型。）</p></li><li><p>集合中：Java集合只能存储对象，而不能存储基本数据类型。（例如，ArrayList集合类就只能以类作为他的存储对象，如果用Integer包装类，可以直接使用stream()方法来计算所有元素的和：int sum &#x3D; list.stream().mapToInt(Integer::intValue).sum();）</p></li></ul></li></ul><h2 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h2><ul><li>类型：int是基本数据类型，Integer是引用类型。前者是预定义的，不需要实例化就可以使用，而后者需要通过实例化对象来使用。意味着前者不需要额外的内存分配，而后者必须为对象分配内存。性能方面，前者通常较快。</li><li>自动装箱与拆箱：可以自动装箱和拆箱。</li><li>空指针异常：int可以直接赋值为0，而Integer必须实例化对象来赋值，否则操作时会出现空指针异常，因为被赋予了null值，而null值无法自动拆箱。</li></ul><h2 id="为什么要保留int类型"><a href="#为什么要保留int类型" class="headerlink" title="为什么要保留int类型"></a>为什么要保留int类型</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身，所以基本数据类型读写效率更高。此外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存方面，而一个int类型数据只占用4字节的内存空间。所以读写效率和存储效率基本类型都比包装类高效。</p><h2 id="Integer的缓存"><a href="#Integer的缓存" class="headerlink" title="Integer的缓存"></a>Integer的缓存</h2><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。默认情况下这个范围是-128-127，当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><p>面向对象是一种编程范式，<strong>将现实世界中的事物抽象成对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的性能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul><li><strong>封装</strong>：将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。目的是增强安全性和简化编程，使对象更加独立。</li><li><strong>继承</strong>：使得子类自动共享父类数据结构和方法的机制。是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li><li><strong>多态</strong>：允许不同类的对象对同一消息作出响应，即同一个接口，使得不同的实例而执行不同操作、可分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。</li></ul><h2 id="多态体现在哪几个方面"><a href="#多态体现在哪几个方面" class="headerlink" title="多态体现在哪几个方面"></a>多态体现在哪几个方面</h2><ul><li><strong>方法重载</strong>：指同一个类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但传入的参数不同，编译器会在编译时确定调用哪个方法。<ul><li>示例：对于一个add方法，可以定义为add(int a, int b)和add(double a, double b)。</li></ul></li><li><strong>方法重写</strong>：指子类能够提供父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。<ul><li>示例：在一个动物类中，定义一个sound方法，子类Dog可以重写该方法以实现bark，而Cat可以实现meow。</li></ul></li><li><strong>接口与实现</strong>：多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法，使得程序在面对不同具体实现时保持一贯的调用方式。<ul><li>示例：多个类（如Dog，cat）都实现了一个Animal接口，当用Animal类型的引用来调用makeSound方法时，会触发对应的实现。</li></ul></li><li><strong>向下转型和向上转型</strong>：向上转型：可以使用父类类型的引用指向子类对象，这样可以在运行时采用不同的子类实现；向下转型：父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免ClassCastException。</li></ul><h2 id="多态解决了什么问题"><a href="#多态解决了什么问题" class="headerlink" title="多态解决了什么问题"></a>多态解决了什么问题</h2><p><em>多态指子类可以替换父类，在实际的代码运行中调用子类的方法实现。</em></p><p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的if-else语句等。</p><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><ul><li><strong>单一职责原则（SRP）</strong>：一个类只负责处理一种改变（一项职责）。</li><li><strong>开放封闭原则（OCP）</strong>：对扩展开放，对修改关闭。</li><li><strong>里氏替换原则（LSP）</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。子类继承父类时，除了添加新的方法完成新增功能外，尽量不要重写父类的方法。</li><li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li><li><strong>最少知识原则（迪米特法则）（Law of Demeter）</strong>：一个对象应当对其他对象有尽可能少的了解。</li><li><strong>组合&#x2F;聚合复用原则</strong>：优先使用对象组合，而不是类继承。</li></ul><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul><li><strong>重载</strong>：同一个类中可以定义多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序），编译器会根据调用时的参数类型决定调用哪个方法。</li><li><strong>重写</strong>：子类重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@Override注解来表示重写。</li></ul><h2 id="抽象类和普通类的区别"><a href="#抽象类和普通类的区别" class="headerlink" title="抽象类和普通类的区别"></a>抽象类和普通类的区别</h2><ul><li><strong>实例化</strong>：普通类可以直接使用new关键字来实例化对象；而抽象类不能直接实例化，只能被继承。</li><li><strong>方法实现</strong>：普通类的方法可以有具体实现；而抽象类中没有方法体，必须在继承它的子类中被重写（除非子类也是抽象类）。</li><li><strong>继承</strong>：一个类可以继承一个普通类，继承后的新类可以选择重写父类的方法，而且可以继承多个接口；而一个类只能继承一个抽象类，子类必须实现父类中的所有抽象方法，除非子类也是抽象类，但可以同时实现多个接口。</li><li><strong>实现限制（用途）</strong>：普通类可以被其他类继承和使用；而抽象类一般用于作为基类，被其他类继承和扩展使用。</li></ul><h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p><strong>两者特点</strong>：</p><ul><li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li><li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java8以后可以有默认方法和静态方法）。适用于定义类的能力和功能。</li></ul><p><strong>区别</strong>：</p><ul><li><strong>实现方式</strong>：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li><li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可以在抽象类中实现。</li><li><strong>访问修饰符</strong>：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可以被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li><li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态变量）。</li></ul><h2 id="抽象类能否加final修饰"><a href="#抽象类能否加final修饰" class="headerlink" title="抽象类能否加final修饰"></a>抽象类能否加final修饰</h2><p>不能。</p><p>Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p><h2 id="接口里面可以定义的方法"><a href="#接口里面可以定义的方法" class="headerlink" title="接口里面可以定义的方法"></a>接口里面可以定义的方法</h2><ul><li><strong>抽象方法</strong>：接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是public和abstract，这些修饰符可以省略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>默认方法</strong></li></ul><p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>静态方法</strong></li></ul><p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>私有方法</strong></li></ul><p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类能否被实例化"><a href="#抽象类能否被实例化" class="headerlink" title="抽象类能否被实例化"></a>抽象类能否被实例化</h2><p>不能。</p><p>所以不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p><p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码可以运行</span></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure><p>在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。</p><p>简而言之，抽象类不能直接实例化，但<strong>通过继承抽象类</strong>并<strong>实现所有抽象方法</strong>的子类是可以被实例化的。</p><h2 id="接口能否包含构造函数"><a href="#接口能否包含构造函数" class="headerlink" title="接口能否包含构造函数"></a>接口能否包含构造函数</h2><p>在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p><p><em>（构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用。）</em></p><p>java的接口不能new所以不需要构造函数，根本就没法调用。</p><h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><p>二者与类本身关联，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</p><p><strong>静态变量</strong>（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p><ul><li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li><li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次分配内存。</li><li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</li></ul><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int staticVar = 0; // 静态变量</span><br><span class="line"></span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        staticVar++; // 每创建一个对象，静态变量自增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void printStaticVar() &#123;</span><br><span class="line">        System.out.println(&quot;Static Var: &quot; + staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = new MyClass();</span><br><span class="line">MyClass.printStaticVar(); // 输出 Static Var: 2</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong>是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p><ul><li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</li><li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</li><li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static void incrementCount() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void displayCount() &#123;</span><br><span class="line">        System.out.println(&quot;Count: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass.incrementCount(); // 调用静态方法</span><br><span class="line">MyClass.displayCount();   // 输出 Count: 1</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>静态变量</strong>：常用于需要在所有对象间共享的数据，如计数器、常量等。</li><li><strong>静态方法</strong>：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理</li></ul><h2 id="非静态内部类和静态内部类的区别"><a href="#非静态内部类和静态内部类的区别" class="headerlink" title="非静态内部类和静态内部类的区别"></a>非静态内部类和静态内部类的区别</h2><ul><li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li><li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</li><li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li><li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li><li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li></ul><h2 id="非静态内部类可以直接访问外部方法，编译器是怎么做到的"><a href="#非静态内部类可以直接访问外部方法，编译器是怎么做到的" class="headerlink" title="非静态内部类可以直接访问外部方法，编译器是怎么做到的"></a>非静态内部类可以直接访问外部方法，编译器是怎么做到的</h2><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p><p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</p><h2 id="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"><a href="#有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的" class="headerlink" title="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"></a>有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的</h2><p>当实例化一个子类对象时，静态成员变量、静态构造方法和静态方法的加载顺序遵循以下步骤：</p><ul><li>在创建子类对象之前，首先会加载父类的静态成员变量和静态代码块（构造方法无法被 <code>static</code> 修饰，因此这里是静态代码块）。这个加载是在类首次被加载时进行的，且只会发生一次。</li><li>接下来，加载子类的静态成员变量和静态代码块。这一过程也只发生一次，即当首次使用子类的相关代码时。</li><li>之后，执行实例化子类对象的过程。这时会呼叫父类构造方法，然后是子类的构造方法。</li></ul><p>具体加载顺序可以简要总结为：</p><ul><li><strong>父类静态成员变量、静态代码块</strong>（如果有）</li><li><strong>子类静态成员变量、静态代码块</strong>（如果有）</li><li><strong>父类构造方法</strong>（实例化对象时）</li><li><strong>子类构造方法</strong>（实例化对象时）</li></ul><p><strong>示例代码</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">parentStaticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">childStaticVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Child() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line">Child <span class="keyword">static</span> block</span><br><span class="line">Parent constructor</span><br><span class="line">Child constructor</span><br></pre></td></tr></table></figure><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="img"></p><ul><li><strong>浅拷贝</strong>：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。相当于只是创建了一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型字段，只是将引用复制到新对象中，两个对象指向同一个引用对象。</li><li><strong>深拷贝</strong>：复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。相当于会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li></ul><h2 id="实现深拷贝的三种方法"><a href="#实现深拷贝的三种方法" class="headerlink" title="实现深拷贝的三种方法"></a>实现深拷贝的三种方法</h2><ul><li>实现 Cloneable 接口并重写 clone() 方法</li></ul><p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用序列化和反序列化</li></ul><p>通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动递归复制</li></ul><p>针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p><p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。</p><h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><ul><li><strong>适用于多种数据类型执行相同的代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。</p><p>引入泛型，它将提供类型的约束，提供编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><p><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><p><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure><p><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure><p><strong>使用clone()方法</strong>：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure><p><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SerializedObject.java</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeserializedObject.java</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h2 id="Java创建对象除了new还有什么方式"><a href="#Java创建对象除了new还有什么方式" class="headerlink" title="Java创建对象除了new还有什么方式"></a>Java创建对象除了new还有什么方式</h2><ul><li><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过反序列化创建对象</strong>：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过clone创建对象</strong>：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new出的对象什么时候回收"><a href="#new出的对象什么时候回收" class="headerlink" title="new出的对象什么时候回收"></a>new出的对象什么时候回收</h2><p>由Java的垃圾回收器（Garbage Collector）负责回收。其工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p><p>回收的算法：</p><ul><li><strong>引用计数法</strong>：个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li><li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li><li><strong>终结器</strong>：如果对象重写了finalize()方法，垃圾回收器会在回收对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。但是由于终结器机制的执行时间不确定，可能会导致不可预测的问题，所以不推荐使用。</li></ul><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p><h2 id="反射的特性"><a href="#反射的特性" class="headerlink" title="反射的特性"></a>反射的特性</h2><ul><li><p><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</p></li><li><p><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</p></li><li><p><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</p></li><li><p><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</p></li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="img"></p><h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><ul><li><strong>加载数据库驱动</strong></li></ul><p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。</p><p>这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>配置文件加载</strong></li></ul><p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><p>Spring通过XML配置模式装载Bean的过程：</p><ul><li>将程序中所有XML或properties配置文件加载入内存</li><li>Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li><li>使用反射机制，根据这个字符串获得某个类的Class实例</li><li>动态配置实例的属性</li></ul><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析配置文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestInvoke</span><br><span class="line">I am fine</span><br></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p><p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h2 id="注解的作用域"><a href="#注解的作用域" class="headerlink" title="注解的作用域"></a>注解的作用域</h2><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p><ul><li><p>类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</p></li><li><p>方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</p></li><li><p>字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</p></li></ul><p>除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="介绍一下异常"><a href="#介绍一下异常" class="headerlink" title="介绍一下异常"></a>介绍一下异常</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="img"></p><ul><li><strong>Error（错误）</strong>：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常程序不应该捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。</li><li><strong>Exception（异常）</strong>：表示程序本身可以处理的异常事件。<ul><li><strong>非运行时异常</strong>：在编译时必须被捕获或者声明抛出。通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。这种异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li><li><strong>运行时异常（RuntimeException）</strong>：由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。这种异常不需要在编译时强制捕获或声明。</li></ul></li></ul><h2 id="Java异常处理有哪些"><a href="#Java异常处理有哪些" class="headerlink" title="Java异常处理有哪些"></a>Java异常处理有哪些</h2><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p><ul><li>try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType3 e3) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionType(&quot;Exception message&quot;);</span><br></pre></td></tr></table></figure><ul><li>throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常为什么不用throws"><a href="#抛出异常为什么不用throws" class="headerlink" title="抛出异常为什么不用throws"></a>抛出异常为什么不用throws</h2><p>如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。</p><ul><li><strong>Unchecked Exceptions</strong>：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。</li><li><strong>捕获和处理异常</strong>：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。</li></ul><h2 id="try-catch中的语句运行情况"><a href="#try-catch中的语句运行情况" class="headerlink" title="try-catch中的语句运行情况"></a>try-catch中的语句运行情况</h2><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。</p><h2 id="try-return-“a”-fianlly-return-“b”-这条语句返回什么"><a href="#try-return-“a”-fianlly-return-“b”-这条语句返回什么" class="headerlink" title="try{return “a”} fianlly{return “b”}这条语句返回什么"></a>try{return “a”} fianlly{return “b”}这条语句返回什么</h2><p>finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。</p><h1 id="object"><a href="#object" class="headerlink" title="object"></a>object</h1><h2 id="与-equals-有什么区别？"><a href="#与-equals-有什么区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals 有什么区别？"></a>&#x3D;&#x3D; 与 equals 有什么区别？</h2><p>对于字符串变量来说，使用”=&#x3D;”和”equals”比较字符串时，其比较方法不同。”&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址，”equals”比较字符串包含内容是否相同。</p><p>对于非字符串变量来说，如果没有对equals()进行重写的话，”&#x3D;&#x3D;” 和 “equals”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。</p><ul><li>&#x3D;&#x3D;：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</li><li>equals()：比较的是两个字符串的内容，属于内容比较。</li></ul><h2 id="StringBuffer和StringBuild区别是什么？"><a href="#StringBuffer和StringBuild区别是什么？" class="headerlink" title="StringBuffer和StringBuild区别是什么？"></a>StringBuffer和StringBuild区别是什么？</h2><p>区别：</p><ul><li>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</li><li>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</li><li>StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</li></ul><p>线程安全：</p><ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul><p>速度：</p><ul><li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li></ul><p>使用场景：</p><ul><li>操作少量的数据使用 String。</li><li>单线程操作大量数据使用 StringBuilder。</li><li>多线程操作大量数据使用 StringBuffer。</li></ul><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716098439957-a080de5a-d69e-4c6e-a5e8-111f976f9b5b.webp" alt="img"></p><h1 id="Java-1-8-新特性"><a href="#Java-1-8-新特性" class="headerlink" title="Java 1.8 新特性"></a>Java 1.8 新特性</h1><h2 id="stream的API"><a href="#stream的API" class="headerlink" title="stream的API"></a>stream的API</h2><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理。</p><p>适用场景举例：</p><ul><li>场景一：过滤并收集满足条件的元素</li></ul><p>eg. 从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。</p><p><strong>没有Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。</p><p><strong>使用Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>这里，我们直接在原始列表上调用.stream()方法创建了一个流，使用.filter()中间操作筛选出长度大于3的字符串，最后使用.collect(Collectors.toList())终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。</p><ul><li>场景二：计算列表中所有数字的总和</li></ul><p>eg. 计算一个数字列表中所有元素的总和。</p><p><strong>没有Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。</p><p><strong>使用Stream API的做法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure><p>通过Stream API，我们可以先使用.mapToInt()将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用.sum()方法来计算总和，极大地简化了代码。</p><h2 id="Stream流的并行API是什么？"><a href="#Stream流的并行API是什么？" class="headerlink" title="Stream流的并行API是什么？"></a>Stream流的并行API是什么？</h2><p>是 ParallelStream。</p><p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。</p><p>Stream串行流与并行流的主要区别：</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="img"></p><p>对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I&#x2F;O密集的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择。</p><h2 id="completableFuture怎么用的？"><a href="#completableFuture怎么用的？" class="headerlink" title="completableFuture怎么用的？"></a>completableFuture怎么用的？</h2><p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p><ul><li>Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。</li><li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。</li></ul><p>下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。</p><p>Future(ListenableFuture)的实现（回调地狱）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure><p>CompletableFuture的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure><p>显然，CompletableFuture的实现更为简洁，可读性更好。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="img"></p><p>CompletableFuture实现了两个接口（如上图所示)：Future、CompletionStage。</p><ul><li>Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。</li><li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="怎么把一个对象从一个jvm转移到另一个jvm?"></a>怎么把一个对象从一个jvm转移到另一个jvm?</h2><ul><li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li><li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li><li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li><li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li></ul><h2 id="序列化和反序列化的缺点"><a href="#序列化和反序列化的缺点" class="headerlink" title="序列化和反序列化的缺点"></a>序列化和反序列化的缺点</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。</p><ul><li>无法跨语言： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</li><li>容易被攻击：Java 序列化是不安全的，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。</li><li>序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</li></ul><h2 id="那么该如何实现"><a href="#那么该如何实现" class="headerlink" title="那么该如何实现"></a>那么该如何实现</h2><p>考虑用主流序列化框架，比如FastJson、Protobuf来替代Java序列化。</p><p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。</p><h2 id="将对象转为二进制字节流具体怎么实现"><a href="#将对象转为二进制字节流具体怎么实现" class="headerlink" title="将对象转为二进制字节流具体怎么实现?"></a>将对象转为二进制字节流具体怎么实现?</h2><p>像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。</p><p>在Java中通过序列化对象流来完成序列化和反序列化：</p><ul><li>ObjectOutputStream：通过writeObject(）方法做序列化操作。</li><li>ObjectInputStrean：通过readObject()方法做反序列化操作。</li></ul><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p><p>实现对象序列化：</p><ul><li>让类实现Serializable接口：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建输出流并写入对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现对象反序列化：</p><ul><li>创建输入流并读取对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="volatile和sychronized如何实现单例模式"><a href="#volatile和sychronized如何实现单例模式" class="headerlink" title="volatile和sychronized如何实现单例模式"></a>volatile和sychronized如何实现单例模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字修饰变量 防止指令重排序</span></span><br><span class="line">    private <span class="keyword">static</span> volatile <span class="title class_">SingleTon</span> instance = <span class="literal">null</span>;</span><br><span class="line">    private <span class="title class_">SingleTon</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">static</span>  <span class="title class_">SingleTon</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块 只有在第一次获取对象的时候会执行到，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦</span></span><br><span class="line">            <span class="title function_">synchronized</span>(<span class="params">SingleTon.<span class="keyword">class</span></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。</p><ul><li>保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。</li><li>禁止指令重排序优化。</li></ul><p>由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p><h2 id="代理模式和适配器模式有什么区别？"><a href="#代理模式和适配器模式有什么区别？" class="headerlink" title="代理模式和适配器模式有什么区别？"></a>代理模式和适配器模式有什么区别？</h2><ul><li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。</li><li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。</li><li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。</li></ul><h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Java怎么实现网络IO高并发编程？"><a href="#Java怎么实现网络IO高并发编程？" class="headerlink" title="Java怎么实现网络IO高并发编程？"></a><strong>Java怎么实现网络IO高并发编程？</strong></h2><p>可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112641716.png" alt="image-20240820112641716"></p><p>NIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112656259.png" alt="image-20240820112656259"></p><h2 id="BIO、NIO、AIO区别是什么？"><a href="#BIO、NIO、AIO区别是什么？" class="headerlink" title="BIO、NIO、AIO区别是什么？"></a>BIO、NIO、AIO区别是什么？</h2><ul><li>BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul><h2 id="NIO是怎么实现的？"><a href="#NIO是怎么实现的？" class="headerlink" title="NIO是怎么实现的？"></a>NIO是怎么实现的？</h2><p>NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。</p><p>同步的核心就Selector（I&#x2F;O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。</p><p>NIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。</p><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p><p>Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="img"></p><h2 id="有哪个框架用到NIO了吗？"><a href="#有哪个框架用到NIO了吗？" class="headerlink" title="有哪个框架用到NIO了吗？"></a>有哪个框架用到NIO了吗？</h2><p><strong>Netty。</strong></p><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="img"></p><p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">// 添加学生对象到列表中</span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure><h2 id="Native方法解释一下"><a href="#Native方法解释一下" class="headerlink" title="Native方法解释一下"></a>Native方法解释一下</h2><p>在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。</p><p>在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现native方法，你需要完成以下步骤：</p><ol><li><strong>生成JNI头文件</strong>：使用javah工具从你的Java类生成C&#x2F;C++的头文件，这个头文件包含了所有native方法的原型。</li><li><strong>编写本地代码</strong>：使用C&#x2F;C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。</li><li><strong>编译本地代码</strong>：将C&#x2F;C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）</li><li><strong>加载本地库</strong>：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145028364.png" alt="image-20240814145028364"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145056943.png" alt="image-20240814145056943"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145133144.png" alt="image-20240814145133144"></p><h1 id="客户-服务器方式和对等方式"><a href="#客户-服务器方式和对等方式" class="headerlink" title="客户-服务器方式和对等方式"></a>客户-服务器方式和对等方式</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145212152.png" alt="image-20240814145212152"></p><h2 id="C-S方式"><a href="#C-S方式" class="headerlink" title="C&#x2F;S方式"></a>C&#x2F;S方式</h2><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145533399.png" alt="image-20240814145533399"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145557894.png" alt="image-20240814145557894"></p><h2 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h2><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145720582.png" alt="image-20240814145720582"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145740501.png" alt="image-20240814145740501"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145828368.png" alt="image-20240814145828368"></p><h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814145940754.png" alt="image-20240814145940754"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150003692.png" alt="image-20240814150003692"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150312518.png" alt="image-20240814150312518"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150257580.png" alt="image-20240814150257580"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150351930.png" alt="image-20240814150351930"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150416657.png" alt="image-20240814150416657"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150542283.png" alt="image-20240814150542283"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150604076.png" alt="image-20240814150604076"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150630692.png" alt="image-20240814150630692"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814150854576.png" alt="image-20240814150854576"></p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151011045.png" alt="image-20240814151011045"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151041427.png" alt="image-20240814151041427"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151120515.png" alt="image-20240814151120515"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151219973.png" alt="image-20240814151219973"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814151248886.png" alt="image-20240814151248886"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152200176.png" alt="image-20240814152200176"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152300753.png" alt="image-20240814152300753"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152329601.png" alt="image-20240814152329601"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152352852.png" alt="image-20240814152352852"></p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152818541.png" alt="image-20240814152818541" style="zoom:80%;"><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152725867.png" alt="image-20240814152725867"></p><h1 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814152906799.png" alt="image-20240814152906799"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153752164.png" alt="image-20240814153752164"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153700428.png" alt="image-20240814153700428"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153846608.png" alt="image-20240814153846608"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814153934314.png" alt="image-20240814153934314"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154019389.png" alt="image-20240814154019389"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154122663.png" alt="image-20240814154122663"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154223820.png" alt="image-20240814154223820"></p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814154259210.png" alt="image-20240814154259210"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160421162.png" alt="image-20240814160421162"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160450645.png" alt="image-20240814160450645"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160606888.png" alt="image-20240814160606888"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160613521.png" alt="image-20240814160613521"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160702858.png" alt="image-20240814160702858"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160740305.png" alt="image-20240814160740305"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160759152.png" alt="image-20240814160759152"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160859362.png" alt="image-20240814160859362"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814160951504.png" alt="image-20240814160951504"></p><h1 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h1><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161135431.png" alt="image-20240814161135431"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161200612.png" alt="image-20240814161200612"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161240233.png" alt="image-20240814161240233"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161316978.png" alt="image-20240814161316978"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161709904.png" alt="image-20240814161709904"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161743596.png" alt="image-20240814161743596"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161811782.png" alt="image-20240814161811782"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161920500.png" alt="image-20240814161920500"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161927901.png" alt="image-20240814161927901"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814161948924.png" alt="image-20240814161948924"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162012460.png" alt="image-20240814162012460"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162051922.png" alt="image-20240814162051922"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162139785.png" alt="image-20240814162139785"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162230627.png" alt="image-20240814162230627"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162353628.png" alt="image-20240814162353628"></p><p><strong>若Web缓存的命中率比较高，则大大减少了该链路上的通信量，因此减少了访问因特网的时延。</strong></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162552152.png" alt="image-20240814162552152"></p><p>若已过期，则如下图：</p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162532542.png" alt="image-20240814162532542"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162708178.png" alt="image-20240814162708178"></p><p><img src="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240814162749726.png" alt="image-20240814162749726"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191337579.png" alt="image-20240813191337579"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191428500.png" alt="image-20240813191428500"></p><h1 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191540313.png" alt="image-20240813191540313"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191728152.png" alt="image-20240813191728152"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191749334.png" alt="image-20240813191749334"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191859414.png" alt="image-20240813191859414"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813191939871.png" alt="image-20240813191939871"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192023369.png" alt="image-20240813192023369"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192100188.png" alt="image-20240813192100188"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192132584.png" alt="image-20240813192132584"></p><h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192240304.png" alt="image-20240813192240304"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192338267.png" alt="image-20240813192338267"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192410822.png" alt="image-20240813192410822"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192512481.png" alt="image-20240813192512481"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192628455.png" alt="image-20240813192628455"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192659817.png" alt="image-20240813192659817"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192709502.png" alt="image-20240813192709502"></p><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813192759530.png" alt="image-20240813192759530"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193254468.png" alt="image-20240813193254468"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193014418.png" alt="image-20240813193014418"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193140423.png" alt="image-20240813193140423"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240813193221498.png" alt="image-20240813193221498"></p><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102444644.png" alt="image-20240814102444644"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102509059.png" alt="image-20240814102509059"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102546596.png" alt="image-20240814102546596"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102755530.png" alt="image-20240814102755530"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102848409.png" alt="image-20240814102848409"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814102932658.png" alt="image-20240814102932658"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103106041.png" alt="image-20240814103106041"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103136291.png" alt="image-20240814103136291"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814103253170.png" alt="image-20240814103253170"></p><h1 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114522435.png" alt="image-20240814114522435"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114600883.png" alt="image-20240814114600883"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114636925.png" alt="image-20240814114636925"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814114841235.png" alt="image-20240814114841235"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115004457.png" alt="image-20240814115004457"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115046267.png" alt="image-20240814115046267"></p><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115512173.png" alt="image-20240814115512173"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115551907.png" alt="image-20240814115551907"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115756066.png" alt="image-20240814115756066"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814115908782.png" alt="image-20240814115908782"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120023961.png" alt="image-20240814120023961"></p><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120107047.png" alt="image-20240814120107047"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120123394.png" alt="image-20240814120123394"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120330906.png" alt="image-20240814120330906"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120601606.png" alt="image-20240814120601606"></p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120610887.png" alt="image-20240814120610887" style="zoom:67%;"><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814120820903.png" alt="image-20240814120820903"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814121911333.png" alt="image-20240814121911333"></p><p>若不等待2MSL，则如下图</p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122043286.png" alt="image-20240814122043286"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122153570.png" alt="image-20240814122153570"></p><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122324269.png" alt="image-20240814122324269"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123143671.png" alt="image-20240814123143671"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122407436.png" alt="image-20240814122407436"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122524309.png" alt="image-20240814122524309"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122543714.png" alt="image-20240814122543714"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122558058.png" alt="image-20240814122558058"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122635196.png" alt="image-20240814122635196"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122657087.png" alt="image-20240814122657087"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122719616.png" alt="image-20240814122719616"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122728111.png" alt="image-20240814122728111"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122746186.png" alt="image-20240814122746186"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122818216.png" alt="image-20240814122818216"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122857566.png" alt="image-20240814122857566"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122923360.png" alt="image-20240814122923360"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814122956048.png" alt="image-20240814122956048"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123010140.png" alt="image-20240814123010140"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123037611.png" alt="image-20240814123037611"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123103340.png" alt="image-20240814123103340"></p><p><img src="/2024/08/13/%E8%BF%90%E8%BE%93%E5%B1%82/image-20240814123118430.png" alt="image-20240814123118430"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812201248589.png" alt="image-20240812201248589"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812201327196.png" alt="image-20240812201327196"></p><h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205024568.png" alt="image-20240812205024568"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205120097.png" alt="image-20240812205120097"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205133787.png" alt="image-20240812205133787"></p><h1 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205211373.png" alt="image-20240812205211373"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205257315.png" alt="image-20240812205257315"></p><h2 id="分类编址的IPv4服务"><a href="#分类编址的IPv4服务" class="headerlink" title="分类编址的IPv4服务"></a>分类编址的IPv4服务</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205437686.png" alt="image-20240812205437686"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205613833.png" alt="image-20240812205613833"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205733387.png" alt="image-20240812205733387"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205818054.png" alt="image-20240812205818054"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205855760.png" alt="image-20240812205855760"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205933774.png" alt="image-20240812205933774"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812205946994.png" alt="image-20240812205946994"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210127298.png" alt="image-20240812210127298"></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210245529.png" alt="image-20240812210245529"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210307165.png" alt="image-20240812210307165"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210346139.png" alt="image-20240812210346139"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210806177.png" alt="image-20240812210806177"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210832696.png" alt="image-20240812210832696"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210852592.png" alt="image-20240812210852592"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210908542.png" alt="image-20240812210908542"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812210648408.png" alt="image-20240812210648408"></p><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211246069.png" alt="image-20240812211246069"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211317457.png" alt="image-20240812211317457"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211356139.png" alt="image-20240812211356139"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211505076.png" alt="image-20240812211505076"></p><h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212511827.png" alt="image-20240812212511827"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211758455.png" alt="image-20240812211758455"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211846486.png" alt="image-20240812211846486"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812211932600.png" alt="image-20240812211932600"></p><p>从子网1~8中任选5个分配给左图中的N1~N5</p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212323608.png" alt="image-20240812212323608"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240812212429093.png" alt="image-20240812212429093"></p><h1 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151158274.png" alt="image-20240813151158274"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151241091.png" alt="image-20240813151241091"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151306838.png" alt="image-20240813151306838"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813152058421.png" alt="image-20240813152058421"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151343600.png" alt="image-20240813151343600"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151416984.png" alt="image-20240813151416984"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151515452.png" alt="image-20240813151515452"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151808369.png" alt="image-20240813151808369"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813151834342.png" alt="image-20240813151834342"></p><h1 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813152127920.png" alt="image-20240813152127920"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160658240.png" alt="image-20240813160658240"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160037987.png" alt="image-20240813160037987"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160208394.png" alt="image-20240813160208394"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160309433.png" alt="image-20240813160309433"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160359795.png" alt="image-20240813160359795"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160514548.png" alt="image-20240813160514548"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160610452.png" alt="image-20240813160610452"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160712299.png" alt="image-20240813160712299"></p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813160826607.png" alt="image-20240813160826607"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161005663.png" alt="image-20240813161005663"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161059383.png" alt="image-20240813161059383"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813161145597.png" alt="image-20240813161145597"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163521582.png" alt="image-20240813163521582"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163554414.png" alt="image-20240813163554414"></p><h2 id="RIP的基本工作原理"><a href="#RIP的基本工作原理" class="headerlink" title="RIP的基本工作原理"></a>RIP的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163650949.png" alt="image-20240813163650949"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163741435.png" alt="image-20240813163741435"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813163821659.png" alt="image-20240813163821659"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164029695.png" alt="image-20240813164029695"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164440827.png" alt="image-20240813164440827"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164515494.png" alt="image-20240813164515494"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813164643536.png" alt="image-20240813164643536"></p><h2 id="开放最短路径优先OSPF的基本工作原理"><a href="#开放最短路径优先OSPF的基本工作原理" class="headerlink" title="开放最短路径优先OSPF的基本工作原理"></a>开放最短路径优先OSPF的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813165529224.png" alt="image-20240813165529224"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813165603466.png" alt="image-20240813165603466"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170002116.png" alt="image-20240813170002116"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170058350.png" alt="image-20240813170058350"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170312189.png" alt="image-20240813170312189"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170336748.png" alt="image-20240813170336748"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170417287.png" alt="image-20240813170417287"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170500348.png" alt="image-20240813170500348"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170554159.png" alt="image-20240813170554159"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170723337.png" alt="image-20240813170723337"></p><h2 id="边界网关协议BGP的基本工作原理"><a href="#边界网关协议BGP的基本工作原理" class="headerlink" title="边界网关协议BGP的基本工作原理"></a>边界网关协议BGP的基本工作原理</h2><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170812638.png" alt="image-20240813170812638"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813170934632.png" alt="image-20240813170934632"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171009427.png" alt="image-20240813171009427"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171036364.png" alt="image-20240813171036364"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171106065.png" alt="image-20240813171106065"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171127832.png" alt="image-20240813171127832"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813171307237.png" alt="image-20240813171307237"></p><h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172023580.png" alt="image-20240813172023580"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172329225.png" alt="image-20240813172329225"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172429600.png" alt="image-20240813172429600"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172616881.png" alt="image-20240813172616881"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172636415.png" alt="image-20240813172636415"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172759368.png" alt="image-20240813172759368"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172857248.png" alt="image-20240813172857248"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813172925377.png" alt="image-20240813172925377"></p><h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182228362.png" alt="image-20240813182228362"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182303630.png" alt="image-20240813182303630"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182334996.png" alt="image-20240813182334996"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182410662.png" alt="image-20240813182410662"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182419437.png" alt="image-20240813182419437"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182443369.png" alt="image-20240813182443369"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182514899.png" alt="image-20240813182514899"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182536842.png" alt="image-20240813182536842"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182632326.png" alt="image-20240813182632326"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813182926421.png" alt="image-20240813182926421"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813183000508.png" alt="image-20240813183000508"></p><h1 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h1><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813184743437.png" alt="image-20240813184743437"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813185043444.png" alt="image-20240813185043444"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813185112872.png" alt="image-20240813185112872"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190521871.png" alt="image-20240813190521871"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190622629.png" alt="image-20240813190622629"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190710951.png" alt="image-20240813190710951"></p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190729005.png" alt="image-20240813190729005" style="zoom:67%;"><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190759977.png" alt="image-20240813190759977"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190824343.png" alt="image-20240813190824343"></p><p><img src="/2024/08/12/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240813190847503.png" alt="image-20240813190847503"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200439428.png" alt="image-20240811200439428"></p><p> <img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200621626.png" alt="image-20240811200621626"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200703874.png" alt="image-20240811200703874"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811200836633.png" alt="image-20240811200836633"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201003064.png" alt="image-20240811201003064"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201036469.png" alt="image-20240811201036469"></p><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201415193.png" alt="image-20240811201415193"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811201646586.png" alt="image-20240811201646586"></p><p>在每5个连续的1后加一个0，确保了帧定界在整个帧中的唯一性（与帧头帧尾区分开）；</p><p>从物理层交付的比特流中提取帧时，将帧的数据部分中的每5个连续的比特1后面的那个比特0剔除即可。</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202150622.png" alt="image-20240811202150622"></p><h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202407835.png" alt="image-20240811202407835"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811202520317.png" alt="image-20240811202520317"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203429392.png" alt="image-20240811203429392"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203503802.png" alt="image-20240811203503802"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203557361.png" alt="image-20240811203557361"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203636275.png" alt="image-20240811203636275"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203826087.png" alt="image-20240811203826087"></p><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="可靠传输的基本概念"><a href="#可靠传输的基本概念" class="headerlink" title="可靠传输的基本概念"></a>可靠传输的基本概念</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811203946372.png" alt="image-20240811203946372"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204059585.png" alt="image-20240811204059585"></p><h2 id="可靠传输的实现机制"><a href="#可靠传输的实现机制" class="headerlink" title="可靠传输的实现机制"></a>可靠传输的实现机制</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204211275.png" alt="image-20240811204211275"></p><h3 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204345219.png" alt="image-20240811204345219"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204423460.png" alt="image-20240811204423460"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204550832.png" alt="image-20240811204550832"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811204642254.png" alt="image-20240811204642254"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205418830.png" alt="image-20240811205418830"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205447010.png" alt="image-20240811205447010"></p><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811205755977.png" alt="image-20240811205755977"></p><p><strong>累积确认</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210050686.png" alt="image-20240811210050686"></p><p>优点：即使确认分组丢失，发送方也可能不必重传</p><p>缺点：不能向发送方即使反映接收方已经正确接收的数据分组信息</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210317077.png" alt="image-20240811210317077"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210411671.png" alt="image-20240811210411671"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210503831.png" alt="image-20240811210503831"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210804540.png" alt="image-20240811210804540"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811210933593.png" alt="image-20240811210933593"></p><h3 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211033403.png" alt="image-20240811211033403"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211248655.png" alt="image-20240811211248655"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211339656.png" alt="image-20240811211339656"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211448408.png" alt="image-20240811211448408"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240811211615317.png" alt="image-20240811211615317"></p><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112454069.png" alt="image-20240812112454069"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112554216.png" alt="image-20240812112554216"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112728218.png" alt="image-20240812112728218"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112756706.png" alt="image-20240812112756706"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812112949890.png" alt="image-20240812112949890"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113020608.png" alt="image-20240812113020608"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113051032.png" alt="image-20240812113051032"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113144684.png" alt="image-20240812113144684"></p><h1 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h1><h2 id="媒体接入控制的基本概念"><a href="#媒体接入控制的基本概念" class="headerlink" title="媒体接入控制的基本概念"></a>媒体接入控制的基本概念</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113712904.png" alt="image-20240812113712904"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113518653.png" alt="image-20240812113518653"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812113659021.png" alt="image-20240812113659021"></p><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120612592.png" alt="image-20240812120612592"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120645749.png" alt="image-20240812120645749"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120710446.png" alt="image-20240812120710446"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812120752098.png" alt="image-20240812120752098"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812121837751.png" alt="image-20240812121837751"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122126917.png" alt="image-20240812122126917"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122236376.png" alt="image-20240812122236376"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122359973.png" alt="image-20240812122359973"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812122521074.png" alt="image-20240812122521074"></p><h2 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h2><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123741657.png" alt="image-20240812123741657"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123836878.png" alt="image-20240812123836878"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812123924519.png" alt="image-20240812123924519"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812124042252.png" alt="image-20240812124042252"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812124203154.png" alt="image-20240812124203154"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131743488.png" alt="image-20240812131743488"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131846382.png" alt="image-20240812131846382"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131933201.png" alt="image-20240812131933201"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812131952631.png" alt="image-20240812131952631"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132016992.png" alt="image-20240812132016992"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132336781.png" alt="image-20240812132336781"></p><h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h3><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132402876.png" alt="image-20240812132402876"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132436985.png" alt="image-20240812132436985"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812132517404.png" alt="image-20240812132517404"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135113752.png" alt="image-20240812135113752"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135154263.png" alt="image-20240812135154263"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135228961.png" alt="image-20240812135228961"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135244375.png" alt="image-20240812135244375"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135309513.png" alt="image-20240812135309513"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135358783.png" alt="image-20240812135358783"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812135437234.png" alt="image-20240812135437234"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143203410.png" alt="image-20240812143203410"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143304483.png" alt="image-20240812143304483"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143337676.png" alt="image-20240812143337676"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143442999.png" alt="image-20240812143442999"></p><p><strong>总结</strong>（易混淆知识分析）</p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143639019.png" alt="image-20240812143639019"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143709627.png" alt="image-20240812143709627"></p><h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143844676.png" alt="image-20240812143844676"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144054228.png" alt="image-20240812144054228"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812143946780.png" alt="image-20240812143946780"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144133180.png" alt="image-20240812144133180"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144244562.png" alt="image-20240812144244562"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144322168.png" alt="image-20240812144322168"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144358817.png" alt="image-20240812144358817"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144422749.png" alt="image-20240812144422749"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144500681.png" alt="image-20240812144500681"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812144542722.png" alt="image-20240812144542722"></p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152206920.png" alt="image-20240812152206920"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152333832.png" alt="image-20240812152333832"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152447381.png" alt="image-20240812152447381"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152622576.png" alt="image-20240812152622576"></p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152948508.png" alt="image-20240812152948508"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153013683.png" alt="image-20240812153013683"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152843468.png" alt="image-20240812152843468"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152858247.png" alt="image-20240812152858247"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812152931095.png" alt="image-20240812152931095"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153037913.png" alt="image-20240812153037913"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153103104.png" alt="image-20240812153103104"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153124385.png" alt="image-20240812153124385"></p><p><strong>总结</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812153240577.png" alt="image-20240812153240577"></p><h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812164411856.png" alt="image-20240812164411856"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812164505986.png" alt="image-20240812164505986"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165249996.png" alt="image-20240812165249996"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165331614.png" alt="image-20240812165331614"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165430951.png" alt="image-20240812165430951"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165618984.png" alt="image-20240812165618984"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165640565.png" alt="image-20240812165640565"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165650394.png" alt="image-20240812165650394"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165723103.png" alt="image-20240812165723103"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165752003.png" alt="image-20240812165752003"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165807890.png" alt="image-20240812165807890"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165820095.png" alt="image-20240812165820095"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812165925100.png" alt="image-20240812165925100"></p><h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170011452.png" alt="image-20240812170011452"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170142508.png" alt="image-20240812170142508"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170214302.png" alt="image-20240812170214302"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170246929.png" alt="image-20240812170246929"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170409360.png" alt="image-20240812170409360"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812170443461.png" alt="image-20240812170443461"></p><p>因为可能交换机某个接口所连接的主机更换成了另一台主机，也可能主机中的网卡进行了更换。</p><h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171117949.png" alt="image-20240812171117949"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171227456.png" alt="image-20240812171227456"></p><h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171347338.png" alt="image-20240812171347338"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171416017.png" alt="image-20240812171416017"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171441551.png" alt="image-20240812171441551"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171512673.png" alt="image-20240812171512673"></p><p>同一个VLAN内部可以广播通信，不同的VLAN之间不能广播通信</p><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171705352.png" alt="image-20240812171705352"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171747169.png" alt="image-20240812171747169"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812171920482.png" alt="image-20240812171920482"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172005866.png" alt="image-20240812172005866"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172148900.png" alt="image-20240812172148900"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172245951.png" alt="image-20240812172245951"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172516159.png" alt="image-20240812172516159"></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172556741.png" alt="image-20240812172556741"></p><p><strong>总结</strong></p><p><img src="/2024/08/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240812172623937.png" alt="image-20240812172623937"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143116330.png" alt="image-20240811143116330"></p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143315583.png" alt="image-20240811143315583"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811143404201.png" alt="image-20240811143404201"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144124746.png" alt="image-20240811144124746"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144228004.png" alt="image-20240811144228004"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144259077.png" alt="image-20240811144259077"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144354650.png" alt="image-20240811144354650"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144538493.png" alt="image-20240811144538493"></p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811144814162.png" alt="image-20240811144814162"></p><p>远距离用串行传输，计算机内部用并行传输</p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811145140938.png" alt="image-20240811145140938"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811145208675.png" alt="image-20240811145208675"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152045479.png" alt="image-20240811152045479"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152254222.png" alt="image-20240811152254222"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152407222.png" alt="image-20240811152407222"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152425853.png" alt="image-20240811152425853"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152528815.png" alt="image-20240811152528815"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152625365.png" alt="image-20240811152625365"></p><p><strong>使用基本调制方法，1个码元只能包含1个比特信息</strong></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152828567.png" alt="image-20240811152828567"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811152839088.png" alt="image-20240811152839088"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153017598.png" alt="image-20240811153017598"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153056845.png" alt="image-20240811153056845"></p><p>所以不可以随便定义</p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811153202481.png" alt="image-20240811153202481"></p><p><em><strong>格雷码即为任意两个相邻码元只有1个比特不同</strong></em></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811160722538.png" alt="image-20240811160722538"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811160952098.png" alt="image-20240811160952098"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161004415.png" alt="image-20240811161004415"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161410382.png" alt="image-20240811161410382"></p><p><img src="/2024/08/10/%E7%89%A9%E7%90%86%E5%B1%82/image-20240811161419636.png" alt="image-20240811161419636"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网概述</title>
      <link href="/2024/08/09/%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/08/09/%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204622155.png" alt="image-20240809204622155"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204730835.png" alt="image-20240809204730835"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204807848.png" alt="image-20240809204807848"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204913000.png" alt="image-20240809204913000"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809204954611.png" alt="image-20240809204954611"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205034605.png" alt="image-20240809205034605"></p><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205755668.png" alt="image-20240809205755668"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809205909024.png" alt="image-20240809205909024"></p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210048654.png" alt="image-20240809210048654"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>与分组交换类似，报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就需要<strong>交换结点需要较大的缓存空间</strong></p><p><em>报文交换现在较少使用，通常被分组交换取代</em></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210437760.png" alt="image-20240809210437760"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809210700240.png" alt="image-20240809210700240"></p><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214427402.png" alt="image-20240809214427402"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214650566.png" alt="image-20240809214650566"></p><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809214750698.png" alt="image-20240809214750698"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215011750.png" alt="image-20240809215011750"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215126975.png" alt="image-20240809215126975"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215202123.png" alt="image-20240809215202123"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215433390.png" alt="image-20240809215433390"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215600876.png" alt="image-20240809215600876"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215703401.png" alt="image-20240809215703401"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215744290.png" alt="image-20240809215744290"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215852942.png" alt="image-20240809215852942"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240809215952112.png" alt="image-20240809215952112"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104105708.png" alt="image-20240810104105708"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104251458.png" alt="image-20240810104251458"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104336672.png" alt="image-20240810104336672"></p><h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104510188.png" alt="image-20240810104510188"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810104623757.png" alt="image-20240810104623757"></p><p> <img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105439764.png" alt="image-20240810105439764"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105619383.png" alt="image-20240810105619383"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105710059.png" alt="image-20240810105710059"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105742492.png" alt="image-20240810105742492"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810105813500.png" alt="image-20240810105813500"></p><h2 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h2><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810110913730.png" alt="image-20240810110913730"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810110927133.png" alt="image-20240810110927133"></p><h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111026913.png" alt="image-20240810111026913"></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111105360.png" alt="image-20240810111105360"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111223421.png" alt="image-20240810111223421"></p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111306763.png" alt="image-20240810111306763"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111337180.png" alt="image-20240810111337180"></p><p><img src="/2024/08/09/%E6%A6%82%E8%BF%B0/image-20240810111421848.png" alt="image-20240810111421848"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制单元</title>
      <link href="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/"/>
      <url>/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="微操作命令分析"><a href="#微操作命令分析" class="headerlink" title="微操作命令分析"></a>微操作命令分析</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728143935656.png" alt="image-20240728143935656"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144052638.png" alt="image-20240728144052638"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144435273.png" alt="image-20240728144435273"></p><p>算术右移时ACC<del>0</del>写回ACC<del>0</del>是为了保存符号位，</p><p>循环左移时ACC<del>0</del>移到ACC<del>n</del></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728144559981.png" alt="image-20240728144559981"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728145011998.png" alt="image-20240728145011998"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728145118107.png" alt="image-20240728145118107"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150008671.png" alt="image-20240728150008671"></p><h1 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150057558.png" alt="image-20240728150057558"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150134150.png" alt="image-20240728150134150"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150226031.png" alt="image-20240728150226031"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150601463.png" alt="image-20240728150601463"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150739209.png" alt="image-20240728150739209"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728150940886.png" alt="image-20240728150940886"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151223085.png" alt="image-20240728151223085"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151343865.png" alt="image-20240728151343865"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151444661.png" alt="image-20240728151444661"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151638534.png" alt="image-20240728151638534"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151814993.png" alt="image-20240728151814993"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728151849300.png" alt="image-20240728151849300"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153621420.png" alt="image-20240728153621420"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153701666.png" alt="image-20240728153701666"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153823779.png" alt="image-20240728153823779"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728153843830.png" alt="image-20240728153843830"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728154019519.png" alt="image-20240728154019519"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728154146349.png" alt="image-20240728154146349"></p><h1 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728155008228.png" alt="image-20240728155008228"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728155033471.png" alt="image-20240728155033471"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161022916.png" alt="image-20240728161022916"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161124560.png" alt="image-20240728161124560"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161358661.png" alt="image-20240728161358661"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728161502365.png" alt="image-20240728161502365"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163241675.png" alt="image-20240728163241675"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163353280.png" alt="image-20240728163353280"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728163850317.png" alt="image-20240728163850317"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728164547812.png" alt="image-20240728164547812"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165006200.png" alt="image-20240728165006200"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165133820.png" alt="image-20240728165133820"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165057671.png" alt="image-20240728165057671"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165116985.png" alt="image-20240728165116985"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165149854.png" alt="image-20240728165149854"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165208790.png" alt="image-20240728165208790"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240728165233289.png" alt="image-20240728165233289"></p><h1 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h1><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729111935421.png" alt="image-20240729111935421"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729112551877.png" alt="image-20240729112551877"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729113249236.png" alt="image-20240729113249236"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729113443616.png" alt="image-20240729113443616"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729121233938.png" alt="image-20240729121233938"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729121504957.png" alt="image-20240729121504957"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122231332.png" alt="image-20240729122231332"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122804135.png" alt="image-20240729122804135"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122846828.png" alt="image-20240729122846828"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729122952615.png" alt="image-20240729122952615"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132337267.png" alt="image-20240729132337267"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132457898.png" alt="image-20240729132457898"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132552681.png" alt="image-20240729132552681"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132825836.png" alt="image-20240729132825836"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729132856283.png" alt="image-20240729132856283"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134504305.png" alt="image-20240729134504305"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134706283.png" alt="image-20240729134706283"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134905248.png" alt="image-20240729134905248"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729134942430.png" alt="image-20240729134942430"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140541662.png" alt="image-20240729140541662"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140620497.png" alt="image-20240729140620497"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140703095.png" alt="image-20240729140703095"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140718988.png" alt="image-20240729140718988"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140742245.png" alt="image-20240729140742245"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140752954.png" alt="image-20240729140752954"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140835462.png" alt="image-20240729140835462"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729140929205.png" alt="image-20240729140929205"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141131618.png" alt="image-20240729141131618"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141253665.png" alt="image-20240729141253665"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141459809.png" alt="image-20240729141459809"></p><p><img src="/2024/07/29/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83/image-20240729141506449.png" alt="image-20240729141506449"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU的结构和功能</title>
      <link href="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155039834.png" alt="image-20240727155039834"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155004784.png" alt="image-20240727155004784"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727155234559.png" alt="image-20240727155234559"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727161424913.png" alt="image-20240727161424913"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727161515714.png" alt="image-20240727161515714"></p><h1 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192450699.png" alt="image-20240727192450699"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192654906.png" alt="image-20240727192654906"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192754511.png" alt="image-20240727192754511"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192841629.png" alt="image-20240727192841629">、<img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727192959755.png" alt="image-20240727192959755"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193252306.png" alt="image-20240727193252306"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193433446.png" alt="image-20240727193433446"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727193600286.png" alt="image-20240727193600286"></p><h1 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727204609300.png" alt="image-20240727204609300"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727204734640.png" alt="image-20240727204734640"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205128538.png" alt="image-20240727205128538"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205552285.png" alt="image-20240727205552285"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727205656676.png" alt="image-20240727205656676"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210031476.png" alt="image-20240727210031476"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210502228.png" alt="image-20240727210502228"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210607754.png" alt="image-20240727210607754"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210651994.png" alt="image-20240727210651994"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194226442.png" alt="image-20240727194226442"></p><p>m*Δt是第一条指令的时间，后面的由于处在流水线上，所以每过Δt的时间完成一条指令</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194302099.png" alt="image-20240727194302099"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194334798.png" alt="image-20240727194334798"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194406081.png" alt="image-20240727194406081"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194832505.png" alt="image-20240727194832505"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727194959746.png" alt="image-20240727194959746"></p><p>每个大段之间需要锁存，但是一个大段中分成若干小段时不需要锁存</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195220532.png" alt="image-20240727195220532"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195358737.png" alt="image-20240727195358737"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727195458528.png" alt="image-20240727195458528"></p><p>如果不一致，则会按照操作时间最长的那个功能段去计算时钟长度，会降低整个流水线的速度。</p><h1 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h1><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210808750.png" alt="image-20240727210808750"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727210843551.png" alt="image-20240727210843551"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211215465.png" alt="image-20240727211215465"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211603986.png" alt="image-20240727211603986"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211700830.png" alt="image-20240727211700830"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727211943545.png" alt="image-20240727211943545"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727212044141.png" alt="image-20240727212044141"></p><p>软件方法更灵活，易于修改。</p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727212207151.png" alt="image-20240727212207151"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727214854359.png" alt="image-20240727214854359"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215028038.png" alt="image-20240727215028038"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215058242.png" alt="image-20240727215058242"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215214614.png" alt="image-20240727215214614"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215444290.png" alt="image-20240727215444290"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215628886.png" alt="image-20240727215628886"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727215716924.png" alt="image-20240727215716924"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220007165.png" alt="image-20240727220007165"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220041529.png" alt="image-20240727220041529"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220149300.png" alt="image-20240727220149300"></p><p><img src="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/image-20240727220323831.png" alt="image-20240727220323831"></p><p>JMP前恢复中断屏蔽字</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指令系统</title>
      <link href="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727104919686.png" alt="image-20240727104919686"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727105438047.png" alt="image-20240727105438047"></p><p> <img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727105854476.png" alt="image-20240727105854476"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727110538897.png" alt="image-20240727110538897"></p><p>4次访存：取指令、取A1、取A2、取A3保存结果</p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727110745461.png" alt="image-20240727110745461"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727111008111.png" alt="image-20240727111008111"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727111305161.png" alt="image-20240727111305161"></p><h1 id="操作数类型和操作类型"><a href="#操作数类型和操作类型" class="headerlink" title="操作数类型和操作类型"></a>操作数类型和操作类型</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727112059684.png" alt="image-20240727112059684"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727112857536.png" alt="image-20240727112857536"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727113031672.png" alt="image-20240727113031672"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727113246050.png" alt="image-20240727113246050"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114454027.png" alt="image-20240727114454027"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114554952.png" alt="image-20240727114554952"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727114817918.png" alt="image-20240727114817918"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115143391.png" alt="image-20240727115143391"></p><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115505511.png" alt="image-20240727115505511"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727115619437.png" alt="image-20240727115619437"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121352980.png" alt="image-20240727121352980"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121517105.png" alt="image-20240727121517105"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121629398.png" alt="image-20240727121629398"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121903296.png" alt="image-20240727121903296"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727121944337.png" alt="image-20240727121944337"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122119494.png" alt="image-20240727122119494"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122204182.png" alt="image-20240727122204182"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122315754.png" alt="image-20240727122315754"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122352206.png" alt="image-20240727122352206"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727122506060.png" alt="image-20240727122506060"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133208801.png" alt="image-20240727133208801"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133344069.png" alt="image-20240727133344069"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133438537.png" alt="image-20240727133438537"></p><p>所以位移量为06H</p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133742279.png" alt="image-20240727133742279"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133914748.png" alt="image-20240727133914748"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727133935985.png" alt="image-20240727133935985"></p><h1 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134216251.png" alt="image-20240727134216251"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134424726.png" alt="image-20240727134424726"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134512040.png" alt="image-20240727134512040"></p><h1 id="RISC技术"><a href="#RISC技术" class="headerlink" title="RISC技术"></a>RISC技术</h1><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134617159.png" alt="image-20240727134617159"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134726862.png" alt="image-20240727134726862"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134841983.png" alt="image-20240727134841983"></p><p><img src="/2024/07/27/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/image-20240727134921942.png" alt="image-20240727134921942"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机的运算方法</title>
      <link href="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084120453.png" alt="image-20240726084120453"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084202561.png" alt="image-20240726084202561"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084417594.png" alt="image-20240726084417594"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726084706913.png" alt="image-20240726084706913"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100354359.png" alt="image-20240726100354359"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100616479.png" alt="image-20240726100616479"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726100740554.png" alt="image-20240726100740554"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726101104461.png" alt="image-20240726101104461"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726103716497-17219614367821.png" alt="image-20240726103716497"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104026869.png" alt="image-20240726104026869"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104340275.png" alt="image-20240726104340275"></p><p><strong>求补码的快捷方式：当真值为负时，补码可用原码除符号位保持不变外，其余每位取反，末位加1求得。</strong></p><p><em>联系：</em></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726104949978.png" alt="image-20240726104949978"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110622175.png" alt="image-20240726110622175"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110650415.png" alt="image-20240726110650415"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726110810847.png" alt="image-20240726110810847"></p><p>如何从y的补码获得-y的补码？</p><p>将y中连同符号位的每一位取反，最后+1，即为-y的补码。</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111250181.png" alt="image-20240726111250181"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111411874.png" alt="image-20240726111411874"></p><p>移码定义中只给出了整数形式的定义，没有小数形式的定义。</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111602966.png" alt="image-20240726111602966"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726111951746.png" alt="image-20240726111951746"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726112044955.png" alt="image-20240726112044955"></p><h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726112406221.png" alt="image-20240726112406221"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726113008038.png" alt="image-20240726113008038"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726113207558.png" alt="image-20240726113207558"></p><p>S是小于1的小数</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115202560.png" alt="image-20240726115202560"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115611019.png" alt="image-20240726115611019"></p><p><em>用有限的数据表示无限多的实数</em></p><p>阶码上溢时按出错处理</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726115813887.png" alt="image-20240726115813887"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121313483.png" alt="image-20240726121313483"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121633506.png" alt="image-20240726121633506"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726121907893.png" alt="image-20240726121907893"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726130313902.png" alt="image-20240726130313902"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726130622716.png" alt="image-20240726130622716"></p><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726131848646.png" alt="image-20240726131848646"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726132042314.png" alt="image-20240726132042314"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726144626746-17219763874883.png" alt="image-20240726144626746"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726144842232.png" alt="image-20240726144842232"></p><h2 id="加减法运算"><a href="#加减法运算" class="headerlink" title="加减法运算"></a>加减法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726145221455.png" alt="image-20240726145221455"></p><p><strong>溢出</strong></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726145801608-17219770818405.png" alt="image-20240726145801608"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726155645240.png" alt="image-20240726155645240"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726155825787.png" alt="image-20240726155825787"></p><h2 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160029431.png" alt="image-20240726160029431"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160151861.png" alt="image-20240726160151861"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160420485.png" alt="image-20240726160420485"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726160642497.png" alt="image-20240726160642497"></p><p>3个寄存器：1个存被乘数，该寄存器不需要移位功能；另外两个一个先存乘数，后存结果的低位，另一个存结果的高位，这两个寄存器需要具有移位功能。</p><p>需要n+1位的全加器，而不是2*n+1位，因为只与高位相加</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161044929.png" alt="image-20240726161044929"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161216633.png" alt="image-20240726161216633"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161352775.png" alt="image-20240726161352775"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161450815.png" alt="image-20240726161450815"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726161931927.png" alt="image-20240726161931927"></p><p>当前最后一位是1时，控制门打开，进行累加和右移；如果是0，送入0相加或者直接右移。</p><p>其中G<del>M</del>是乘法标志，S是符号位。</p><h2 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h2><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163415540.png" alt="image-20240726163415540"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163549474.png" alt="image-20240726163549474"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726163721714.png" alt="image-20240726163721714"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165052679.png" alt="image-20240726165052679"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165346644.png" alt="image-20240726165346644"></p><p><strong>如果第一次上商为1，则表示溢出</strong></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726165953615.png" alt="image-20240726165953615"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170115295.png" alt="image-20240726170115295"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170343860.png" alt="image-20240726170343860"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726170718668.png" alt="image-20240726170718668"></p><p>其中G<del>D</del>是除法标志，S是符号位，V表示是否发生溢出</p><h1 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726171132967.png" alt="image-20240726171132967"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726171329355.png" alt="image-20240726171329355"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726172246707.png" alt="image-20240726172246707"></p><p>主要根据<strong>第二条</strong>，看<strong>补码</strong>来判断</p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726172411867.png" alt="image-20240726172411867"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726182921475.png" alt="image-20240726182921475"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726183121695.png" alt="image-20240726183121695"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726184655074.png" alt="image-20240726184655074"></p><p>如果发生下溢，则可以当作0处理；如果发生上溢，说明出错</p><h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726184938015.png" alt="image-20240726184938015"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726185752403.png" alt="image-20240726185752403"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726185926765.png" alt="image-20240726185926765"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190058550.png" alt="image-20240726190058550"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190232027.png" alt="image-20240726190232027"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190340273-17219918213137.png" alt="image-20240726190340273"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190648289.png" alt="image-20240726190648289"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190721252.png" alt="image-20240726190721252"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726190813806.png" alt="image-20240726190813806"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726191320963.png" alt="image-20240726191320963"></p><p><img src="/2024/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/image-20240726191223657.png" alt="image-20240726191223657"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出系统</title>
      <link href="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725151150308.png" alt="image-20240725151150308"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725151541579.png" alt="image-20240725151541579"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725152923581.png" alt="image-20240725152923581"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153101841.png" alt="image-20240725153101841"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153228627.png" alt="image-20240725153228627"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153520694.png" alt="image-20240725153520694"></p><p>CPU在原地等待I&#x2F;O，利用率低</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153829377.png" alt="image-20240725153829377"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725153959012.png" alt="image-20240725153959012"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154533403.png" alt="image-20240725154533403"></p><p>在周期挪用期间，CPU不能访问主存，不能使用总线，但是可以进行缓存中的程序</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154816784.png" alt="image-20240725154816784"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725154922419.png" alt="image-20240725154922419"></p><h1 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h1><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155152727.png" alt="image-20240725155152727"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155346845.png" alt="image-20240725155346845"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155452879.png" alt="image-20240725155452879"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725155729064.png" alt="image-20240725155729064"></p><p>A指模拟信号，D指数字信号（计算机识别数字信号）</p><h1 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160014257.png" alt="image-20240725160014257"></p><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160134010.png" alt="image-20240725160134010"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160415218.png" alt="image-20240725160415218"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160610352.png" alt="image-20240725160610352"></p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725160804803.png" alt="image-20240725160804803"></p><p>程序查询方式不需要接口进行控制</p><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725162650407.png" alt="image-20240725162650407"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725162900109.png" alt="image-20240725162900109"></p><h2 id="接口电路"><a href="#接口电路" class="headerlink" title="接口电路"></a>接口电路</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725163105166.png" alt="image-20240725163105166"></p><p>先是D为0，B为1，来启动设备，开始数据准备；准备好后，设备工作结束，将D改为1，B改为0，来接收数据。在此过程中 CPU原地踏步等待，不断循环查看。</p><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170626134.png" alt="image-20240725170626134"></p><h2 id="I-O中断的产生"><a href="#I-O中断的产生" class="headerlink" title="I&#x2F;O中断的产生"></a>I&#x2F;O中断的产生</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170722412.png" alt="image-20240725170722412"></p><h2 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725170920256.png" alt="image-20240725170920256"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725171133983.png" alt="image-20240725171133983"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725171421661.png" alt="image-20240725171421661"></p><p>紫色为低电平，黄色为高电平</p><p>上图中INTR2有请求，通过与非门和非门屏蔽了优先级比他低的请求，最终只有INTP2是高电平，由此筛选出了中断请求优先级最高的中断源。</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725172147493.png" alt="image-20240725172147493"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725172327266.png" alt="image-20240725172327266"></p><h2 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I&#x2F;O中断处理过程"></a>I&#x2F;O中断处理过程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725180833908.png" alt="image-20240725180833908"></p><h2 id="中断服务程序流程"><a href="#中断服务程序流程" class="headerlink" title="中断服务程序流程"></a>中断服务程序流程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725181423207.png" alt="image-20240725181423207"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193302659.png" alt="image-20240725193302659"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193448717.png" alt="image-20240725193448717"></p><h1 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h1><h2 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725193819214.png" alt="image-20240725193819214"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194441311.png" alt="image-20240725194441311"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194648757.png" alt="image-20240725194648757"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194736394.png" alt="image-20240725194736394"></p><h2 id="DMA接口的功能和组成"><a href="#DMA接口的功能和组成" class="headerlink" title="DMA接口的功能和组成"></a>DMA接口的功能和组成</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725194852625.png" alt="image-20240725194852625"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195220292.png" alt="image-20240725195220292"></p><h2 id="DMA的工作过程"><a href="#DMA的工作过程" class="headerlink" title="DMA的工作过程"></a>DMA的工作过程</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195303647.png" alt="image-20240725195303647"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195513527.png" alt="image-20240725195513527"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195652131.png" alt="image-20240725195652131"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195801637.png" alt="image-20240725195801637"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195846382.png" alt="image-20240725195846382"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725195959192.png" alt="image-20240725195959192"></p><p>越靠近CPU，DMA接口的优先级越高</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200046533.png" alt="image-20240725200046533"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200211175.png" alt="image-20240725200211175"></p><p><em>由于DMA方式是内存和外设之间直接进行数据交换，通常连接高速设备，所以DMA方式在I&#x2F;O和内存进行数据传输的模式下优先级更高。</em></p><h2 id="DMA接口的类型"><a href="#DMA接口的类型" class="headerlink" title="DMA接口的类型"></a>DMA接口的类型</h2><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200525683.png" alt="image-20240725200525683"></p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200626870.png" alt="image-20240725200626870"></p><p>多路型允许多个设备同时准备，同时进行缓冲，但是每次只能处理一个请求。</p><p><img src="/2024/07/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/image-20240725200835974.png" alt="image-20240725200835974"></p><p><em>（本题中假设每个DMA请求处理时间为5微秒，磁盘的DMA请求时间间隔为30微秒，磁带为45微秒，打印机为150微秒）</em></p><p><strong>速度越快的优先级越高，所以磁盘和磁带同时出现时，选择处理磁盘。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器</title>
      <link href="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130008946.png" alt="image-20240724130008946"></p><p>其中（1）是易失的，另外三个是非易失的</p><p>主要相当于是三种：第一种是半导体存储器，利用0和1代表低电平和高电平；第二种是磁表面存储器，利用磁头读出与写入；第三种是光盘存储器，利用光烧制。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130627988.png" alt="image-20240724130627988"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724130804075.png" alt="image-20240724130804075"></p><p>RAM即随机存储器，ROM即只读存储器</p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724131046942.png" alt="image-20240724131046942"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724131724189.png" alt="image-20240724131724189"></p><p>缓存和主存用硬件连接成一个整体，主要解决速度问题；</p><p>主存和辅存用软硬件结合的方式连接成一个整体，主要解决容量问题。</p><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="主存的基本组成"><a href="#主存的基本组成" class="headerlink" title="主存的基本组成"></a>主存的基本组成</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724134958736.png" alt="image-20240724134958736"></p><h3 id="主存与CPU之间的联系"><a href="#主存与CPU之间的联系" class="headerlink" title="主存与CPU之间的联系"></a>主存与CPU之间的联系</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135035979.png" alt="image-20240724135035979"></p><h3 id="主存中存储单元地址的分配"><a href="#主存中存储单元地址的分配" class="headerlink" title="主存中存储单元地址的分配"></a>主存中存储单元地址的分配</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135610942.png" alt="image-20240724135610942"></p><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135750674.png" alt="image-20240724135750674"></p><h2 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724135946685.png" alt="image-20240724135946685"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140423555.png" alt="image-20240724140423555"></p><p><strong>片选线</strong>：芯片选择信号，指出操作给出的地址是不是针对存储芯片的地址，被选择的字节是否在芯片中</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140705474.png" alt="image-20240724140705474"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724140927773.png" alt="image-20240724140927773"></p><p>片选线让某一个芯片或某一组芯片开始工作。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724141425701.png" alt="image-20240724141425701"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724141621082.png" alt="image-20240724141621082"></p><h2 id="随机存取存储器（RAM）"><a href="#随机存取存储器（RAM）" class="headerlink" title="随机存取存储器（RAM）"></a>随机存取存储器（RAM）</h2><h3 id="静态RAM（SRAM）"><a href="#静态RAM（SRAM）" class="headerlink" title="静态RAM（SRAM）"></a>静态RAM（SRAM）</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142057829.png" alt="image-20240724142057829"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142209154.png" alt="image-20240724142209154"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142310937.png" alt="image-20240724142310937"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142559957.png" alt="image-20240724142559957"></p><p>WE是读写控制信号（低电平为写，高电平为读）</p><p>CS是片选信号，只有是低电平时芯片才会被选中</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142916821.png" alt="image-20240724142916821"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724142936211.png" alt="image-20240724142936211"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724143159555.png" alt="image-20240724143159555"></p><h3 id="动态RAM（DRAM）"><a href="#动态RAM（DRAM）" class="headerlink" title="动态RAM（DRAM）"></a>动态RAM（DRAM）</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152738563.png" alt="image-20240724152738563"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152852273.png" alt="image-20240724152852273"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724152923180.png" alt="image-20240724152923180"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153210832.png" alt="image-20240724153210832"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153415213.png" alt="image-20240724153415213"></p><p>若读放大器一侧为0，则经过后另一侧变为1（即变成相反），所以读出与原存信息相反</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724153704527.png" alt="image-20240724153704527"></p><p>读出的时候做一次反向，写入的时候再做一次反向，所以写入与输入信息相同</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154143543.png" alt="image-20240724154143543"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154240944.png" alt="image-20240724154240944"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154327146.png" alt="image-20240724154327146"></p><h3 id="动态RAM和静态RAM的比较"><a href="#动态RAM和静态RAM的比较" class="headerlink" title="动态RAM和静态RAM的比较"></a>动态RAM和静态RAM的比较</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154509275.png" alt="image-20240724154509275"></p><h2 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154842683.png" alt="image-20240724154842683"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724154957288.png" alt="image-20240724154957288"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724155100219.png" alt="image-20240724155100219"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724155202935.png" alt="image-20240724155202935"></p><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><h3 id="存储器容量的扩展"><a href="#存储器容量的扩展" class="headerlink" title="存储器容量的扩展"></a>存储器容量的扩展</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724160535401.png" alt="image-20240724160535401"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724161026746.png" alt="image-20240724161026746"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724161158499.png" alt="image-20240724161158499"></p><h3 id="存储器与CPU的连接-1"><a href="#存储器与CPU的连接-1" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724162452972.png" alt="image-20240724162452972"></p><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724164242922.png" alt="image-20240724164242922"></p><p><em>由于百分之90出现的错误是1位错，所以默认为1位错</em>，即3中110默认为111出现1位错，而不是000出现2位错</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724164449657.png" alt="image-20240724164449657"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165623211.png" alt="image-20240724165623211"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165633635.png" alt="image-20240724165633635"></p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724165927090.png" alt="image-20240724165927090" style="zoom: 80%;"><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170058283.png" alt="image-20240724170058283"></p><p>默认为偶校验</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170228664.png" alt="image-20240724170228664"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170346358.png" alt="image-20240724170346358"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170416112.png" alt="image-20240724170416112"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170613128.png" alt="image-20240724170613128"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170659444.png" alt="image-20240724170659444"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724170731656.png" alt="image-20240724170731656"></p><h2 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171235754.png" alt="image-20240724171235754"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171400441.png" alt="image-20240724171400441"></p><p>由于顺序存储，会出现某个存储体非常忙，其余的存储体非常闲的问题。</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171534349.png" alt="image-20240724171534349"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171729335.png" alt="image-20240724171729335"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171746395.png" alt="image-20240724171746395"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171842408.png" alt="image-20240724171842408"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724171939659.png" alt="image-20240724171939659"></p><p>高位交叉主要应用于存储器容量的扩展，低位交叉用于存储器带宽和访问速度的提高</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724172234056.png" alt="image-20240724172234056"></p><h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185159497.png" alt="image-20240724185159497"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185329009.png" alt="image-20240724185329009"></p><p>主存和缓存<strong>按块存储</strong>，块的大小相同，B为块长</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724185549270.png" alt="image-20240724185549270"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724190133649.png" alt="image-20240724190133649"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724193621766.png" alt="image-20240724193621766"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194134440.png" alt="image-20240724194134440"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194223818.png" alt="image-20240724194223818"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194521303.png" alt="image-20240724194521303"></p><p>写直达法的缺点：容易出现对同一个块频繁操作，而其他块不改变（例如累加操作）</p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724194748797.png" alt="image-20240724194748797"></p><p>分立缓存是将指令Cache和数据Cache区分开</p><h2 id="Cache—主存的地址映射"><a href="#Cache—主存的地址映射" class="headerlink" title="Cache—主存的地址映射"></a>Cache—主存的地址映射</h2><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195222352.png" alt="image-20240724195222352"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195455972.png" alt="image-20240724195455972"></p><p>优点：结构简单，速度快</p><p>缺点：利用率可能很低；调入时冲突概率大；不灵活</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195628998.png" alt="image-20240724195628998"></p><p>优点：利用率高</p><p>缺点：成本高；速度较低</p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724195806223.png" alt="image-20240724195806223"></p><p>即 i &#x3D; j mod Q，是直接映射和全相联映射的结合</p><p><strong>越靠近CPU的Cache对于速度要求越高，所以使用直接映射或者路数较少的组相联映射；中间的Cache使用组相联映射；距离CPU最远的对于利用率的要求较高，使用全相联映射。</strong></p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200452563.png" alt="image-20240724200452563"></p><h1 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h1><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200805304.png" alt="image-20240724200805304"></p><h3 id="磁记录原理"><a href="#磁记录原理" class="headerlink" title="磁记录原理"></a>磁记录原理</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200836851.png" alt="image-20240724200836851"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724200902692.png" alt="image-20240724200902692"></p><h3 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201003297.png" alt="image-20240724201003297"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201057621.png" alt="image-20240724201057621"></p><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201136280.png" alt="image-20240724201136280"></p><h3 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201247862.png" alt="image-20240724201247862"></p><p><em>软盘已经被淘汰</em></p><h3 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h3><p><img src="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/image-20240724201448868.png" alt="image-20240724201448868"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/2024/07/23/%E6%80%BB%E7%BA%BF/"/>
      <url>/2024/07/23/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723154906559.png" alt="image-20240723154906559"></p><p>并行传输容易出错，所以一般距离较短</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155030862.png" alt="image-20240723155030862"></p><p>缺点：当主存和I&#x2F;O进行信息传输时，CPU不能运行</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155109089.png" alt="image-20240723155109089"></p><p>缺点：主存和I&#x2F;O不能直接进行信息传输，需要打断CPU的执行程序的任务</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723155345605.png" alt="image-20240723155345605"></p><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163707908.png" alt="image-20240723163707908"></p><p><em>有出（CPU向外送的）：存储器读、存储器写，总线允许，中断确认</em></p><p><em>有入（由I&#x2F;O端口送给CPU）：中断请求、总线请求</em></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163755736.png" alt="image-20240723163755736"></p><h1 id="总线性能及性能指标"><a href="#总线性能及性能指标" class="headerlink" title="总线性能及性能指标"></a>总线性能及性能指标</h1><h2 id="总线物理实现"><a href="#总线物理实现" class="headerlink" title="总线物理实现"></a>总线物理实现</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723163914464.png" alt="image-20240723163914464"></p><h2 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164014962.png" alt="image-20240723164014962"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164307600.png" alt="image-20240723164307600"></p><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164525560.png" alt="image-20240723164525560"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164549247.png" alt="image-20240723164549247"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164642430.png" alt="image-20240723164642430"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164725208.png" alt="image-20240723164725208"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723164953962.png" alt="image-20240723164953962"></p><p>把高速设备和低速设备区分开，高速设备用高速总线进行组织，低速设备用扩展总线进行组织，使数据传输速率更高。</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165229027-172172475133729.png" alt="image-20240723165229027"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165244264.png" alt="image-20240723165244264"></p><p>同样区分了高速设备和低速设备（VL-BUS连接高速，ISA、EISA连接低速）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165326175.png" alt="image-20240723165326175"></p><p>（PCI总线连接高速，ISA、EISA连接低速）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723165446833.png" alt="image-20240723165446833"></p><p>通过桥电路实现了总线的驱动能力的提高和总线的扩展</p><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723170550512.png" alt="image-20240723170550512"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723170641001.png" alt="image-20240723170641001"></p><p>BG的连接顺序就是I&#x2F;O接口的优先级顺序</p><p>优点：结构简单，增删设备容易，容易实现可靠性设计（比如增加一条BR线，防止出现问题）</p><p>缺点：某一处出现故障，信号无法继续向后传，后面的接口无法获得总线的使用权，所以对电路故障非常敏感</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723171754067.png" alt="image-20240723171754067"></p><p>优点：优先级灵活（可以通过计数器来控制优先级）</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723172120313.png" alt="image-20240723172120313"></p><p>优点：优先级灵活（可以通过排队器的设置来控制优先级）</p><p>缺点：需要的线数比较多</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195012084.png" alt="image-20240723195012084"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195051085.png" alt="image-20240723195051085"></p><p>​                                                                 潜力</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195311877.png" alt="image-20240723195311877"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723195448675.png" alt="image-20240723195448675"></p><p>同步式适用于总线长度较短，而且各个模块存取时间比较一致的情况</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723210631881.png" alt="image-20240723210631881"></p><p>不互锁：主设备发出请求后一段时间后即使没有收到应答信号也会撤销信号，从设备发出应答信号后一段时间后即使没有收到撤销信号也会撤销应答信号</p><p>半互锁：主设备发出信号后一直等到收到应答信号才会撤回信号，从设备发出应答信号后一段时间后即使没有收到撤销信号也会撤销应答信号</p><p>全互锁：主设备发出请求后直到收到应答信号才会撤销信号，从设备发出应答信号后直到收到撤销信号才会撤销应答信号</p><p><strong>异步通信可以完成可靠的数据传输</strong></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723210809190.png" alt="image-20240723210809190"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211040400.png" alt="image-20240723211040400"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211207579.png" alt="image-20240723211207579"></p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211249924.png" alt="image-20240723211249924"></p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211501971.png" alt="image-20240723211501971"><p>所有的模块都可以从从模块可以变成主模块</p><p><img src="/2024/07/23/%E6%80%BB%E7%BA%BF/image-20240723211750657.png" alt="image-20240723211750657"></p><p>总线被占用时一定在进行数据通信或者在传输控制命令，<strong>充分利用了总线的带宽</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论</title>
      <link href="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统简介"><a href="#计算机系统简介" class="headerlink" title="计算机系统简介"></a>计算机系统简介</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220609924.png" alt="image-20240719220609924"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220810332.png" alt="image-20240719220810332"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719220853358.png" alt="image-20240719220853358"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221014409.png" alt="image-20240719221014409"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221250112.png" alt="image-20240719221250112"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719221519835.png" alt="image-20240719221519835"></p><p>中间的虚线完成了计算机系统当中软硬件功能的划分，也提供了软硬件的接口</p><p><em><strong>计算机组成与计算机体系结构从研究内容上来说有什么区别呢？</strong></em></p><p>计算机系统结构定义了计算机系统的软硬件的交界面，定义了哪些功能由软件实现，哪些功能由硬件实现，提供了上层软件进行编写的时候与硬件进行交互的接口。</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240719222122165.png" alt="image-20240719222122165"></p><h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120255259.png" alt="image-20240723120255259"></p><p><strong>五大部件：运算器，控制器，寄存器，输入设备，输出设备</strong></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120736894.png" alt="image-20240723120736894"></p><p>（黑色的实线表示数据通路，虚线表示控制和状态反馈）</p><p>运算器：算术运算，逻辑运算</p><p>存储器：存放数据和程序</p><p>控制器：指挥程序运行</p><p>输入设备：将信息转换成机器能识别的形式</p><p>输出设备：将结果转换成人们熟悉的形式</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120912424.png" alt="image-20240723120912424"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723120957365.png" alt="image-20240723120957365"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121200198.png" alt="image-20240723121200198"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121735627.png" alt="image-20240723121735627"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121747826.png" alt="image-20240723121747826"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723121818404.png" alt="image-20240723121818404"></p><p>由上图可见，指令和数据都是保存在存储器中</p><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723122158051.png" alt="image-20240723122158051"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723122338179.png" alt="image-20240723122338179"></p><p>对于存储器的读出和写入需要用到MAR和MDR</p><p>上图中MAR为4位，则这4位可以从0000到1111，一共保存了16个地址，也就是存储体中一共有16个存储单元；MDR存储了数据，由于数据和地址的长度相同，所以也反映了存储的字长。</p><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723134957723.png" alt="image-20240723134957723"></p><p>在乘法运算时位数变成原先的两倍，所以需要MQ来存储</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135056105.png" alt="image-20240723135056105"></p><p>M给出了加数的<strong>地址</strong></p><p>需要把内存单元M中的内容取出来放入X寄存器中（即[M]—&gt;X）</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135309833.png" alt="image-20240723135309833"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135502874.png" alt="image-20240723135502874"></p><p><strong>控制器</strong>决定进行哪个操作的先后顺序，并且控制传送到哪个寄存器</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723135752674.png" alt="image-20240723135752674"></p><p><em>MQ寄存器只在乘除法使用，所以又叫乘商寄存器</em></p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p><strong>功能</strong>：解释指令</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140219058.png" alt="image-20240723140219058"></p><h2 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h2><p>以取数指令为例</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140617030.png" alt="image-20240723140617030"></p><p>以存数指令为例</p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723140747841.png" alt="image-20240723140747841"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723141141959.png" alt="image-20240723141141959"></p><p>OP(IR)表示IR中存的指令的操作码；Ad(IR)表示IR中存的指令的地址码</p><h1 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h1><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723152035059.png" alt="image-20240723152035059"></p><p><img src="/2024/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/image-20240723152950211.png" alt="image-20240723152950211"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 面试必备知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点</title>
      <link href="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h1><h2 id="概念与功能"><a href="#概念与功能" class="headerlink" title="概念与功能"></a>概念与功能</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423194707226.png" alt="image-20240423194707226"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423194841887.png" alt="image-20240423194841887"></p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195117102.png" alt="image-20240423195117102"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195216394.png" alt="image-20240423195216394"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423195332150.png" alt="image-20240423195332150"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423201906314.png" alt="image-20240423201906314"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202038794.png" alt="image-20240423202038794"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202117687.png" alt="image-20240423202117687"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202324881.png" alt="image-20240423202324881"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202332741.png" alt="image-20240423202332741"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202549561.png" alt="image-20240423202549561"> </p><p>没有并发和共享，就没有虚拟和异步，所以并发和共享是两个最基本的特征。</p><h2 id="发展与分类"><a href="#发展与分类" class="headerlink" title="发展与分类"></a>发展与分类</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423202902770.png" alt="image-20240423202902770"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203035194.png" alt="image-20240423203035194"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203120921.png" alt="image-20240423203120921"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203212927.png" alt="image-20240423203212927"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203302552.png" alt="image-20240423203302552"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240423203337113.png" alt="image-20240423203337113"></p><h1 id="操作系统的运行"><a href="#操作系统的运行" class="headerlink" title="操作系统的运行"></a>操作系统的运行</h1><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161413293.png" alt="image-20240424161413293"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161608749.png" alt="image-20240424161608749"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161646947.png" alt="image-20240424161646947"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161730273.png" alt="image-20240424161730273"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424161925701.png" alt="image-20240424161925701"></p><p>内中断的例子：</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162131100.png" alt="image-20240424162131100"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162100314.png" alt="image-20240424162100314"></p><p>外中断的例子：</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162342891.png" alt="image-20240424162342891"></p><p>（每一条指令执行结束时，CPU都会例行检查是否有外中断信号）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162648223.png" alt="image-20240424162648223"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162732505.png" alt="image-20240424162732505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424162750550.png" alt="image-20240424162750550"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163016612.png" alt="image-20240424163016612"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163133166.png" alt="image-20240424163133166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163227764.png" alt="image-20240424163227764"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163248719.png" alt="image-20240424163248719"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163517853.png" alt="image-20240424163517853"></p><p> <img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424163556825.png" alt="image-20240424163556825"></p><h1 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a>操作系统体系结构</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172527821.png" alt="image-20240424172527821"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172556390.png" alt="image-20240424172556390"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172624554.png" alt="image-20240424172624554"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172747625.png" alt="image-20240424172747625"></p><p>（“变态”即CPU状态的转换）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424172849193.png" alt="image-20240424172849193"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424173308508.png" alt="image-20240424173308508"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424174249792.png" alt="image-20240424174249792"></p><h1 id="操作系统的引导"><a href="#操作系统的引导" class="headerlink" title="操作系统的引导"></a>操作系统的引导</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424175832327.png" alt="image-20240424175832327"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424175920257.png" alt="image-20240424175920257"></p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424180221509.png" alt="image-20240424180221509"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240424180529570.png" alt="image-20240424180529570"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425194050907.png" alt="image-20240425194050907"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425194501549.png" alt="image-20240425194501549"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425195833490.png" alt="image-20240425195833490"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425195950949.png" alt="image-20240425195950949"></p><p>更确切的说，应该是“进程实体（进程映像）的组成”</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202052767.png" alt="image-20240425202052767"></p><p>进程实体反应了进程在某一时刻的状态</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202251316.png" alt="image-20240425202251316"></p><p>（一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202536005.png" alt="image-20240425202536005"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425202624628.png" alt="image-20240425202624628"></p><h2 id="状态与转换"><a href="#状态与转换" class="headerlink" title="状态与转换"></a>状态与转换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203158683.png" alt="image-20240425203158683"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203232076.png" alt="image-20240425203232076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203258368.png" alt="image-20240425203258368"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203341916.png" alt="image-20240425203341916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203616442.png" alt="image-20240425203616442"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203659892.png" alt="image-20240425203659892"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203729200.png" alt="image-20240425203729200"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203752369.png" alt="image-20240425203752369"></p><p>大多数使用链式方式</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203824211.png" alt="image-20240425203824211"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425203843154.png" alt="image-20240425203843154"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204014861.png" alt="image-20240425204014861"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204142396.png" alt="image-20240425204142396"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204307182.png" alt="image-20240425204307182"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204414430.png" alt="image-20240425204414430"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204556522.png" alt="image-20240425204556522"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204644915.png" alt="image-20240425204644915"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205119950.png" alt="image-20240425205119950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425204958551.png" alt="image-20240425204958551"></p><p>这样，当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205209183.png" alt="image-20240425205209183"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205526858.png" alt="image-20240425205526858"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205616344.png" alt="image-20240425205616344"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205743656.png" alt="image-20240425205743656"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205842141.png" alt="image-20240425205842141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425205929221.png" alt="image-20240425205929221"></p><p> <img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210208090.png" alt="image-20240425210208090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210314279.png" alt="image-20240425210314279"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425210729504.png" alt="image-20240425210729504"></p><p>先进先出（FIFO）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425211023890.png" alt="image-20240425211023890"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425211103113.png" alt="image-20240425211103113"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425212924612.png" alt="image-20240425212924612"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213012953.png" alt="image-20240425213012953"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213022270.png" alt="image-20240425213022270"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213504551.png" alt="image-20240425213504551"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213554685.png" alt="image-20240425213554685"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213745128.png" alt="image-20240425213745128"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213829589.png" alt="image-20240425213829589"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425213923083.png" alt="image-20240425213923083"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214004512.png" alt="image-20240425214004512"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214042850.png" alt="image-20240425214042850"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214107952.png" alt="image-20240425214107952"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214252434.png" alt="image-20240425214252434"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214347873.png" alt="image-20240425214347873"></p><h2 id="状态与转换-1"><a href="#状态与转换-1" class="headerlink" title="状态与转换"></a>状态与转换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214516442.png" alt="image-20240425214516442"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240425214903060.png" alt="image-20240425214903060"></p><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="概念，层次"><a href="#概念，层次" class="headerlink" title="概念，层次"></a>概念，层次</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171438969.png" alt="image-20240426171438969"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171526532.png" alt="image-20240426171526532"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171612978.png" alt="image-20240426171612978"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426171752119.png" alt="image-20240426171752119"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172310673.png" alt="image-20240426172310673"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172436227.png" alt="image-20240426172436227"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172751011.png" alt="image-20240426172751011"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426172848352.png" alt="image-20240426172848352"></p><h2 id="进程调度的时机，切换与方式"><a href="#进程调度的时机，切换与方式" class="headerlink" title="进程调度的时机，切换与方式"></a>进程调度的时机，切换与方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426183054466.png" alt="image-20240426183054466"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426212516479.png" alt="image-20240426212516479"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426212715032.png" alt="image-20240426212715032"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215459885.png" alt="image-20240426215459885"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215508243.png" alt="image-20240426215508243"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215649600.png" alt="image-20240426215649600"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215759025.png" alt="image-20240426215759025"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426215814790.png" alt="image-20240426215814790"></p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220036114.png" alt="image-20240426220036114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220048941.png" alt="image-20240426220048941"></p><h2 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a>闲逛进程</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220117897.png" alt="image-20240426220117897"></p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220251731.png" alt="image-20240426220251731"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220315202.png" alt="image-20240426220315202"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220403033.png" alt="image-20240426220403033"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220508876.png" alt="image-20240426220508876"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220623795.png" alt="image-20240426220623795"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220637861.png" alt="image-20240426220637861"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220647090.png" alt="image-20240426220647090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426220746537.png" alt="image-20240426220746537"></p><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221105498.png" alt="image-20240426221105498"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221005368.png" alt="image-20240426221005368"></p><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221633075.png" alt="image-20240426221633075"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221227911.png" alt="image-20240426221227911"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221355660.png" alt="image-20240426221355660"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221426472.png" alt="image-20240426221426472"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221552888.png" alt="image-20240426221552888"></p><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221942370.png" alt="image-20240426221942370"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426221907145.png" alt="image-20240426221907145"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222017800.png" alt="image-20240426222017800"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222310955.png" alt="image-20240426222310955"></p><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223150381.png" alt="image-20240426223150381"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222701916.png" alt="image-20240426222701916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222740205.png" alt="image-20240426222740205"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222754522.png" alt="image-20240426222754522"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222840849.png" alt="image-20240426222840849"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426222922006.png" alt="image-20240426222922006"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223043674.png" alt="image-20240426223043674"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223049058.png" alt="image-20240426223049058"></p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223642340.png" alt="image-20240426223642340"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223343429.png" alt="image-20240426223343429"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223435568.png" alt="image-20240426223435568"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223623059.png" alt="image-20240426223623059"></p><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224052076.png" alt="image-20240426224052076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426223933261.png" alt="image-20240426223933261"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224157458.png" alt="image-20240426224157458"></p><h3 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240426224548604.png" alt="image-20240426224548604"></p><h1 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153146275.png" alt="image-20240427153146275"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153238267.png" alt="image-20240427153238267"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153329535.png" alt="image-20240427153329535"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153528037.png" alt="image-20240427153528037"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153536900.png" alt="image-20240427153536900"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153654004.png" alt="image-20240427153654004"></p><h2 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153905013.png" alt="image-20240427153905013"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427153954228.png" alt="image-20240427153954228"></p><h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154050812.png" alt="image-20240427154050812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154158402.png" alt="image-20240427154158402"></p><h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154433993.png" alt="image-20240427154433993"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154506099.png" alt="image-20240427154506099"></p><h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154806950.png" alt="image-20240427154806950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154919393.png" alt="image-20240427154919393"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427154909218.png" alt="image-20240427154909218"></p><h2 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155132426.png" alt="image-20240427155132426"></p><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155351280.png" alt="image-20240427155351280"></p><h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155549439.png" alt="image-20240427155549439"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155657037.png" alt="image-20240427155657037"></p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427155714643.png" alt="image-20240427155714643"></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427161617855.png" alt="image-20240427161617855"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427161909400.png" alt="image-20240427161909400"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427162015247.png" alt="image-20240427162015247"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427162138098.png" alt="image-20240427162138098"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164404808.png" alt="image-20240427164404808"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427163801843.png" alt="image-20240427163801843"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427163931364.png" alt="image-20240427163931364"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164150523.png" alt="image-20240427164150523"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164224249.png" alt="image-20240427164224249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427164238901.png" alt="image-20240427164238901"></p><h2 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427165838505.png" alt="image-20240427165838505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427165920640.png" alt="image-20240427165920640"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170038714.png" alt="image-20240427170038714"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170257233.png" alt="image-20240427170257233"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427170413130.png" alt="image-20240427170413130"></p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230155371.png" alt="image-20240427230155371"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230456604.png" alt="image-20240427230456604"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427230748836.png" alt="image-20240427230748836"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231003737.png" alt="image-20240427231003737"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231031143.png" alt="image-20240427231031143"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240427231115335.png" alt="image-20240427231115335"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428103345511.png" alt="image-20240428103345511"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428103541095.png" alt="image-20240428103541095"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104031040.png" alt="image-20240428104031040"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104232904.png" alt="image-20240428104232904"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104329673.png" alt="image-20240428104329673"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104355076.png" alt="image-20240428104355076"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104409628.png" alt="image-20240428104409628"></p><h2 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428104800043.png" alt="image-20240428104800043"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428110845067.png" alt="image-20240428110845067"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111135087.png" alt="image-20240428111135087"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111303598.png" alt="image-20240428111303598"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111510565.png" alt="image-20240428111510565"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111517724.png" alt="image-20240428111517724"></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111556177.png" alt="image-20240428111556177"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111847322.png" alt="image-20240428111847322"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428111953258.png" alt="image-20240428111953258"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112039907.png" alt="image-20240428112039907"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112334211.png" alt="image-20240428112334211"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112423236.png" alt="image-20240428112423236"></p><h3 id="检测和解除"><a href="#检测和解除" class="headerlink" title="检测和解除"></a>检测和解除</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428112508031.png" alt="image-20240428112508031"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114206668.png" alt="image-20240428114206668"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114342738.png" alt="image-20240428114342738"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114537944.png" alt="image-20240428114537944"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114711590.png" alt="image-20240428114711590"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114751638.png" alt="image-20240428114751638"></p><p>（优先处理批处理式的，因为对用户使用影响不大）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240428114902430.png" alt="image-20240428114902430"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429153752166.png" alt="image-20240429153752166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429153924658.png" alt="image-20240429153924658"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429155629486.png" alt="image-20240429155629486"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161049771.png" alt="image-20240429161049771"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161153683.png" alt="image-20240429161153683"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161508184.png" alt="image-20240429161508184"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429161825328.png" alt="image-20240429161825328"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162053249.png" alt="image-20240429162053249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162102537.png" alt="image-20240429162102537"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162249346.png" alt="image-20240429162249346"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162330274.png" alt="image-20240429162330274"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429162410033.png" alt="image-20240429162410033"></p><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163400898.png" alt="image-20240429163400898"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163436757.png" alt="image-20240429163436757"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163535716.png" alt="image-20240429163535716"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163803860.png" alt="image-20240429163803860"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429163827524.png" alt="image-20240429163827524"></p><h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164418713.png" alt="image-20240429164418713"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164455670.png" alt="image-20240429164455670"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164544862.png" alt="image-20240429164544862"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164612141.png" alt="image-20240429164612141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429164806355.png" alt="image-20240429164806355"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429165155247.png" alt="image-20240429165155247"></p><p>（PCB用于对换出内存的管理，所以不能移除）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429165311501.png" alt="image-20240429165311501"></p><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170107455.png" alt="image-20240429170107455"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170230003.png" alt="image-20240429170230003"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170337227.png" alt="image-20240429170337227"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170427693.png" alt="image-20240429170427693"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170534520.png" alt="image-20240429170534520"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170605691.png" alt="image-20240429170605691"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429170629349.png" alt="image-20240429170629349"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429171248308.png" alt="image-20240429171248308"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429171640000.png" alt="image-20240429171640000"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429172307867.png" alt="image-20240429172307867"></p><h2 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429183640521.png" alt="image-20240429183640521"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184107179.png" alt="image-20240429184107179"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184308438.png" alt="image-20240429184308438"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184401089.png" alt="image-20240429184401089"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184847313.png" alt="image-20240429184847313"></p><p>综合而看，四种算法中，首次适应算法的效果反而更好</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429184926780.png" alt="image-20240429184926780"></p><h2 id="基本分页存储管理的概念"><a href="#基本分页存储管理的概念" class="headerlink" title="基本分页存储管理的概念"></a>基本分页存储管理的概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429185044850.png" alt="image-20240429185044850"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192021793.png" alt="image-20240429192021793"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192254015.png" alt="image-20240429192254015"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429192445398.png" alt="image-20240429192445398"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193030243.png" alt="image-20240429193030243"></p><p>由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要3*(n+1)B</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193529864.png" alt="image-20240429193529864"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429193852356.png" alt="image-20240429193852356"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194001277.png" alt="image-20240429194001277"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194313689.png" alt="image-20240429194313689"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194524418.png" alt="image-20240429194524418"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194533049.png" alt="image-20240429194533049"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194608934.png" alt="image-20240429194608934"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240429194709962.png" alt="image-20240429194709962"></p><h2 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430132639778.png" alt="image-20240430132639778"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133036680.png" alt="image-20240430133036680"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430132854505.png" alt="image-20240430132854505"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133322637.png" alt="image-20240430133322637"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133721750.png" alt="image-20240430133721750"></p><p>进程页表通常是装在连续的内存块中的</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430133924940.png" alt="image-20240430133924940"></p><h2 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214406783.png" alt="image-20240430214406783"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214543586.png" alt="image-20240430214543586"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430214820134.png" alt="image-20240430214820134"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215034699.png" alt="image-20240430215034699"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215057205.png" alt="image-20240430215057205"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215201466.png" alt="image-20240430215201466"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215219805.png" alt="image-20240430215219805"></p><h2 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215240895.png" alt="image-20240430215240895"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215333566.png" alt="image-20240430215333566"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215352627.png" alt="image-20240430215352627"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215447088.png" alt="image-20240430215447088"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215536826.png" alt="image-20240430215536826"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430215622471.png" alt="image-20240430215622471"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430221904881.png" alt="image-20240430221904881"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430221945125.png" alt="image-20240430221945125"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222104397.png" alt="image-20240430222104397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222157336.png" alt="image-20240430222157336"></p><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222216947.png" alt="image-20240430222216947"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222313015.png" alt="image-20240430222313015"></p><p><strong>编译程序会将段名转换为段号</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222448571.png" alt="image-20240430222448571"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222607184.png" alt="image-20240430222607184"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222632255.png" alt="image-20240430222632255"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222837702.png" alt="image-20240430222837702"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430222939786.png" alt="image-20240430222939786"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223029812.png" alt="image-20240430223029812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223111412.png" alt="image-20240430223111412"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223204169.png" alt="image-20240430223204169"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223230391.png" alt="image-20240430223230391"></p><h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223311760.png" alt="image-20240430223311760"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223410358.png" alt="image-20240430223410358"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223432847.png" alt="image-20240430223432847"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223516924.png" alt="image-20240430223516924"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223606180.png" alt="image-20240430223606180"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223748610.png" alt="image-20240430223748610"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240430223846996.png" alt="image-20240430223846996"></p><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184705338.png" alt="image-20240502184705338"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184712905.png" alt="image-20240502184712905"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502184811774.png" alt="image-20240502184811774"></p><p>可以用虚拟存储技术来解决以上问题</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185030315.png" alt="image-20240502185030315"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185138135.png" alt="image-20240502185138135"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185227489.png" alt="image-20240502185227489"></p><p>请求分页管理方式</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185306672.png" alt="image-20240502185306672"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185559242.png" alt="image-20240502185559242"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502185728367.png" alt="image-20240502185728367"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194240033.png" alt="image-20240502194240033"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194301875.png" alt="image-20240502194301875"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194349367.png" alt="image-20240502194349367"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194456246.png" alt="image-20240502194456246"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194504439.png" alt="image-20240502194504439"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194613253.png" alt="image-20240502194613253"></p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194654282.png" alt="image-20240502194654282"></p><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194907990.png" alt="image-20240502194907990"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502194923756.png" alt="image-20240502194923756"></p><h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195010397.png" alt="image-20240502195010397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195104391.png" alt="image-20240502195104391"></p><h3 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195219347.png" alt="image-20240502195219347"></p><h3 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195451628.png" alt="image-20240502195451628"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195834848.png" alt="image-20240502195834848"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195846554.png" alt="image-20240502195846554"></p><h2 id="页面分配策略、抖动、工作集"><a href="#页面分配策略、抖动、工作集" class="headerlink" title="页面分配策略、抖动、工作集"></a>页面分配策略、抖动、工作集</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502195917853.png" alt="image-20240502195917853"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200328455.png" alt="image-20240502200328455"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200616114.png" alt="image-20240502200616114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200510409.png" alt="image-20240502200510409"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200724251.png" alt="image-20240502200724251"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502200857234.png" alt="image-20240502200857234"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201108775.png" alt="image-20240502201108775"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201216358.png" alt="image-20240502201216358"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201416165.png" alt="image-20240502201416165"></p><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201435872.png" alt="image-20240502201435872"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201452957.png" alt="image-20240502201452957"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201604556.png" alt="image-20240502201604556"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201730094.png" alt="image-20240502201730094"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201805732.png" alt="image-20240502201805732"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240502201827918.png" alt="image-20240502201827918"></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171030309.png" alt="image-20240504171030309"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171100048.png" alt="image-20240504171100048"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171158309.png" alt="image-20240504171158309"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171509565.png" alt="image-20240504171509565"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504171545533.png" alt="image-20240504171545533"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172200165.png" alt="image-20240504172200165"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172305676.png" alt="image-20240504172305676"></p><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172432897.png" alt="image-20240504172432897"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172450107.png" alt="image-20240504172450107"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172613166.png" alt="image-20240504172613166"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504172700370.png" alt="image-20240504172700370"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173323289.png" alt="image-20240504173323289"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173336639.png" alt="image-20240504173336639"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173521971.png" alt="image-20240504173521971"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173624407.png" alt="image-20240504173624407"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173700930.png" alt="image-20240504173700930"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173729770.png" alt="image-20240504173729770"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173749799.png" alt="image-20240504173749799"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504173854083.png" alt="image-20240504173854083"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504195911089.png" alt="image-20240504195911089"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504200009100.png" alt="image-20240504200009100"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504200404511.png" alt="image-20240504200404511"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215231835.png" alt="image-20240504215231835"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215306445.png" alt="image-20240504215306445"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215331400.png" alt="image-20240504215331400"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504215952889.png" alt="image-20240504215952889"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220119936.png" alt="image-20240504220119936"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220155365.png" alt="image-20240504220155365"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220241393.png" alt="image-20240504220241393"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220544857.png" alt="image-20240504220544857"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220615588.png" alt="image-20240504220615588"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220655481.png" alt="image-20240504220655481"></p><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220740852.png" alt="image-20240504220740852"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220752447.png" alt="image-20240504220752447"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504220855137.png" alt="image-20240504220855137"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221018691.png" alt="image-20240504221018691"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221121523.png" alt="image-20240504221121523"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221145678.png" alt="image-20240504221145678"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221221006.png" alt="image-20240504221221006"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221235714.png" alt="image-20240504221235714"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221253950.png" alt="image-20240504221253950"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221338623.png" alt="image-20240504221338623"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221406153.png" alt="image-20240504221406153"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221527276.png" alt="image-20240504221527276"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221639911.png" alt="image-20240504221639911"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221722289.png" alt="image-20240504221722289"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504221847769.png" alt="image-20240504221847769"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222029236.png" alt="image-20240504222029236"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222113093.png" alt="image-20240504222113093"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222245426.png" alt="image-20240504222245426"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222435451.png" alt="image-20240504222435451"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222441484.png" alt="image-20240504222441484"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222610746.png" alt="image-20240504222610746"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222649601.png" alt="image-20240504222649601"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222734502.png" alt="image-20240504222734502"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504222829167.png" alt="image-20240504222829167"></p><h2 id="逻辑结构vs物理结构"><a href="#逻辑结构vs物理结构" class="headerlink" title="逻辑结构vs物理结构"></a>逻辑结构vs物理结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504223801107.png" alt="image-20240504223801107"></p><p>用户用逻辑地址访问文件</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504224101208.png" alt="image-20240504224101208"></p><p>链接分配：逻辑上相邻的块在物理上用链接指针表示先后关系</p><p>索引分配：操作系统为每个文件维护一张索引表，其中记录了逻辑块号-&gt;物理块号的映射关系</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225231869.png" alt="image-20240504225231869"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225343412.png" alt="image-20240504225343412"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504225423299.png" alt="image-20240504225423299"></p><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504230904031.png" alt="image-20240504230904031"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231052685.png" alt="image-20240504231052685"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231222045.png" alt="image-20240504231222045"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231330897.png" alt="image-20240504231330897"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231405631.png" alt="image-20240504231405631"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231501014.png" alt="image-20240504231501014"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231702988.png" alt="image-20240504231702988"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231734142.png" alt="image-20240504231734142"></p><p><strong>连续分配和离散分配都适用</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231829147.png" alt="image-20240504231829147"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504231940539.png" alt="image-20240504231940539"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232055144.png" alt="image-20240504232055144"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232136941.png" alt="image-20240504232136941"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232227928.png" alt="image-20240504232227928"></p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232311717.png" alt="image-20240504232311717"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232402356.png" alt="image-20240504232402356"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232515051.png" alt="image-20240504232515051"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232622767.png" alt="image-20240504232622767"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232720671.png" alt="image-20240504232720671"></p><p>读写指针记录了该进程对文件的读&#x2F;写操作进行到的位置</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232851782.png" alt="image-20240504232851782"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504232947726.png" alt="image-20240504232947726"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233116280.png" alt="image-20240504233116280"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233232205.png" alt="image-20240504233232205"></p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233249597.png" alt="image-20240504233249597"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233306020.png" alt="image-20240504233306020"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233405003.png" alt="image-20240504233405003"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233441070.png" alt="image-20240504233441070"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233519512.png" alt="image-20240504233519512"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233615226.png" alt="image-20240504233615226"></p><p>用软链接访问比硬链接访问更慢</p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233710763.png" alt="image-20240504233710763"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233744538.png" alt="image-20240504233744538"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233836916.png" alt="image-20240504233836916"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233849257.png" alt="image-20240504233849257"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504233944363.png" alt="image-20240504233944363"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504234020658.png" alt="image-20240504234020658"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240504234249589.png" alt="image-20240504234249589"></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004126460.png" alt="image-20240505004126460"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004321745.png" alt="image-20240505004321745"></p><h2 id="全局结构（布局）"><a href="#全局结构（布局）" class="headerlink" title="全局结构（布局）"></a>全局结构（布局）</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004424894.png" alt="image-20240505004424894"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004553268.png" alt="image-20240505004553268"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004659347.png" alt="image-20240505004659347"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505004823504.png" alt="image-20240505004823504"></p><h2 id="虚拟文件系统-文件系统挂载（安装）"><a href="#虚拟文件系统-文件系统挂载（安装）" class="headerlink" title="虚拟文件系统&amp;文件系统挂载（安装）"></a>虚拟文件系统&amp;文件系统挂载（安装）</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010711222.png" alt="image-20240505010711222"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010719404.png" alt="image-20240505010719404"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010808536.png" alt="image-20240505010808536"></p><p>不同的文件系统，文件数据结构各不相同</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505010952068.png" alt="image-20240505010952068"></p><p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505011216050.png" alt="image-20240505011216050"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505011428925.png" alt="image-20240505011428925"></p><h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="IO设备的概念和分类"><a href="#IO设备的概念和分类" class="headerlink" title="IO设备的概念和分类"></a>IO设备的概念和分类</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225718206.png" alt="image-20240505225718206"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225746149.png" alt="image-20240505225746149"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225827445.png" alt="image-20240505225827445"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225846591.png" alt="image-20240505225846591"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225911811.png" alt="image-20240505225911811"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505225942693.png" alt="image-20240505225942693"></p><h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230011862.png" alt="image-20240505230011862"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230024418.png" alt="image-20240505230024418"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230220253.png" alt="image-20240505230220253"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230449678.png" alt="image-20240505230449678"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230525811.png" alt="image-20240505230525811"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230650922.png" alt="image-20240505230650922"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505230850587.png" alt="image-20240505230850587"></p><h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231017333.png" alt="image-20240505231017333"></p><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231202758.png" alt="image-20240505231202758"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231400321.png" alt="image-20240505231400321"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231500903.png" alt="image-20240505231500903"></p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231626441.png" alt="image-20240505231626441"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231808551.png" alt="image-20240505231808551"></p><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505231926063.png" alt="image-20240505231926063"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232123731.png" alt="image-20240505232123731"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232248661.png" alt="image-20240505232248661"></p><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232345060.png" alt="image-20240505232345060"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232427047.png" alt="image-20240505232427047"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232459847.png" alt="image-20240505232459847"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232537544.png" alt="image-20240505232537544"></p><h2 id="IO软件层次结构"><a href="#IO软件层次结构" class="headerlink" title="IO软件层次结构"></a>IO软件层次结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232703178.png" alt="image-20240505232703178"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505232753417.png" alt="image-20240505232753417"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233318743.png" alt="image-20240505233318743"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233149021.png" alt="image-20240505233149021"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233457047.png" alt="image-20240505233457047"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233617288.png" alt="image-20240505233617288"></p><p><strong>设备驱动程序和中断处理程序是直接跟硬件打交道的</strong></p><h2 id="输入输出应用程序接口-设备驱动程序接口"><a href="#输入输出应用程序接口-设备驱动程序接口" class="headerlink" title="输入输出应用程序接口&amp;设备驱动程序接口"></a>输入输出应用程序接口&amp;设备驱动程序接口</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505233805618.png" alt="image-20240505233805618"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234639307.png" alt="image-20240505234639307"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234410497.png" alt="image-20240505234410497"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234728857.png" alt="image-20240505234728857"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234818521.png" alt="image-20240505234818521"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240505234903607.png" alt="image-20240505234903607"></p><h1 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515185912720.png" alt="image-20240515185912720"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190016114.png" alt="image-20240515190016114"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190051769.png" alt="image-20240515190051769"></p><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190141105.png" alt="image-20240515190141105"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190246973.png" alt="image-20240515190246973"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190306405.png" alt="image-20240515190306405"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190348462.png" alt="image-20240515190348462"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190414097.png" alt="image-20240515190414097"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190512805.png" alt="image-20240515190512805"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190629310.png" alt="image-20240515190629310"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190740808.png" alt="image-20240515190740808"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190807314.png" alt="image-20240515190807314"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190833819.png" alt="image-20240515190833819"></p><h2 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190904141.png" alt="image-20240515190904141"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515190947631.png" alt="image-20240515190947631"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515191148963.png" alt="image-20240515191148963"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515191324566.png" alt="image-20240515191324566"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515193830101.png" alt="image-20240515193830101"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515193931812.png" alt="image-20240515193931812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194021285.png" alt="image-20240515194021285"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194050812.png" alt="image-20240515194050812"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194117090.png" alt="image-20240515194117090"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194219582.png" alt="image-20240515194219582"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194338774.png" alt="image-20240515194338774"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194431060.png" alt="image-20240515194431060"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194458390.png" alt="image-20240515194458390"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194614688.png" alt="image-20240515194614688"></p><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194823232.png" alt="image-20240515194823232"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515194900675.png" alt="image-20240515194900675"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195003159.png" alt="image-20240515195003159"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195218929.png" alt="image-20240515195218929"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195312946.png" alt="image-20240515195312946"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195413937.png" alt="image-20240515195413937"></p><p><strong>结论：采用单缓冲策略，处理一块数据平均耗时Max(C，T)+M</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515195613001.png" alt="image-20240515195613001"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515200142640.png" alt="image-20240515200142640"></p><p><strong>结论：采用双缓冲策略，先处理一个数据快的平均时间为Max(T,C+M)</strong></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202408963.png" alt="image-20240515202408963"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202425470.png" alt="image-20240515202425470"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202511574.png" alt="image-20240515202511574"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202711480.png" alt="image-20240515202711480"></p><p>第一个是收容输入，第二个是提取输入，第三个是收容输出，第四个是提取输出。</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240515202850685.png" alt="image-20240515202850685"></p><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215343934.png" alt="image-20240516215343934"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215441480.png" alt="image-20240516215441480"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215519553.png" alt="image-20240516215519553"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215636134.png" alt="image-20240516215636134"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215658355.png" alt="image-20240516215658355"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215710532.png" alt="image-20240516215710532"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215735020.png" alt="image-20240516215735020"></p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516215845127.png" alt="image-20240516215845127"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222616024.png" alt="image-20240516222616024"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222649827.png" alt="image-20240516222649827"></p><p>通过软件无法改变延迟时间和传输时间，但是操作系统的磁盘调度算法会直接影响寻道时间。</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516222841882.png" alt="image-20240516222841882"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223106937.png" alt="image-20240516223106937"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223224545.png" alt="image-20240516223224545"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223313155.png" alt="image-20240516223313155"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223420104.png" alt="image-20240516223420104"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223452110.png" alt="image-20240516223452110"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223528949.png" alt="image-20240516223528949"></p><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223637792.png" alt="image-20240516223637792"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223731203.png" alt="image-20240516223731203"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516223858397.png" alt="image-20240516223858397"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224116789.png" alt="image-20240516224116789"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224130200.png" alt="image-20240516224130200"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224232260.png" alt="image-20240516224232260"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224319135.png" alt="image-20240516224319135"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224337508.png" alt="image-20240516224337508"></p><h2 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224403877.png" alt="image-20240516224403877"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224616726.png" alt="image-20240516224616726"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224714791.png" alt="image-20240516224714791"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516224847796.png" alt="image-20240516224847796"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225039778.png" alt="image-20240516225039778"></p><p>（对操作系统透明即为操作系统不可知，不透明即为操作系统可知）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225117627.png" alt="image-20240516225117627"></p><h2 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h2><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225206249.png" alt="image-20240516225206249"></p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225250497.png" alt="image-20240516225250497"></p><p>SSD中黑色的块就是一个个闪存芯片</p><p>固态硬盘的读写单位是页，页相当于磁盘中的块&#x2F;扇区，固态硬盘的块相当于磁盘的磁道</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516225511475.png" alt="image-20240516225511475"></p><p>固态硬盘读的速度通常很快，但是写的速度会慢的多（由于写的动作可能会引起擦除的动作以及数据迁移的动作）</p><p><img src="/2024/07/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240516230425181.png" alt="image-20240516230425181"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试必备知识点 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本指令</title>
      <link href="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="显示—ls"><a href="#显示—ls" class="headerlink" title="显示—ls"></a>显示—ls</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213158767.png" alt="image-20240324213042128"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213250705.png" alt="image-20240324213250705"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213332270.png" alt="image-20240324213332270"></p><h1 id="切换工作目录—cd"><a href="#切换工作目录—cd" class="headerlink" title="切换工作目录—cd"></a>切换工作目录—cd</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213353859.png" alt="image-20240324213353859"></p><h1 id="查看工作目录—pwd"><a href="#查看工作目录—pwd" class="headerlink" title="查看工作目录—pwd"></a>查看工作目录—pwd</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213420156.png" alt="image-20240324213420156"></p><h1 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213511589.png" alt="image-20240324213511589"></p><h1 id="创建目录—mkdir"><a href="#创建目录—mkdir" class="headerlink" title="创建目录—mkdir"></a>创建目录—mkdir</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213536359.png" alt="image-20240324213536359"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213601946.png" alt="image-20240324213601946"></p><h1 id="创建文件—touch"><a href="#创建文件—touch" class="headerlink" title="创建文件—touch"></a>创建文件—touch</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213622899.png" alt="image-20240324213622899"></p><h1 id="查看文件内容—cat"><a href="#查看文件内容—cat" class="headerlink" title="查看文件内容—cat"></a>查看文件内容—cat</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213638906.png" alt="image-20240324213638906"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213704783-17112874254251.png" alt="image-20240324213704783"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213723718.png" alt="image-20240324213723718"></p><h1 id="复制—cp，移动—mv，删除—rm"><a href="#复制—cp，移动—mv，删除—rm" class="headerlink" title="复制—cp，移动—mv，删除—rm"></a>复制—cp，移动—mv，删除—rm</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213752631.png" alt="image-20240324213752631"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213820095.png" alt="image-20240324213820095"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213832997.png" alt="image-20240324213832997"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213854257.png" alt="image-20240324213854257"></p><h1 id="查找—which-find"><a href="#查找—which-find" class="headerlink" title="查找—which&#x2F;find"></a>查找—which&#x2F;find</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213917733.png" alt="image-20240324213917733"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213942043.png" alt="image-20240324213942043"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213953644.png" alt="image-20240324213953644"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214013971.png" alt="image-20240324214013971"></p><h1 id="过滤—grep"><a href="#过滤—grep" class="headerlink" title="过滤—grep"></a>过滤—grep</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214104661.png" alt="image-20240324214104661"></p><h1 id="数量统计—wc"><a href="#数量统计—wc" class="headerlink" title="数量统计—wc"></a>数量统计—wc</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213058155.png" alt="image-20240324213058155"></p><h1 id="管道符—“-”"><a href="#管道符—“-”" class="headerlink" title="管道符—“|”"></a>管道符—“|”</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324213122982.png" alt="image-20240324213122982"></p><h1 id="输出指定内容—echo"><a href="#输出指定内容—echo" class="headerlink" title="输出指定内容—echo"></a>输出指定内容—echo</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214203237.png" alt="image-20240324214203237"></p><h1 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214246163.png" alt="image-20240324214246163"></p><h1 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214333538.png" alt="image-20240324214333538"></p><h1 id="查看尾部内容—tail"><a href="#查看尾部内容—tail" class="headerlink" title="查看尾部内容—tail"></a>查看尾部内容—tail</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324214425502.png" alt="image-20240324214425502"></p><p>持续跟踪指再通过&gt;&gt;对文件追加内容时，会同时显示出来。</p><p>可以通过CTRL+C结束命令运行。</p><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220144155.png" alt="image-20240324220144155"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220300768.png" alt="image-20240324220300768"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324220219685.png" alt="image-20240324220219685"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221017284.png" alt="image-20240324221017284"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221155625.png" alt="image-20240324221155625"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240324221443763.png" alt="image-20240324221443763"></p><h1 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235721324.png" alt="image-20240326235721324"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235743426.png" alt="image-20240326235743426"></p><h1 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235855782.png" alt="image-20240326235855782"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240326235940645.png" alt="image-20240326235940645"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000647083.png" alt="image-20240327000647083"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000716131.png" alt="image-20240327000716131"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327000755732.png" alt="image-20240327000755732"></p><h1 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001138163.png" alt="image-20240327001138163"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001153182.png" alt="image-20240327001153182"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001314477.png" alt="image-20240327001314477"></p><h1 id="修改权限—chmod"><a href="#修改权限—chmod" class="headerlink" title="修改权限—chmod"></a>修改权限—chmod</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327001806438.png" alt="image-20240327001806438"></p><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327002348443.png" alt="image-20240327002348443"></p><h1 id="修改用户、用户组—chown"><a href="#修改用户、用户组—chown" class="headerlink" title="修改用户、用户组—chown"></a>修改用户、用户组—chown</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327002709372.png" alt="image-20240327002709372"></p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327225812236.png" alt="image-20240327225812236"></p><h1 id="安装软件—apt-yum"><a href="#安装软件—apt-yum" class="headerlink" title="安装软件—apt&#x2F;yum"></a>安装软件—apt&#x2F;yum</h1><p><img src="/2024/07/02/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/image-20240327230014265.png" alt="image-20240327230014265"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平台正在搭建中</title>
      <link href="/2024/05/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/05/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>将会持续更新操作系统、计网、计组、算法、后端等相关知识，敬请期待~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/23/hello-world/"/>
      <url>/2024/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>个人介绍</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class="note red icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p><strong>欢迎光临珈豪の学习仓库！！！</strong></p></div><p>本人就读于南京大学软件学院，该博客中将会持续发布面试必需的重点专业课知识以及面向就业的必备能力，希望大家能够收藏并且持续关注……</p><p>此网站一方面是为了记录自己的成长之路，另一方面也是鼓励大家坚持做自己所热爱的东西，让我们携手前行，遇见更好的自己！</p>]]></content>
      
    </entry>
    
    
  
</search>
