<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | 珈豪の学习仓库</title><meta name="author" content="Shi Jiahao"><meta name="copyright" content="Shi Jiahao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于Java基础的常见面试题，主要依据小林coding的Java面试题进行了完善和修改。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://gentleshiao.github.io/2024/10/17/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="珈豪の学习仓库">
<meta property="og:description" content="关于Java基础的常见面试题，主要依据小林coding的Java面试题进行了完善和修改。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://gentleshiao.github.io/img/java.jpg">
<meta property="article:published_time" content="2024-10-17T13:22:00.000Z">
<meta property="article:modified_time" content="2024-10-17T13:26:15.960Z">
<meta property="article:author" content="Shi Jiahao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试必备知识点">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://gentleshiao.github.io/img/java.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="http://gentleshiao.github.io/2024/10/17/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 21:26:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐（暂未开放）</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-photo-video"></i><span> 图片（暂未开放）</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/java.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="珈豪の学习仓库"><span class="site-name">珈豪の学习仓库</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐（暂未开放）</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-photo-video"></i><span> 图片（暂未开放）</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-17T13:22:00.000Z" title="发表于 2024-10-17 21:22:00">2024-10-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T13:26:15.960Z" title="更新于 2024-10-17 21:26:15">2024-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><ul>
<li><strong>平台无关性</strong>：Java编写一次，运行无处不在。Java编译器将源代码编译成字节码，可以在任何安装了JVM的系统上运行。</li>
<li><strong>面向对象</strong>：Java是一门严格的面向对象的编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类、对象、继承、多态、抽象和封装。</li>
<li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关问题。</li>
</ul>
<h2 id="Java为什么是跨平台的"><a href="#Java为什么是跨平台的" class="headerlink" title="Java为什么是跨平台的"></a>Java为什么是跨平台的</h2><p>主要依赖于JVM。JVM也是一个软件，不同的平台有不同的版本。编写的Java源码编译后会生成一种.class文件，称为字节码文件。JVM就是负责将字节码文件翻译成特定平台下的机器码然后运行。只要在不同平台上安装对应的JVM就可以运行字节码文件，运行编写的Java程序。</p>
<p><em>（不同平台下编译生成的字节码是一样的，但是由 JVM编译成的机器码却不一样）</em></p>
<p><em>（跨平台的是 Java程序，不是 JVM。JVM是用 C&#x2F;C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM。）</em></p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713860588639-bb89fc8e-30b6-4d18-a329-f3fea52c729a.png" alt="img"></p>
<h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p>JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。JVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“<strong>一次编译，到处运行的</strong>”原因。</p>
<h2 id="JVM、JDK、JRE三者的关系"><a href="#JVM、JDK、JRE三者的关系" class="headerlink" title="JVM、JDK、JRE三者的关系"></a>JVM、JDK、JRE三者的关系</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240725230247664.png" alt="image-20240725230247664"></p>
<ul>
<li>JVM是Java虚拟机，是Java程序运行的环境，负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li>
<li>JDK是Java开发工具包，是开发Java程序所需的工具集合。包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li>
<li>JRE是Java运行时的环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li>
</ul>
<h2 id="为什么Java解释和编译都有"><a href="#为什么Java解释和编译都有" class="headerlink" title="为什么Java解释和编译都有"></a>为什么Java解释和编译都有</h2><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤——编译和解释。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.webp" alt="img"></p>
<p><strong>编译性</strong>：</p>
<ul>
<li>Java源代码首先被编译成字节码，JIT会把编译过的机器码保存起来，以备下次使用。</li>
</ul>
<p><strong>解释性</strong>：</p>
<ul>
<li>JVM中有一个方法调用计数器，当累计计数大于一定值时，就使用JIT进行编译生成机器码文件，否则就使用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。</li>
</ul>
<p>所以Java既是编译性也是解释性语言，默认采用解释器和编译器混合的模式。</p>
<h2 id="编译型语言和解释型语言的区别？"><a href="#编译型语言和解释型语言的区别？" class="headerlink" title="编译型语言和解释型语言的区别？"></a><strong>编译型语言和解释型语言的区别？</strong></h2><p>编译型语言和解释型语言的区别在于：</p>
<ul>
<li>编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。</li>
<li>解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。</li>
<li>典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。</li>
</ul>
<h2 id="Python和Java区别是什么？"><a href="#Python和Java区别是什么？" class="headerlink" title="Python和Java区别是什么？"></a>Python和Java区别是什么？</h2><ul>
<li>Java是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行</li>
<li>python是一种解释语言，翻译时会在执行程序的同时进行翻译。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><p>Java支持数据类型分为：<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p>
<p>基本数据类型包括：</p>
<ul>
<li>数值型：整数类型（byte、short、int、long）和浮点类型（float、double）</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930632378-7f03a5ae-3364-41d4-88a8-428997d543dd.png" alt="img"></p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715930589177-73932d2c-b0c0-4f58-a5c1-ab514b1a389c.png" alt="img"></p>
<p><strong>注意</strong>：</p>
<ul>
<li>java八种基本数据类型的字节数:1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)</li>
<li>浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）</li>
<li>整数的默认类型为int（声明Long型在末尾加上l或者L）</li>
<li>八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写</li>
<li>char类型是无符号的，不能为负，所以是0开始的</li>
</ul>
<h2 id="数据类型转换方式"><a href="#数据类型转换方式" class="headerlink" title="数据类型转换方式"></a>数据类型转换方式</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240726003850183.png" alt="image-20240726003850183"></p>
<ul>
<li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。</li>
<li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。</li>
<li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。</li>
<li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。</li>
</ul>
<h2 id="类型互转会出现什么问题"><a href="#类型互转会出现什么问题" class="headerlink" title="类型互转会出现什么问题"></a>类型互转会出现什么问题</h2><ul>
<li>数据丢失：大类型转小类型，可能截断后高位丢失，如long转int</li>
<li>数据溢出：如double转int</li>
<li>精度损失：浮点数类型转换，如float转double</li>
<li>类型不匹配</li>
</ul>
<h2 id="为什么用bigDecimal而不用double"><a href="#为什么用bigDecimal而不用double" class="headerlink" title="为什么用bigDecimal而不用double"></a>为什么用bigDecimal而不用double</h2><p>double执行二进制浮点运算，会出现精度丢失，Decimal是精确运算，一般用于金钱的运算。</p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。</p>
<p>eg. Integer i &#x3D; 10；&#x2F;&#x2F;装箱</p>
<p>​	int n &#x3D; i；&#x2F;&#x2F;拆箱</p>
<p>自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p>
<p><strong>赋值时</strong>：</p>
<p>最常见的一种情况，Java1.5前需要手动转换，现在所有转换由编译器完成。</p>
<p><strong>方法调用时</strong>：</p>
<p>可以传入原始数据值或者对象，同样编译器会帮我们转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">show</span><span class="params">(Integer iParam)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;autoboxing example - method invocation i: &quot;</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure>

<p><strong>自动装箱的弊端</strong>：</p>
<p>如果在一个循环中进行自动装箱操作，下面的例子会创建多个多余的对象，影响性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>sum进行自动拆箱，然后数值相加，最好自动装箱转换成Integer对象。所以循环中会创建4000个无用的Integer对象，会降低程序性能并且加重垃圾回收的工作量。所以应该正确声明变量类型，避免自动装箱引起的性能问题。</p>
<h2 id="Java为什么要有Integer"><a href="#Java为什么要有Integer" class="headerlink" title="Java为什么要有Integer"></a>Java为什么要有Integer</h2><ul>
<li><p>Integer是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性（数据）跟处理这些数据的方法结合在一起。（比如Integer中的parseInt()等方法）。</p>
</li>
<li><p>Java绝大部分方法或类都是用来处理类类型对象的。</p>
<ul>
<li><p>泛型中：只能使用引用类型，而不能使用基本类型。如果在泛型中使用int类型，就必须使用Integer包装类。（例如：Collections.sort()内部放Integer而不是int。）</p>
</li>
<li><p>转换中：基本类型和引用类型不能直接进行转换，必须使用包装类来实现。（例如，int不能直接转成String，需要先转换成Integer类型，再转成String类型。）</p>
</li>
<li><p>集合中：Java集合只能存储对象，而不能存储基本数据类型。（例如，ArrayList集合类就只能以类作为他的存储对象，如果用Integer包装类，可以直接使用stream()方法来计算所有元素的和：int sum &#x3D; list.stream().mapToInt(Integer::intValue).sum();）</p>
</li>
</ul>
</li>
</ul>
<h2 id="Integer与int的区别"><a href="#Integer与int的区别" class="headerlink" title="Integer与int的区别"></a>Integer与int的区别</h2><ul>
<li>类型：int是基本数据类型，Integer是引用类型。前者是预定义的，不需要实例化就可以使用，而后者需要通过实例化对象来使用。意味着前者不需要额外的内存分配，而后者必须为对象分配内存。性能方面，前者通常较快。</li>
<li>自动装箱与拆箱：可以自动装箱和拆箱。</li>
<li>空指针异常：int可以直接赋值为0，而Integer必须实例化对象来赋值，否则操作时会出现空指针异常，因为被赋予了null值，而null值无法自动拆箱。</li>
</ul>
<h2 id="为什么要保留int类型"><a href="#为什么要保留int类型" class="headerlink" title="为什么要保留int类型"></a>为什么要保留int类型</h2><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身，所以基本数据类型读写效率更高。此外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存方面，而一个int类型数据只占用4字节的内存空间。所以读写效率和存储效率基本类型都比包装类高效。</p>
<h2 id="Integer的缓存"><a href="#Integer的缓存" class="headerlink" title="Integer的缓存"></a>Integer的缓存</h2><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。默认情况下这个范围是-128-127，当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="怎么理解面向对象"><a href="#怎么理解面向对象" class="headerlink" title="怎么理解面向对象"></a>怎么理解面向对象</h2><p>面向对象是一种编程范式，<strong>将现实世界中的事物抽象成对象</strong>，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的性能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。</p>
<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul>
<li><strong>封装</strong>：将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。目的是增强安全性和简化编程，使对象更加独立。</li>
<li><strong>继承</strong>：使得子类自动共享父类数据结构和方法的机制。是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。</li>
<li><strong>多态</strong>：允许不同类的对象对同一消息作出响应，即同一个接口，使得不同的实例而执行不同操作、可分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。</li>
</ul>
<h2 id="多态体现在哪几个方面"><a href="#多态体现在哪几个方面" class="headerlink" title="多态体现在哪几个方面"></a>多态体现在哪几个方面</h2><ul>
<li><strong>方法重载</strong>：指同一个类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但传入的参数不同，编译器会在编译时确定调用哪个方法。<ul>
<li>示例：对于一个add方法，可以定义为add(int a, int b)和add(double a, double b)。</li>
</ul>
</li>
<li><strong>方法重写</strong>：指子类能够提供父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法，这是实现多态的主要方式。<ul>
<li>示例：在一个动物类中，定义一个sound方法，子类Dog可以重写该方法以实现bark，而Cat可以实现meow。</li>
</ul>
</li>
<li><strong>接口与实现</strong>：多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法，使得程序在面对不同具体实现时保持一贯的调用方式。<ul>
<li>示例：多个类（如Dog，cat）都实现了一个Animal接口，当用Animal类型的引用来调用makeSound方法时，会触发对应的实现。</li>
</ul>
</li>
<li><strong>向下转型和向上转型</strong>：向上转型：可以使用父类类型的引用指向子类对象，这样可以在运行时采用不同的子类实现；向下转型：父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免ClassCastException。</li>
</ul>
<h2 id="多态解决了什么问题"><a href="#多态解决了什么问题" class="headerlink" title="多态解决了什么问题"></a>多态解决了什么问题</h2><p><em>多态指子类可以替换父类，在实际的代码运行中调用子类的方法实现。</em></p>
<p>多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的if-else语句等。</p>
<h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><ul>
<li><strong>单一职责原则（SRP）</strong>：一个类只负责处理一种改变（一项职责）。</li>
<li><strong>开放封闭原则（OCP）</strong>：对扩展开放，对修改关闭。</li>
<li><strong>里氏替换原则（LSP）</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。子类继承父类时，除了添加新的方法完成新增功能外，尽量不要重写父类的方法。</li>
<li><strong>接口隔离原则（ISP）</strong>：客户端不应该依赖那些它不需要的接口，即接口应该小而专。</li>
<li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li>
<li><strong>最少知识原则（迪米特法则）（Law of Demeter）</strong>：一个对象应当对其他对象有尽可能少的了解。</li>
<li><strong>组合&#x2F;聚合复用原则</strong>：优先使用对象组合，而不是类继承。</li>
</ul>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ul>
<li><strong>重载</strong>：同一个类中可以定义多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序），编译器会根据调用时的参数类型决定调用哪个方法。</li>
<li><strong>重写</strong>：子类重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@Override注解来表示重写。</li>
</ul>
<h2 id="抽象类和普通类的区别"><a href="#抽象类和普通类的区别" class="headerlink" title="抽象类和普通类的区别"></a>抽象类和普通类的区别</h2><ul>
<li><strong>实例化</strong>：普通类可以直接使用new关键字来实例化对象；而抽象类不能直接实例化，只能被继承。</li>
<li><strong>方法实现</strong>：普通类的方法可以有具体实现；而抽象类中没有方法体，必须在继承它的子类中被重写（除非子类也是抽象类）。</li>
<li><strong>继承</strong>：一个类可以继承一个普通类，继承后的新类可以选择重写父类的方法，而且可以继承多个接口；而一个类只能继承一个抽象类，子类必须实现父类中的所有抽象方法，除非子类也是抽象类，但可以同时实现多个接口。</li>
<li><strong>实现限制（用途）</strong>：普通类可以被其他类继承和使用；而抽象类一般用于作为基类，被其他类继承和扩展使用。</li>
</ul>
<h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p><strong>两者特点</strong>：</p>
<ul>
<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li>
<li>接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java8以后可以有默认方法和静态方法）。适用于定义类的能力和功能。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>实现方式</strong>：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</li>
<li><strong>方法方式</strong>：接口只有定义，不能有方法的实现，java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可以在抽象类中实现。</li>
<li><strong>访问修饰符</strong>：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可以被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</li>
<li><strong>变量</strong>：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态变量）。</li>
</ul>
<h2 id="抽象类能否加final修饰"><a href="#抽象类能否加final修饰" class="headerlink" title="抽象类能否加final修饰"></a>抽象类能否加final修饰</h2><p>不能。</p>
<p>Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。</p>
<h2 id="接口里面可以定义的方法"><a href="#接口里面可以定义的方法" class="headerlink" title="接口里面可以定义的方法"></a>接口里面可以定义的方法</h2><ul>
<li><strong>抽象方法</strong>：接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是public和abstract，这些修饰符可以省略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>默认方法</strong></li>
</ul>
<p>默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法</strong></li>
</ul>
<p>静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method in interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>私有方法</strong></li>
</ul>
<p>私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sleeping...&quot;</span>);</span><br><span class="line">        logSleep();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logSleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logging sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类能否被实例化"><a href="#抽象类能否被实例化" class="headerlink" title="抽象类能否被实例化"></a>抽象类能否被实例化</h2><p>不能。</p>
<p>所以不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。</p>
<p>抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 调用抽象类的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码可以运行</span></span><br><span class="line"><span class="type">ConcreteClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br></pre></td></tr></table></figure>

<p>在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。</p>
<p>简而言之，抽象类不能直接实例化，但<strong>通过继承抽象类</strong>并<strong>实现所有抽象方法</strong>的子类是可以被实例化的。</p>
<h2 id="接口能否包含构造函数"><a href="#接口能否包含构造函数" class="headerlink" title="接口能否包含构造函数"></a>接口能否包含构造函数</h2><p>在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。</p>
<p><em>（构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用。）</em></p>
<p>java的接口不能new所以不需要构造函数，根本就没法调用。</p>
<h2 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h2><p>二者与类本身关联，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。</p>
<p><strong>静态变量</strong>（也称为类变量）是在类中使用<code>static</code>关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>共享性</strong>：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。</li>
<li><strong>初始化</strong>：静态变量在类被加载时初始化，只会对其进行一次分配内存。</li>
<li><strong>访问方式</strong>：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。</li>
</ul>
<p>示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int staticVar = 0; // 静态变量</span><br><span class="line"></span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        staticVar++; // 每创建一个对象，静态变量自增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void printStaticVar() &#123;</span><br><span class="line">        System.out.println(&quot;Static Var: &quot; + staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = new MyClass();</span><br><span class="line">MyClass.printStaticVar(); // 输出 Static Var: 2</span><br></pre></td></tr></table></figure>

<p><strong>静态方法</strong>是在类中使用<code>static</code>关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：</p>
<ul>
<li><strong>无实例依赖</strong>：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。</li>
<li><strong>访问静态成员</strong>：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。</li>
<li><strong>多态性</strong>：静态方法不支持重写（Override），但可以被隐藏（Hide）。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    // 静态方法</span><br><span class="line">    public static void incrementCount() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void displayCount() &#123;</span><br><span class="line">        System.out.println(&quot;Count: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">MyClass.incrementCount(); // 调用静态方法</span><br><span class="line">MyClass.displayCount();   // 输出 Count: 1</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：</p>
<ul>
<li><strong>静态变量</strong>：常用于需要在所有对象间共享的数据，如计数器、常量等。</li>
<li><strong>静态方法</strong>：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理</li>
</ul>
<h2 id="非静态内部类和静态内部类的区别"><a href="#非静态内部类和静态内部类的区别" class="headerlink" title="非静态内部类和静态内部类的区别"></a>非静态内部类和静态内部类的区别</h2><ul>
<li>非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。</li>
<li>非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。</li>
<li>非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。</li>
<li>非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。</li>
<li>非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。</li>
</ul>
<h2 id="非静态内部类可以直接访问外部方法，编译器是怎么做到的"><a href="#非静态内部类可以直接访问外部方法，编译器是怎么做到的" class="headerlink" title="非静态内部类可以直接访问外部方法，编译器是怎么做到的"></a>非静态内部类可以直接访问外部方法，编译器是怎么做到的</h2><p>非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。</p>
<p>这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。</p>
<h2 id="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"><a href="#有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的" class="headerlink" title="有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的"></a>有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的</h2><p>当实例化一个子类对象时，静态成员变量、静态构造方法和静态方法的加载顺序遵循以下步骤：</p>
<ul>
<li>在创建子类对象之前，首先会加载父类的静态成员变量和静态代码块（构造方法无法被 <code>static</code> 修饰，因此这里是静态代码块）。这个加载是在类首次被加载时进行的，且只会发生一次。</li>
<li>接下来，加载子类的静态成员变量和静态代码块。这一过程也只发生一次，即当首次使用子类的相关代码时。</li>
<li>之后，执行实例化子类对象的过程。这时会呼叫父类构造方法，然后是子类的构造方法。</li>
</ul>
<p>具体加载顺序可以简要总结为：</p>
<ul>
<li><strong>父类静态成员变量、静态代码块</strong>（如果有）</li>
<li><strong>子类静态成员变量、静态代码块</strong>（如果有）</li>
<li><strong>父类构造方法</strong>（实例化对象时）</li>
<li><strong>子类构造方法</strong>（实例化对象时）</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">parentStaticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Parent() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">childStaticVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Child() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line">Child <span class="keyword">static</span> block</span><br><span class="line">Parent constructor</span><br><span class="line">Child constructor</span><br></pre></td></tr></table></figure>

<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683675376-c5af6668-4538-479f-84e8-42d4143ab101.webp" alt="img"></p>
<ul>
<li><strong>浅拷贝</strong>：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。相当于只是创建了一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型字段，只是将引用复制到新对象中，两个对象指向同一个引用对象。</li>
<li><strong>深拷贝</strong>：复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。相当于会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。</li>
</ul>
<h2 id="实现深拷贝的三种方法"><a href="#实现深拷贝的三种方法" class="headerlink" title="实现深拷贝的三种方法"></a>实现深拷贝的三种方法</h2><ul>
<li>实现 Cloneable 接口并重写 clone() 方法</li>
</ul>
<p>这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">cloned</span> <span class="operator">=</span> (MyClass) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.nestedObject = (NestedClass) nestedObject.clone(); <span class="comment">// 深拷贝内部的引用对象</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用序列化和反序列化</li>
</ul>
<p>通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (MyClass) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动递归复制</li>
</ul>
<p>针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String field1;</span><br><span class="line">    <span class="keyword">private</span> NestedClass nestedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        copy.setField1(<span class="built_in">this</span>.field1);</span><br><span class="line">        copy.setNestedObject(<span class="built_in">this</span>.nestedObject.deepCopy());</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NestedClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nestedField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NestedClass <span class="title function_">deepCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NestedClass</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NestedClass</span>();</span><br><span class="line">        copy.setNestedField(<span class="built_in">this</span>.nestedField);</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。</p>
<p>泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。</p>
<h2 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h2><ul>
<li><strong>适用于多种数据类型执行相同的代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure>

<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure>

<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><p><strong>使用new关键字</strong>：通过new关键字直接调用类的构造方法来创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>

<p><strong>使用Class类的newInstance()方法</strong>：通过反射机制，可以使用Class类的newInstance()方法创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>使用Constructor类的newInstance()方法</strong>：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>使用clone()方法</strong>：如果类实现了Cloneable接口，可以使用clone()方法复制对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<p><strong>使用反序列化</strong>：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SerializedObject.java</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeserializedObject.java</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h2 id="Java创建对象除了new还有什么方式"><a href="#Java创建对象除了new还有什么方式" class="headerlink" title="Java创建对象除了new还有什么方式"></a>Java创建对象除了new还有什么方式</h2><ul>
<li><strong>通过反射创建对象</strong>：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Constructor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过反序列化创建对象</strong>：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// Class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Serialize object</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">        out.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Deserialize object</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> (MyClass) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过clone创建对象</strong>：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyClass) obj1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new出的对象什么时候回收"><a href="#new出的对象什么时候回收" class="headerlink" title="new出的对象什么时候回收"></a>new出的对象什么时候回收</h2><p>由Java的垃圾回收器（Garbage Collector）负责回收。其工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。</p>
<p>回收的算法：</p>
<ul>
<li><strong>引用计数法</strong>：个对象的引用计数为0时，表示该对象不再被引用，可以被回收。</li>
<li><strong>可达性分析算法</strong>：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。</li>
<li><strong>终结器</strong>：如果对象重写了finalize()方法，垃圾回收器会在回收对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。但是由于终结器机制的执行时间不确定，可能会导致不可预测的问题，所以不推荐使用。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h2 id="反射的特性"><a href="#反射的特性" class="headerlink" title="反射的特性"></a>反射的特性</h2><ul>
<li><p><strong>运行时类信息访问</strong>：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。</p>
</li>
<li><p><strong>动态对象创建</strong>：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。</p>
</li>
<li><p><strong>动态方法调用</strong>：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。</p>
</li>
<li><p><strong>访问和修改字段值</strong>：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。</p>
</li>
</ul>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1718957173277-863d2ec6-a754-423b-9066-9f28610d1a31.png" alt="img"></p>
<h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><ul>
<li><strong>加载数据库驱动</strong></li>
</ul>
<p>我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。</p>
<p>这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>配置文件加载</strong></li>
</ul>
<p>Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p>
<p>Spring通过XML配置模式装载Bean的过程：</p>
<ul>
<li>将程序中所有XML或properties配置文件加载入内存</li>
<li>Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用反射机制，根据这个字符串获得某个类的Class实例</li>
<li>动态配置实例的属性</li>
</ul>
<p>配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.example.reflectdemo.TestInvoke</span><br><span class="line">methodName=printlnState</span><br></pre></td></tr></table></figure>

<p>实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printlnState</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am fine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析配置文件内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getName</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\IdeaProjects\AllDemos\language-specification\src\main\resources\application.properties&quot;</span>);</span><br><span class="line">    properties.load(in);</span><br><span class="line">    in.close();</span><br><span class="line">    <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;</span><br><span class="line">    <span class="comment">// 使用反射机制，根据这个字符串获得Class对象</span></span><br><span class="line">    Class&lt;?&gt; c = Class.forName(getName(<span class="string">&quot;className&quot;</span>));</span><br><span class="line">    System.out.println(c.getSimpleName());</span><br><span class="line">    <span class="comment">// 获取方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> c.getDeclaredMethod(getName(<span class="string">&quot;methodName&quot;</span>));</span><br><span class="line">    <span class="comment">// 绕过安全检查</span></span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    <span class="type">TestInvoke</span> <span class="variable">testInvoke</span> <span class="operator">=</span> (TestInvoke)c.newInstance();</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    method.invoke(testInvoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestInvoke</span><br><span class="line">I am fine</span><br></pre></td></tr></table></figure>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。</p>
<p>我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h2 id="注解的作用域"><a href="#注解的作用域" class="headerlink" title="注解的作用域"></a>注解的作用域</h2><p>注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：</p>
<ul>
<li><p>类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。</p>
</li>
<li><p>方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。</p>
</li>
<li><p>字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。</p>
</li>
</ul>
<p>除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="介绍一下异常"><a href="#介绍一下异常" class="headerlink" title="介绍一下异常"></a>介绍一下异常</h2><p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1720683900898-1d0ce69d-4b5d-41a6-a5df-022e42f8f4c5.webp" alt="img"></p>
<ul>
<li><strong>Error（错误）</strong>：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常程序不应该捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。</li>
<li><strong>Exception（异常）</strong>：表示程序本身可以处理的异常事件。<ul>
<li><strong>非运行时异常</strong>：在编译时必须被捕获或者声明抛出。通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。这种异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。</li>
<li><strong>运行时异常（RuntimeException）</strong>：由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。这种异常不需要在编译时强制捕获或声明。</li>
</ul>
</li>
</ul>
<h2 id="Java异常处理有哪些"><a href="#Java异常处理有哪些" class="headerlink" title="Java异常处理有哪些"></a>Java异常处理有哪些</h2><p>异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：</p>
<ul>
<li>try-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型1的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型2的逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType3 e3) &#123;</span><br><span class="line">    <span class="comment">// 处理异常类型3的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选的finally块，用于定义无论是否发生异常都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>throw语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ExceptionType(&quot;Exception message&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>throws关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抛出异常为什么不用throws"><a href="#抛出异常为什么不用throws" class="headerlink" title="抛出异常为什么不用throws"></a>抛出异常为什么不用throws</h2><p>如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。</p>
<ul>
<li><strong>Unchecked Exceptions</strong>：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。</li>
<li><strong>捕获和处理异常</strong>：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。</li>
</ul>
<h2 id="try-catch中的语句运行情况"><a href="#try-catch中的语句运行情况" class="headerlink" title="try-catch中的语句运行情况"></a>try-catch中的语句运行情况</h2><p>try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。</p>
<h2 id="try-return-“a”-fianlly-return-“b”-这条语句返回什么"><a href="#try-return-“a”-fianlly-return-“b”-这条语句返回什么" class="headerlink" title="try{return “a”} fianlly{return “b”}这条语句返回什么"></a>try{return “a”} fianlly{return “b”}这条语句返回什么</h2><p>finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。</p>
<h1 id="object"><a href="#object" class="headerlink" title="object"></a>object</h1><h2 id="与-equals-有什么区别？"><a href="#与-equals-有什么区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals 有什么区别？"></a>&#x3D;&#x3D; 与 equals 有什么区别？</h2><p>对于字符串变量来说，使用”=&#x3D;”和”equals”比较字符串时，其比较方法不同。”&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址，”equals”比较字符串包含内容是否相同。</p>
<p>对于非字符串变量来说，如果没有对equals()进行重写的话，”&#x3D;&#x3D;” 和 “equals”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。</p>
<ul>
<li>&#x3D;&#x3D;：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</li>
<li>equals()：比较的是两个字符串的内容，属于内容比较。</li>
</ul>
<h2 id="StringBuffer和StringBuild区别是什么？"><a href="#StringBuffer和StringBuild区别是什么？" class="headerlink" title="StringBuffer和StringBuild区别是什么？"></a>StringBuffer和StringBuild区别是什么？</h2><p>区别：</p>
<ul>
<li>String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</li>
<li>StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。</li>
<li>StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</li>
</ul>
<p>线程安全：</p>
<ul>
<li>StringBuffer：线程安全</li>
<li>StringBuilder：线程不安全</li>
</ul>
<p>速度：</p>
<ul>
<li>一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>操作少量的数据使用 String。</li>
<li>单线程操作大量数据使用 StringBuilder。</li>
<li>多线程操作大量数据使用 StringBuffer。</li>
</ul>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716098439957-a080de5a-d69e-4c6e-a5e8-111f976f9b5b.webp" alt="img"></p>
<h1 id="Java-1-8-新特性"><a href="#Java-1-8-新特性" class="headerlink" title="Java 1.8 新特性"></a>Java 1.8 新特性</h1><h2 id="stream的API"><a href="#stream的API" class="headerlink" title="stream的API"></a>stream的API</h2><p>Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理。</p>
<p>适用场景举例：</p>
<ul>
<li>场景一：过滤并收集满足条件的元素</li>
</ul>
<p>eg. 从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String item : originalList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        filteredList.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;fig&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredList = originalList.stream()</span><br><span class="line">                                        .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，我们直接在原始列表上调用.stream()方法创建了一个流，使用.filter()中间操作筛选出长度大于3的字符串，最后使用.collect(Collectors.toList())终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。</p>
<ul>
<li>场景二：计算列表中所有数字的总和</li>
</ul>
<p>eg. 计算一个数字列表中所有元素的总和。</p>
<p><strong>没有Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">    sum += number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。</p>
<p><strong>使用Stream API的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                 .mapToInt(Integer::intValue)</span><br><span class="line">                 .sum();</span><br></pre></td></tr></table></figure>

<p>通过Stream API，我们可以先使用.mapToInt()将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用.sum()方法来计算总和，极大地简化了代码。</p>
<h2 id="Stream流的并行API是什么？"><a href="#Stream流的并行API是什么？" class="headerlink" title="Stream流的并行API是什么？"></a>Stream流的并行API是什么？</h2><p>是 ParallelStream。</p>
<p>并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果。</p>
<p>Stream串行流与并行流的主要区别：</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716365522454-4b56a07e-9b54-4cbb-9832-26b099fc35cd.png" alt="img"></p>
<p>对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I&#x2F;O密集的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择。</p>
<h2 id="completableFuture怎么用的？"><a href="#completableFuture怎么用的？" class="headerlink" title="completableFuture怎么用的？"></a>completableFuture怎么用的？</h2><p>CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。</p>
<ul>
<li>Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。</li>
<li>CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。</li>
</ul>
<p>下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。</p>
<p>Future(ListenableFuture)的实现（回调地狱）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">guavaExecutor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(executor);</span><br><span class="line">ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//step 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);</span><br><span class="line">Futures.addCallback(future1And2, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Futures.addCallback(future3, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, guavaExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    &#125;&#125;, guavaExecutor);</span><br></pre></td></tr></table></figure>

<p>CompletableFuture的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step1 result&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step2 result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;</span><br><span class="line">    System.out.println(result1 + <span class="string">&quot; , &quot;</span> + result2);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行step 3&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;step3 result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result3 -&gt; System.out.println(result3));</span><br></pre></td></tr></table></figure>

<p>显然，CompletableFuture的实现更为简洁，可读性更好。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1713777049912-2268a5fc-c7f1-477d-8c9c-310aae18f51a.png" alt="img"></p>
<p>CompletableFuture实现了两个接口（如上图所示)：Future、CompletionStage。</p>
<ul>
<li>Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。</li>
<li>从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。</li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="怎么把一个对象从一个jvm转移到另一个jvm?"></a>怎么把一个对象从一个jvm转移到另一个jvm?</h2><ul>
<li><strong>使用序列化和反序列化</strong>：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。</li>
<li><strong>使用消息传递机制</strong>：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。</li>
<li><strong>使用远程方法调用（RPC）</strong>：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。</li>
<li><strong>使用共享数据库或缓存</strong>：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。</li>
</ul>
<h2 id="序列化和反序列化的缺点"><a href="#序列化和反序列化的缺点" class="headerlink" title="序列化和反序列化的缺点"></a>序列化和反序列化的缺点</h2><p>Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。</p>
<ul>
<li>无法跨语言： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。</li>
<li>容易被攻击：Java 序列化是不安全的，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。</li>
<li>序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。</li>
</ul>
<h2 id="那么该如何实现"><a href="#那么该如何实现" class="headerlink" title="那么该如何实现"></a>那么该如何实现</h2><p>考虑用主流序列化框架，比如FastJson、Protobuf来替代Java序列化。</p>
<p>如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。</p>
<h2 id="将对象转为二进制字节流具体怎么实现"><a href="#将对象转为二进制字节流具体怎么实现" class="headerlink" title="将对象转为二进制字节流具体怎么实现?"></a>将对象转为二进制字节流具体怎么实现?</h2><p>像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的<strong>处理和解析协议</strong>，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。</p>
<p>在Java中通过序列化对象流来完成序列化和反序列化：</p>
<ul>
<li>ObjectOutputStream：通过writeObject(）方法做序列化操作。</li>
<li>ObjectInputStrean：通过readObject()方法做反序列化操作。</li>
</ul>
<p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<p>实现对象序列化：</p>
<ul>
<li>让类实现Serializable接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// class code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建输出流并写入对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">    out.writeObject(obj);</span><br><span class="line">    out.close();</span><br><span class="line">    fileOut.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现对象反序列化：</p>
<ul>
<li>创建输入流并读取对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.ser&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">    newObj = (MyClass) in.readObject();</span><br><span class="line">    in.close();</span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="volatile和sychronized如何实现单例模式"><a href="#volatile和sychronized如何实现单例模式" class="headerlink" title="volatile和sychronized如何实现单例模式"></a>volatile和sychronized如何实现单例模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字修饰变量 防止指令重排序</span></span><br><span class="line">    private <span class="keyword">static</span> volatile <span class="title class_">SingleTon</span> instance = <span class="literal">null</span>;</span><br><span class="line">    private <span class="title class_">SingleTon</span>()&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    public <span class="keyword">static</span>  <span class="title class_">SingleTon</span> <span class="title function_">getInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步代码块 只有在第一次获取对象的时候会执行到，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦</span></span><br><span class="line">            <span class="title function_">synchronized</span>(<span class="params">SingleTon.<span class="keyword">class</span></span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。</p>
<ul>
<li>保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。</li>
<li>禁止指令重排序优化。</li>
</ul>
<p>由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。</p>
<h2 id="代理模式和适配器模式有什么区别？"><a href="#代理模式和适配器模式有什么区别？" class="headerlink" title="代理模式和适配器模式有什么区别？"></a>代理模式和适配器模式有什么区别？</h2><ul>
<li><strong>目的不同</strong>：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。</li>
<li><strong>结构不同</strong>：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。</li>
<li><strong>应用场景不同</strong>：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。</li>
</ul>
<h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Java怎么实现网络IO高并发编程？"><a href="#Java怎么实现网络IO高并发编程？" class="headerlink" title="Java怎么实现网络IO高并发编程？"></a><strong>Java怎么实现网络IO高并发编程？</strong></h2><p>可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112641716.png" alt="image-20240820112641716"></p>
<p>NIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/image-20240820112656259.png" alt="image-20240820112656259"></p>
<h2 id="BIO、NIO、AIO区别是什么？"><a href="#BIO、NIO、AIO区别是什么？" class="headerlink" title="BIO、NIO、AIO区别是什么？"></a>BIO、NIO、AIO区别是什么？</h2><ul>
<li>BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
<h2 id="NIO是怎么实现的？"><a href="#NIO是怎么实现的？" class="headerlink" title="NIO是怎么实现的？"></a>NIO是怎么实现的？</h2><p>NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。</p>
<p>同步的核心就Selector（I&#x2F;O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。</p>
<p>NIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。</p>
<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</p>
<p>Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1716018476312-e5525ca7-acf8-46b1-8fff-8a7d22db5304.webp" alt="img"></p>
<h2 id="有哪个框架用到NIO了吗？"><a href="#有哪个框架用到NIO了吗？" class="headerlink" title="有哪个框架用到NIO了吗？"></a>有哪个框架用到NIO了吗？</h2><p><strong>Netty。</strong></p>
<p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。</p>
<p><img src="/2024/10/17/Java%E5%9F%BA%E7%A1%80/1715424254674-7a7159b1-d1ed-4236-ae18-09421c9837ed.png" alt="img"></p>
<p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"><a href="#有一个学生类，想按照分数排序，再按学号排序，应该怎么做？" class="headerlink" title="有一个学生类，想按照分数排序，再按学号排序，应该怎么做？"></a>有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</h2><p>可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法和其他属性、方法省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.score != other.score) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(other.score, <span class="built_in">this</span>.score); <span class="comment">// 按照分数降序排序</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.id, other.id); <span class="comment">// 如果分数相同，则按照学号升序排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">// 添加学生对象到列表中</span><br><span class="line">Collections.sort(students);</span><br></pre></td></tr></table></figure>

<h2 id="Native方法解释一下"><a href="#Native方法解释一下" class="headerlink" title="Native方法解释一下"></a>Native方法解释一下</h2><p>在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。</p>
<p>在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现native方法，你需要完成以下步骤：</p>
<ol>
<li><strong>生成JNI头文件</strong>：使用javah工具从你的Java类生成C&#x2F;C++的头文件，这个头文件包含了所有native方法的原型。</li>
<li><strong>编写本地代码</strong>：使用C&#x2F;C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。</li>
<li><strong>编译本地代码</strong>：将C&#x2F;C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）</li>
<li><strong>加载本地库</strong>：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://Gentleshiao.github.io">Shi Jiahao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://gentleshiao.github.io/2024/10/17/Java%E5%9F%BA%E7%A1%80/">http://gentleshiao.github.io/2024/10/17/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Gentleshiao.github.io" target="_blank">珈豪の学习仓库</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B9/">面试必备知识点</a></div><div class="post_share"><div class="social-share" data-image="/img/java.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/17/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="/img/java.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java集合</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/" title="应用层"><img class="cover" src="/img/network.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">应用层</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/17/Java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="/img/java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-17</div><div class="title">Java集合</div></div></a></div><div><a href="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/" title="JVM经典面试题"><img class="cover" src="/img/java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-21</div><div class="title">JVM经典面试题</div></div></a></div><div><a href="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机"><img class="cover" src="/img/java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-01</div><div class="title">Java虚拟机</div></div></a></div><div><a href="/2024/07/28/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/" title="CPU的结构和功能"><img class="cover" src="/img/composition.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-28</div><div class="title">CPU的结构和功能</div></div></a></div><div><a href="/2024/08/14/%E5%BA%94%E7%94%A8%E5%B1%82/" title="应用层"><img class="cover" src="/img/network.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="title">应用层</div></div></a></div><div><a href="/2024/07/24/%E5%AD%98%E5%82%A8%E5%99%A8/" title="存储器"><img class="cover" src="/img/composition.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">存储器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Shi Jiahao</div><div class="author-info__description">不为更多人看到,只为记录自己成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Java的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">Java为什么是跨平台的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.</span> <span class="toc-text">JVM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E3%80%81JDK%E3%80%81JRE%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.</span> <span class="toc-text">JVM、JDK、JRE三者的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E8%A7%A3%E9%87%8A%E5%92%8C%E7%BC%96%E8%AF%91%E9%83%BD%E6%9C%89"><span class="toc-number">1.5.</span> <span class="toc-text">为什么Java解释和编译都有</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">编译型语言和解释型语言的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%92%8CJava%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">Python和Java区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">八种基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">数据类型转换方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%92%E8%BD%AC%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">类型互转会出现什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8bigDecimal%E8%80%8C%E4%B8%8D%E7%94%A8double"><span class="toc-number">2.4.</span> <span class="toc-text">为什么用bigDecimal而不用double</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">2.5.</span> <span class="toc-text">装箱和拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89Integer"><span class="toc-number">2.6.</span> <span class="toc-text">Java为什么要有Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E4%B8%8Eint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">Integer与int的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E7%95%99int%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.8.</span> <span class="toc-text">为什么要保留int类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E7%9A%84%E7%BC%93%E5%AD%98"><span class="toc-number">2.9.</span> <span class="toc-text">Integer的缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">怎么理解面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">3.2.</span> <span class="toc-text">面向对象三大特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">多态体现在哪几个方面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">多态解决了什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">3.5.</span> <span class="toc-text">面向对象的设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%99%AE%E9%80%9A%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">抽象类和普通类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">Java抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E5%90%A6%E5%8A%A0final%E4%BF%AE%E9%A5%B0"><span class="toc-number">3.9.</span> <span class="toc-text">抽象类能否加final修饰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.</span> <span class="toc-text">接口里面可以定义的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%83%BD%E5%90%A6%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">3.11.</span> <span class="toc-text">抽象类能否被实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%83%BD%E5%90%A6%E5%8C%85%E5%90%AB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.12.</span> <span class="toc-text">接口能否包含构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.</span> <span class="toc-text">静态变量和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.14.</span> <span class="toc-text">非静态内部类和静态内部类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84"><span class="toc-number">3.15.</span> <span class="toc-text">非静态内部类可以直接访问外部方法，编译器是怎么做到的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E9%9D%99%E6%80%81%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9C%A8%E6%88%91new%E4%B8%80%E4%B8%AA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">3.16.</span> <span class="toc-text">有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">实现深拷贝的三种方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">什么是泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">为什么需要泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%99%A4%E4%BA%86new%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Java创建对象除了new还有什么方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%87%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6"><span class="toc-number">6.3.</span> <span class="toc-text">new出的对象什么时候回收</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">7.1.</span> <span class="toc-text">什么是反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">反射的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.3.</span> <span class="toc-text">反射的应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">注解的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.2.</span> <span class="toc-text">注解的作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">9.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%BC%82%E5%B8%B8"><span class="toc-number">9.1.</span> <span class="toc-text">介绍一下异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.2.</span> <span class="toc-text">Java异常处理有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8throws"><span class="toc-number">9.3.</span> <span class="toc-text">抛出异常为什么不用throws</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch%E4%B8%AD%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5"><span class="toc-number">9.4.</span> <span class="toc-text">try-catch中的语句运行情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-return-%E2%80%9Ca%E2%80%9D-fianlly-return-%E2%80%9Cb%E2%80%9D-%E8%BF%99%E6%9D%A1%E8%AF%AD%E5%8F%A5%E8%BF%94%E5%9B%9E%E4%BB%80%E4%B9%88"><span class="toc-number">9.5.</span> <span class="toc-text">try{return “a”} fianlly{return “b”}这条语句返回什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#object"><span class="toc-number">10.</span> <span class="toc-text">object</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-equals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">&#x3D;&#x3D; 与 equals 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuild%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">StringBuffer和StringBuild区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-1-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">Java 1.8 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream%E7%9A%84API"><span class="toc-number">11.1.</span> <span class="toc-text">stream的API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E7%9A%84%E5%B9%B6%E8%A1%8CAPI%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">Stream流的并行API是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completableFuture%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">completableFuture怎么用的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BB%8E%E4%B8%80%E4%B8%AAjvm%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAjvm"><span class="toc-number">12.1.</span> <span class="toc-text">怎么把一个对象从一个jvm转移到另一个jvm?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">12.2.</span> <span class="toc-text">序列化和反序列化的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.3.</span> <span class="toc-text">那么该如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.4.</span> <span class="toc-text">将对象转为二进制字节流具体怎么实现?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%92%8Csychronized%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">volatile和sychronized如何实现单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">代理模式和适配器模式有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O"><span class="toc-number">14.</span> <span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9CIO%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">Java怎么实现网络IO高并发编程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">BIO、NIO、AIO区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">NIO是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%B8%AA%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0NIO%E4%BA%86%E5%90%97%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">有哪个框架用到NIO了吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">15.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AD%A6%E7%94%9F%E7%B1%BB%EF%BC%8C%E6%83%B3%E6%8C%89%E7%85%A7%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%86%8D%E6%8C%89%E5%AD%A6%E5%8F%B7%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">有一个学生类，想按照分数排序，再按学号排序，应该怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="toc-number">15.2.</span> <span class="toc-text">Native方法解释一下</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/" title="JVM经典面试题"><img src="/img/java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM经典面试题"/></a><div class="content"><a class="title" href="/2025/02/21/JVM%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98/" title="JVM经典面试题">JVM经典面试题</a><time datetime="2025-02-21T12:12:01.000Z" title="发表于 2025-02-21 20:12:01">2025-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机"><img src="/img/java.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java虚拟机"/></a><div class="content"><a class="title" href="/2025/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" title="Java虚拟机">Java虚拟机</a><time datetime="2025-02-01T13:22:01.000Z" title="发表于 2025-02-01 21:22:01">2025-02-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/04/web%E5%BC%80%E5%8F%91/" title="Web开发"><img src="/img/web.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web开发"/></a><div class="content"><a class="title" href="/2024/11/04/web%E5%BC%80%E5%8F%91/" title="Web开发">Web开发</a><time datetime="2024-11-04T13:22:01.000Z" title="发表于 2024-11-04 21:22:01">2024-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/01/MySQL/" title="MySQL"><img src="/img/web.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL"/></a><div class="content"><a class="title" href="/2024/11/01/MySQL/" title="MySQL">MySQL</a><time datetime="2024-11-01T13:22:01.000Z" title="发表于 2024-11-01 21:22:01">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/30/Mybatis/" title="Mybatis"><img src="/img/web.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis"/></a><div class="content"><a class="title" href="/2024/10/30/Mybatis/" title="Mybatis">Mybatis</a><time datetime="2024-10-30T13:22:01.000Z" title="发表于 2024-10-30 21:22:01">2024-10-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/java.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Shi Jiahao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":240,"height":480},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body></html>